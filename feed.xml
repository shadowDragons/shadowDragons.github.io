<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ben Blog</title>
    <description>一个小白的成长学习历程</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sat, 15 Dec 2018 22:29:19 +0800</pubDate>
    <lastBuildDate>Sat, 15 Dec 2018 22:29:19 +0800</lastBuildDate>
    <generator>Jekyll v3.8.4</generator>
    
      <item>
        <title>「Docker」基础</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;本篇主要让大家知道如何安装、 Docker的基本知识点、Docker的基本使用&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;安装&quot;&gt;安装&lt;/h3&gt;

&lt;h4 id=&quot;docker&quot;&gt;Docker&lt;/h4&gt;

&lt;p&gt;由于我本机是mac系统，所以这里以mac安装为例子。其他系统的安装请自行查看&lt;a href=&quot;https://docs.docker.com/&quot;&gt;官方文档&amp;gt;&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;进入&lt;a href=&quot;https://docs.docker.com/docker-for-mac/install/&quot;&gt;官网下载页面&amp;gt;&lt;/a&gt;下载。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/img/posts/2018-11-12-docker-base/1.jpg&quot;&gt;&lt;img src=&quot;/assets/img/posts/2018-11-12-docker-base/1.jpg&quot; alt=&quot;1.jpg&quot; title=&quot;点击查看原图&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;下载完成后，直接安装。&lt;/p&gt;

&lt;p&gt;完成后，直接打开Docker应用程序，如果这时顶部导航会显示Docker图标，说明已经启动了。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/img/posts/2018-11-12-docker-base/2.jpg&quot;&gt;&lt;img src=&quot;/assets/img/posts/2018-11-12-docker-base/2.jpg&quot; alt=&quot;2.jpg&quot; title=&quot;点击查看原图&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;查看版本，输入以下命令查看。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/img/posts/2018-11-12-docker-base/3.jpg&quot;&gt;&lt;img src=&quot;/assets/img/posts/2018-11-12-docker-base/3.jpg&quot; alt=&quot;3.jpg&quot; title=&quot;点击查看原图&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;kitematic&quot;&gt;Kitematic&lt;/h4&gt;

&lt;p&gt;Kitematic是Docker可视化界面工具，可以很轻易的来管理容器。&lt;/p&gt;

&lt;p&gt;点击顶部导航&lt;code class=&quot;highlighter-rouge&quot;&gt;Docker&lt;/code&gt;图标，在下拉菜单中选中&lt;code class=&quot;highlighter-rouge&quot;&gt;Kitematic&lt;/code&gt;，即可下载。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/img/posts/2018-11-12-docker-base/4.jpg&quot;&gt;&lt;img src=&quot;/assets/img/posts/2018-11-12-docker-base/4.jpg&quot; alt=&quot;4.jpg&quot; title=&quot;点击查看原图&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;下载完成，直接解压并拖到应用程序即可。&lt;/p&gt;

&lt;h3 id=&quot;基本概念&quot;&gt;基本概念&lt;/h3&gt;

&lt;h4 id=&quot;镜像image&quot;&gt;镜像（Image）&lt;/h4&gt;

&lt;p&gt;镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。&lt;/p&gt;

&lt;h4 id=&quot;容器container&quot;&gt;容器（Container）&lt;/h4&gt;

&lt;p&gt;镜像和容器的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。&lt;/p&gt;

&lt;p&gt;容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。也因为这种隔离的特性，很多人初学 Docker 时常常会混淆容器和虚拟机。&lt;/p&gt;

&lt;h4 id=&quot;仓库repository&quot;&gt;仓库（Repository）&lt;/h4&gt;

&lt;p&gt;镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry 就是这样的服务。&lt;/p&gt;

&lt;p&gt;一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Docker Registry&lt;/code&gt;中可以包含多个仓库；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。&lt;/p&gt;

&lt;p&gt;通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 &lt;仓库名&gt;:&lt;标签&gt; 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。&lt;/标签&gt;&lt;/仓库名&gt;&lt;/p&gt;

&lt;h3 id=&quot;使用镜像&quot;&gt;使用镜像&lt;/h3&gt;

&lt;h3 id=&quot;使用容器&quot;&gt;使用容器&lt;/h3&gt;

</description>
        <pubDate>Mon, 12 Nov 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/11/12/docker-base/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/11/12/docker-base/</guid>
        
        <category>docker</category>
        
        
      </item>
    
      <item>
        <title>“老鼠试药”算法</title>
        <description>&lt;p&gt;昨天在网上看到一个视频，看到了一个很有趣的算法，赶紧记录下来。&lt;/p&gt;

&lt;h4 id=&quot;老鼠试药&quot;&gt;“老鼠试药”&lt;/h4&gt;

&lt;p&gt;题目是这样的：有100瓶药水，只有1瓶毒药。毒性发作需要1周时间，请问至少需要机智老鼠才能用1周时间找到那瓶毒药。&lt;/p&gt;

&lt;p&gt;我们可以用二进制来轻松的解决这个问题。&lt;/p&gt;

&lt;p&gt;1、首先把100瓶药水按1到100排号。&lt;br /&gt;
2、将序号转换为二进制。如下表所示：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;药品序号&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;二进制&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;0000001&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;0000010&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;…&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;…&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;100&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;1100100&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;3、可以看到，这些二进制总共有7位，所以我们只需要7只老鼠，每只老鼠喝对应位置为1的毒药，如果老鼠死亡，则把对应位置为1，否则置为0。&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;位数1&lt;/td&gt;
      &lt;td&gt;位数2&lt;/td&gt;
      &lt;td&gt;位数3&lt;/td&gt;
      &lt;td&gt;位数4&lt;/td&gt;
      &lt;td&gt;位数5&lt;/td&gt;
      &lt;td&gt;位数6&lt;/td&gt;
      &lt;td&gt;位数7&lt;/td&gt;
      &lt;td&gt;对应序号&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;.&lt;/td&gt;
      &lt;td&gt;.&lt;/td&gt;
      &lt;td&gt;.&lt;/td&gt;
      &lt;td&gt;.&lt;/td&gt;
      &lt;td&gt;.&lt;/td&gt;
      &lt;td&gt;.&lt;/td&gt;
      &lt;td&gt;.&lt;/td&gt;
      &lt;td&gt;.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;100&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1号老鼠&lt;/td&gt;
      &lt;td&gt;2号老鼠&lt;/td&gt;
      &lt;td&gt;3号老鼠&lt;/td&gt;
      &lt;td&gt;4号老鼠&lt;/td&gt;
      &lt;td&gt;5号老鼠&lt;/td&gt;
      &lt;td&gt;6号老鼠&lt;/td&gt;
      &lt;td&gt;7号老鼠&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;举个例子，如果第3，4，7号到老鼠死亡，则可以算出二进制数为0011001的药瓶有毒，也即是25号。&lt;/p&gt;

&lt;h4 id=&quot;奇数枪毙&quot;&gt;“奇数枪毙”&lt;/h4&gt;

&lt;p&gt;有100个人按序号排列，从序号1开始依次报数，念到奇数的枪毙。剩余的人重新按序号排列，依次执行。问如果想活命，应该一开始站在哪一序号？&lt;/p&gt;

&lt;p&gt;这个问题我们依旧可以用二进制来解决这个问题。&lt;/p&gt;

&lt;p&gt;1、先列出100个人对应序号的二进制&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;序号&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;二进制&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;0000001&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;0000010&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;…&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;…&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;100&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;1100100&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;2、从这里可以看出，末位为1的人需要被枪毙。&lt;br /&gt;
3、接下来剩余的人都是末位为0，由于需要重新排序，新的序号刚好是去掉末位后的数。所以我们把那些人到末位去掉，再按照第2步的逻辑枪毙，以此类推。&lt;br /&gt;
4、所以我们得出1000000会是最后胜出的人，即一开始序号为64的人。&lt;/p&gt;

</description>
        <pubDate>Mon, 29 Oct 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/10/29/mouse-algorithm/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/10/29/mouse-algorithm/</guid>
        
        <category>算法</category>
        
        
      </item>
    
      <item>
        <title>swoole 学习笔记</title>
        <description>&lt;p&gt;最近需要用到多进程处理任务，先学习一番。&lt;/p&gt;

&lt;h3 id=&quot;安装&quot;&gt;安装&lt;/h3&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pecl &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;swoole
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;安装遇到的问题&quot;&gt;安装遇到的问题&lt;/h5&gt;

&lt;p&gt;我选择了支持openssl，安装过程中遇到了两个错误&lt;/p&gt;

&lt;p&gt;1、 &lt;code class=&quot;highlighter-rouge&quot;&gt;fatal error: 'openssl/ssl.h' file not found&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;解决方法： &lt;br /&gt;
一般用brew安装的软件，都会把需要include的文件自动放到/usr/local/include里的，但是不知为什么安装openssl的时候没有放到那里。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cp -R /usr/local/opt/openssl/include/openssl /usr/local/include&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ln -s /usr/local/opt/openssl/include/openssl /usr/local/include/openssl&lt;/code&gt;（推荐）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;2、&lt;code class=&quot;highlighter-rouge&quot;&gt;Enable openssl support, require openssl library.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;查看 openssl 信息 &lt;code class=&quot;highlighter-rouge&quot;&gt;brew info openssl&lt;/code&gt;，可以查看一下信息&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;For compilers to find openssl you may need to &lt;span class=&quot;nb&quot;&gt;set&lt;/span&gt;:
  &lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;LDFLAGS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;-L/usr/local/opt/openssl/lib&quot;&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;CPPFLAGS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;-I/usr/local/opt/openssl/include&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;添加环境变量即可修复这个问题。&lt;/p&gt;

&lt;h3 id=&quot;多进程&quot;&gt;多进程&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://wiki.swoole.com/wiki/page/p-process.html&quot;&gt;官方文档&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;language-php highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?php&lt;/span&gt;

&lt;span class=&quot;nv&quot;&gt;$url_arr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;$url_arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;www.baidu.com?wd=&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nv&quot;&gt;$workers&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 创建子进程&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;$process&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;swoole_process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'getContents'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;$pid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$process&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// 向管道内写入数据&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;$process&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;$workers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$pid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//主进程数据结果&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;foreach&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$workers&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$process&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;PHP_EOL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getContents&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;swoole_process&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$worker&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 从管道中读取数据&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;$i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$worker&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;global&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$url_arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;$res1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;execCurl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$url_arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]);&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rand&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;$res2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;execCurl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$url_arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$res1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;PHP_EOL&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$res2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;execCurl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;handle &quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$url&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot; finished&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;////回收子进程&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$workers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)){&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;foreach&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$workers&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$pid&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$worker&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;nv&quot;&gt;$ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;swoole_process&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;worker exit: &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$pid&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;nb&quot;&gt;unset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$workers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$pid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Mon, 15 Oct 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/10/15/swoole-note/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/10/15/swoole-note/</guid>
        
        <category>php</category>
        
        
      </item>
    
      <item>
        <title>『构建高性能web站点』浏览器缓存</title>
        <description>&lt;p&gt;我们可以通过http头信息来实现浏览器缓存。&lt;/p&gt;

&lt;h3 id=&quot;last-modified&quot;&gt;Last-Modified&lt;/h3&gt;

&lt;p&gt;这种信息需要后台来判定是否过期。流程如下：&lt;/p&gt;

&lt;script src=&quot;/assets/js/mermaid.js&quot;&gt;&lt;/script&gt;
&lt;div class=&quot;mermaid&quot;&gt;
sequenceDiagram;
    participant 客户端
    participant 服务端
    客户端-&amp;gt;服务端: 请求静态文件
    服务端-&amp;gt;客户端: 返回头信息 Last-Modified: {最后修改时间} GMT
    Note left of 客户端: 确认文件是否过期
    客户端-&amp;gt;服务端: 返回头信息If-Modified-Since: {上一步获取的最后修改时间} GMT 
    Note right of 服务端: 获取客户端的头信息，根据设定的过期时间判断
    服务端-&amp;gt;客户端: 返回静态文件是否过期
&lt;/div&gt;

&lt;p&gt;缺点：需要请求服务器，确认是否过期&lt;/p&gt;

&lt;h3 id=&quot;etag&quot;&gt;ETag&lt;/h3&gt;

&lt;p&gt;同样需要后台来判定是否过期。流程如下：&lt;/p&gt;

&lt;script src=&quot;/assets/js/mermaid.js&quot;&gt;&lt;/script&gt;
&lt;div class=&quot;mermaid&quot;&gt;
sequenceDiagram;
    participant 客户端
    participant 服务端
    客户端-&amp;gt;服务端: 请求静态文件
    服务端-&amp;gt;客户端: 返回头信息 ETag: {根据文件内容计算出来的值} 
    Note left of 客户端: 确认文件是否过期
    客户端-&amp;gt;服务端: 返回头信息If-None-Match: {上一步获取的ETag值}
    Note right of 服务端: 获取客户端的头信息，计算目前文件内容的ETag值做对比
    服务端-&amp;gt;客户端: 返回静态文件是否过期
&lt;/div&gt;

&lt;p&gt;缺点：需要请求服务器，确认是否过期&lt;/p&gt;

&lt;h3 id=&quot;expires&quot;&gt;Expires&lt;/h3&gt;

&lt;p&gt;这种方式可以彻底消灭服务器请求，流程如下：&lt;/p&gt;

&lt;script src=&quot;/assets/js/mermaid.js&quot;&gt;&lt;/script&gt;
&lt;div class=&quot;mermaid&quot;&gt;
sequenceDiagram;
    participant 客户端
    participant 服务端
    客户端-&amp;gt;服务端: 请求静态文件
    服务端-&amp;gt;客户端: 返回头信息 Expires: {过期时间} GMT
    loop 判断过期
        客户端-&amp;gt;客户端: 根据Expires过期时间判断
    end
&lt;/div&gt;

&lt;p&gt;缺点：依赖本地时间、无法实时更新静态文件内容。&lt;/p&gt;

&lt;h3 id=&quot;cache-control&quot;&gt;Cache-control&lt;/h3&gt;

&lt;p&gt;HTTP1.1 的Cache-control可以弥补Expires依赖本地时间的不足。格式如下：&lt;/p&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Cache-control: max-age=&lt;span class=&quot;nt&quot;&gt;&amp;lt;second&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;max-age&lt;/code&gt;指定了缓存过期的相对时间，单位秒，并且是相对于本地时间。浏览器根据本地当前时间是否大于max-age+上次访问时间&lt;/p&gt;

&lt;p&gt;流程如下：&lt;/p&gt;

&lt;script src=&quot;/assets/js/mermaid.js&quot;&gt;&lt;/script&gt;
&lt;div class=&quot;mermaid&quot;&gt;
sequenceDiagram;
    participant 客户端
    participant 服务端
    客户端-&amp;gt;服务端: 请求静态文件
    服务端-&amp;gt;客户端: 返回头信息 Expires: {过期时间} GMT、Cache-control: max-age={有效时长}
    loop 判断过期
        客户端-&amp;gt;客户端: 优先判断max-age
    end
&lt;/div&gt;
</description>
        <pubDate>Thu, 11 Oct 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/10/11/bhpws-brower-cache/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/10/11/bhpws-brower-cache/</guid>
        
        <category>web</category>
        
        
      </item>
    
      <item>
        <title>系统调用跟踪 - strace、dtruss</title>
        <description>&lt;h3 id=&quot;linux工具strace&quot;&gt;linux工具strace&lt;/h3&gt;

&lt;h5 id=&quot;语法&quot;&gt;语法&lt;/h5&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;strace [-dffhiqrtttTvVxx] [-a column] [-e expr] ... [-o file]

              [-p pid] ... [-s strsize] [-u username] [-E var&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;val] ...

              [command [arg ...]]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;或者&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;strace &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-e&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;expr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; ... &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-O&lt;/span&gt; overhead] &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-S&lt;/span&gt; sortby] &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-E&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;val] ...

              &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;command&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;arg ...]]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;参数说明&quot;&gt;参数说明&lt;/h5&gt;

&lt;p&gt;-c 统计每一系统调用的所执行的时间,次数和出错的次数等.&lt;/p&gt;

&lt;p&gt;-d 输出strace关于标准错误的调试信息.&lt;/p&gt;

&lt;p&gt;-f 跟踪由fork调用所产生的子进程.&lt;/p&gt;

&lt;p&gt;-ff 如果提供-o filename,则所有进程的跟踪结果输出到相应的filename.pid中,pid是各进程的进程号.&lt;/p&gt;

&lt;p&gt;-F 尝试跟踪vfork调用.在-f时,vfork不被跟踪.&lt;/p&gt;

&lt;p&gt;-h 输出简要的帮助信息.&lt;/p&gt;

&lt;p&gt;-i 输出系统调用的入口指针.&lt;/p&gt;

&lt;p&gt;-q 禁止输出关于脱离的消息.&lt;/p&gt;

&lt;p&gt;-r 打印出相对时间关于每一个系统调用.&lt;/p&gt;

&lt;p&gt;-t 在输出中的每一行前加上时间信息.&lt;/p&gt;

&lt;p&gt;-tt 在输出中的每一行前加上时间信息,微秒级.&lt;/p&gt;

&lt;p&gt;-ttt 微秒级输出,以秒了表示时间.&lt;/p&gt;

&lt;p&gt;-T 显示每一调用所耗的时间.&lt;/p&gt;

&lt;p&gt;-v 输出所有的系统调用.一些调用关于环境变量,状态,输入输出等调用由于使用频繁,默认不输出.&lt;/p&gt;

&lt;p&gt;-V 输出strace的版本信息.&lt;/p&gt;

&lt;p&gt;-x 以十六进制形式输出非标准字符串.&lt;/p&gt;

&lt;p&gt;-xx 所有字符串以十六进制形式输出.&lt;/p&gt;

&lt;p&gt;-a column 设置返回值的输出位置.默认 为40.&lt;/p&gt;

&lt;p&gt;-e expr 指定一个表达式,用来控制如何跟踪.格式如下:&lt;/p&gt;

&lt;p&gt;[qualifier=][!]value1[,value2]…&lt;/p&gt;

&lt;p&gt;qualifier只能是 trace,abbrev,verbose,raw,signal,read,write其中之一.value是用来限定的符号或数字.默认的 qualifier是 trace.感叹号是否定符号.例如-eopen等价于 -e trace=open,表示只跟踪open调用.而-etrace!=open表示跟踪除了open以外的其它调用.有两个特殊的符号 all 和 none. 注意有些shell使用!来执行历史记录里的命令,所以要使用\.&lt;/p&gt;

&lt;p&gt;-e trace=set 只跟踪指定的系统调用.例如:-e trace=open,close,rean,write表示只跟踪这四个系统调用.默认的为set=all.&lt;/p&gt;

&lt;p&gt;-e trace=file 只跟踪有关文件操作的系统调用.&lt;/p&gt;

&lt;p&gt;-e trace=process 只跟踪有关进程控制的系统调用.&lt;/p&gt;

&lt;p&gt;-e trace=network 跟踪与网络有关的所有系统调用.&lt;/p&gt;

&lt;p&gt;-e strace=signal 跟踪所有与系统信号有关的系统调用.&lt;/p&gt;

&lt;p&gt;-e trace=ipc 跟踪所有与进程通讯有关的系统调用.&lt;/p&gt;

&lt;p&gt;-e abbrev=set 设定strace输出的系统调用的结果集.-v 等与 abbrev=none.默认为abbrev=all.&lt;/p&gt;

&lt;p&gt;-e raw=set 将指定的系统调用的参数以十六进制显示.&lt;/p&gt;

&lt;p&gt;-e signal=set 指定跟踪的系统信号.默认为all.如 signal=!SIGIO(或者signal=!io),表示不跟踪SIGIO信号.&lt;/p&gt;

&lt;p&gt;-e read=set 输出从指定文件中读出的数据.例如-e read=3,5&lt;/p&gt;

&lt;p&gt;-e write=set 输出写入到指定文件中的数据.&lt;/p&gt;

&lt;p&gt;-o filename 将strace的输出写入文件filename&lt;/p&gt;

&lt;p&gt;-p pid 跟踪指定的进程pid.&lt;/p&gt;

&lt;p&gt;-s strsize 指定输出的字符串的最大长度.默认为32.文件名一直全部输出.&lt;/p&gt;

&lt;p&gt;-u username 以username 的UID和GID执行被跟踪的命令.&lt;/p&gt;

&lt;h5 id=&quot;例子&quot;&gt;例子&lt;/h5&gt;

&lt;p&gt;&lt;a href=&quot;https://huoding.com/2013/10/06/288&quot;&gt;通过Strace定位故障原因&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;mac工具dtruss&quot;&gt;mac工具dtruss&lt;/h3&gt;

&lt;h5 id=&quot;语法-1&quot;&gt;语法&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dtruss [-acdefholLs] [-t syscall] { -p PID | -n name | command | -W name }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;参数说明-1&quot;&gt;参数说明&lt;/h5&gt;

&lt;p&gt;-a 输出全部&lt;/p&gt;

&lt;p&gt;-b bufsize&lt;br /&gt;
dynamic variable buffer size. Increase this if you notice
dynamic variable drop errors. The default is “4m” for 4
megabytes per CPU.&lt;/p&gt;

&lt;p&gt;-c 输出系统调用数&lt;/p&gt;

&lt;p&gt;-d 输出时间消耗&lt;/p&gt;

&lt;p&gt;-e 输出剩余多少时间&lt;/p&gt;

&lt;p&gt;-f 监视fork出来的进程调用&lt;/p&gt;

&lt;p&gt;-l force printing of pid/lwpid per line&lt;/p&gt;

&lt;p&gt;-L don’t print pid/lwpid per line&lt;/p&gt;

&lt;p&gt;-n name 跟踪名为name的进程&lt;/p&gt;

&lt;p&gt;-o 输出花在cpu上的时间&lt;/p&gt;

&lt;p&gt;-s 输出栈跟踪&lt;/p&gt;

&lt;p&gt;-p PID 监视某个pid&lt;/p&gt;

&lt;p&gt;-t syscall 只监视某个系统调用&lt;/p&gt;

&lt;h5 id=&quot;例子-1&quot;&gt;例子&lt;/h5&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dtruss &lt;span class=&quot;nb&quot;&gt;df&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-h&lt;/span&gt;       &lt;span class=&quot;c&quot;&gt;# run and examine &quot;df -h&quot;  &lt;/span&gt;
dtruss &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; 1871     &lt;span class=&quot;c&quot;&gt;# examine PID 1871  &lt;/span&gt;
dtruss &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;tar&lt;/span&gt;      &lt;span class=&quot;c&quot;&gt;# examine all processes called &quot;tar&quot;  &lt;/span&gt;
dtruss &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; test.sh  &lt;span class=&quot;c&quot;&gt;# run test.sh and follow children&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;参考&quot;&gt;参考&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_38712943/article/details/82149045&quot;&gt;strace&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/kfy2011/article/details/48102843&quot;&gt;系统调用跟踪命令strace和dtruss&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 07 Oct 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/10/07/strace-dtruss/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/10/07/strace-dtruss/</guid>
        
        <category>工具</category>
        
        
      </item>
    
      <item>
        <title>smarty缓存应用</title>
        <description>&lt;h3 id=&quot;执行流程&quot;&gt;执行流程&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;/assets/img/posts/2018-10-07-smarty/1.jpg&quot;&gt;&lt;img src=&quot;/assets/img/posts/2018-10-07-smarty/1.jpg&quot; alt=&quot;1.jpg&quot; title=&quot;点击查看原图&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;开启缓存&quot;&gt;开启缓存&lt;/h3&gt;

&lt;div class=&quot;language-php highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$smarty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;caching&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$smarty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;cache_lifetime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3600&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;判断是否已有缓存&lt;/p&gt;

&lt;div class=&quot;language-php highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$smarty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isCached&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'index.htm'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;$smarty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;display&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'index.htm'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// do something&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$smarty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;display&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'index.htm'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;清除缓存&quot;&gt;清除缓存&lt;/h3&gt;

&lt;h5 id=&quot;单个页面缓存&quot;&gt;单个页面缓存&lt;/h5&gt;

&lt;div class=&quot;language-php highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$smarty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;clearCache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'index.htm'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;全部页面缓存&quot;&gt;全部页面缓存&lt;/h5&gt;

&lt;div class=&quot;language-php highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$smarty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;clearAllCache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;局部缓存&quot;&gt;局部缓存&lt;/h3&gt;

&lt;h5 id=&quot;变量&quot;&gt;变量&lt;/h5&gt;

&lt;div class=&quot;language-php highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 第三个参数 true 表示不缓存&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$smarty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;assign&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'var'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'value'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;模板变量&quot;&gt;模板变量&lt;/h5&gt;

&lt;div class=&quot;language-smarty highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$num&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;nocache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;模板局部&quot;&gt;模板局部&lt;/h5&gt;

&lt;div class=&quot;language-smarty highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;nocache&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;div&amp;gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$title&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;br/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;div&amp;gt;&lt;/span&gt;评论数：&lt;span class=&quot;k&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$num&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;{/&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;nocache&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;单页面多缓存&quot;&gt;单页面多缓存&lt;/h3&gt;

&lt;p&gt;display拥有第二个参数，我们可以把需要改变的变量放入第二个参数就可以实现根据不同的请求生成不同的缓存！常用于详细内容页。&lt;/p&gt;

&lt;div class=&quot;language-php highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$smarty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;display&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'index.htm'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//集合&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$smarty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;display&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'index.htm'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$id1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'|'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$id2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;局限性&quot;&gt;局限性&lt;/h3&gt;

&lt;p&gt;1.当缓存文件过多，cpu需要耗在遍历文件。&lt;/p&gt;

&lt;p&gt;可以通过设置支持目录分级&lt;/p&gt;

&lt;div class=&quot;language-php highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$smarty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;use_sub_dirs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;2.缓存文件存在I/O消耗。&lt;/p&gt;

&lt;p&gt;可以把缓存内容存到内存中。&lt;/p&gt;

&lt;h3 id=&quot;参考&quot;&gt;参考&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://jingyan.baidu.com/album/ea24bc39c0d376da62b331a4.html?picindex=1&quot;&gt;Smarty缓存技术完整的执行流程&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 07 Oct 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/10/07/smarty-cache/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/10/07/smarty-cache/</guid>
        
        <category>php</category>
        
        
      </item>
    
      <item>
        <title>php加速器</title>
        <description>&lt;h3 id=&quot;opcache推荐&quot;&gt;opcache(推荐)&lt;/h3&gt;

&lt;p&gt;新一代PHP加速器，由Zend公司研发，其实现原理与Xcache类似，都是把PHP执行后的数据缓冲到内存中从而避免重复的编译过程，能够直接使用缓冲区已编译的代码从而提高速度，降低服务器负载，但性能却比Xcache更加优越。&lt;/p&gt;

&lt;p&gt;PHP 5.5.0 及后续版本中已经绑定了 opcache 扩展。 对于 PHP 5.2，5.3 和 5.4 版本可以使用PECL扩展中的 opcache 库。&lt;/p&gt;

&lt;h5 id=&quot;配置说明&quot;&gt;配置说明&lt;/h5&gt;

&lt;div class=&quot;language-ini highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;py&quot;&gt;opcache.enable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;1 (default &quot;1&quot;)&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;;OPcache打开/关闭开关。当设置为Off或者0时，会关闭Opcache, 代码没有被优化和缓存。
&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;opcache.enable_cli&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;1 (default &quot;0&quot;)&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;;CLI环境下，PHP启用OPcache。这主要是为了测试和调试。从 PHP 7.1.2 开始，默认启用。
&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;opcache.memory_consumption&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;128 (default &quot;64&quot;)&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;;OPcache共享内存存储大小。用于存储预编译的opcode（以MB为单位）。
&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;opcache.interned_strings_buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;8 (default &quot;4&quot;)&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;;这是一个很有用的选项，但是似乎完全没有文档说明。PHP使用了一种叫做字符串驻留（string interning）的技术来改善性能。例如，如果你在代码中使用了1000次字符串“foobar”，在PHP内部只会在第一使用这个字符串的时候分配一个不可变的内存区域来存储这个字符串，其他的999次使用都会直接指向这个内存区域。这个选项则会把这个特性提升一个层次——默认情况下这个不可变的内存区域只会存在于单个php-fpm的进程中，如果设置了这个选项，那么它将会在所有的php-fpm进程中共享。在比较大的应用中，这可以非常有效地节约内存，提高应用的性能。
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;这个选项的值是以兆字节（megabytes）作为单位，如果把它设置为16，则表示16MB，默认是4MB，这是一个比较低的值。&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;opcache.max_accelerated_files&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;(default&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&quot;2000&quot;)&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;;这个选项用于控制内存中最多可以缓存多少个PHP文件。这个选项必须得设置得足够大，大于你的项目中的所有PHP文件的总和。
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;设置值取值范围最小值是&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;200，最大值在&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;PHP&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;5.5.6&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;之前是&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;100000，PHP&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;5.5.6&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;及之后是&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;1000000。也就是说在200到1000000之间。&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;你可以运行“find&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-type&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-print&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;grep&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;php&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;wc&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-l”这个命令来快速计算你的代码库中的PHP文件数。&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;opcache.max_wasted_percentage&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;(default&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&quot;5&quot;)&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;;计划重新启动之前，“浪费”内存的最大百分比。
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;opcache.use_cwd&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;(default&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&quot;1&quot;)&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;;如果启用，OPcache将在哈希表的脚本键之后附加改脚本的工作目录， 以避免同名脚本冲突的问题。禁用此选项可以提高性能，但是可能会导致应用崩溃
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;opcache.validate_timestamps&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;(default&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&quot;1&quot;)&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;;如果启用（设置为1），OPcache会在opcache.revalidate_freq设置的秒数去检测文件的时间戳（timestamp）检查脚本是否更新。
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;如果这个选项被禁用（设置为0），opcache.revalidate_freq会被忽略，PHP文件永远不会被检查。这意味着如果你修改了你的代码，然后你把它更新到服务器上，再在浏览器上请求更新的代码对应的功能，你会看不到更新的效果，你必须使用&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;`opcache_reset()`&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;或者&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;`opcache_invalidate()`&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;函数来手动重置&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;OPcache。或者重重你的web服务器或者php-fpm&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;来使文件系统更改生效。&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;我强烈建议你在生产环境中设置为0，why？因为当你在更新服务器代码的时候，如果代码较多，更新操作是有些延迟的，在这个延迟的过程中必然出现老代码和新代码混合的情况，这个时候对用户请求的处理必然存在不确定性。最后，等所有的代码更新完毕后，再平滑重启PHP和web服务器。&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;opcache.revalidate_freq&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;(default&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&quot;2&quot;)&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;;这个选项用于设置缓存的过期时间（单位是秒），当这个时间达到后，opcache会检查你的代码是否改变，如果改变了PHP会重新编译它，生成新的opcode，并且更新缓存。值为“0”表示每次请求都会检查你的PHP代码是否更新（这意味着会增加很多次stat系统调用，译注：stat系统调用是读取文件的状态，这里主要是获取最近修改时间，这个系统调用会发生磁盘I/O，所以必然会消耗一些CPU时间，当然系统调用本身也会消耗一些CPU时间）。可以在开发环境中把它设置为0，生产环境下不用管。
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;如果&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;`opcache.validate_timestamps`&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;配置指令设置为禁用（设置为0），那么此设置项将会被忽略。&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;opcache.revalidate_path&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;(default&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&quot;0&quot;)&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;;在include_path优化中启用或禁用文件搜索
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;如果被禁用，并且找到了使用的缓存文件相同的include_path，该文件不被再次搜索。因此，如果一个文件与include_path中的其他地方相同的名称出现将不会被发现。如果此优化对此有效，请启用此指令你的应用程序，这个指令的默认值是禁用的，这意味着该优化是活跃的。&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;opcache.fast_shutdown（默认“0”）&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;;如果启用，则会使用快速停止续发事件。 所谓快速停止续发事件是指依赖 Zend 引擎的内存管理模块 一次释放全部请求变量的内存，而不是依次释放每一个已分配的内存块。
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;该指令已在PHP&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;7.2.0中被删除。快速关机序列的一个变种已经被集成到PHP中，并且如果可能的话将被自动使用。&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;其他加速器&quot;&gt;其他加速器&lt;/h3&gt;

&lt;h5 id=&quot;apc&quot;&gt;APC&lt;/h5&gt;

&lt;p&gt;Alternative PHP Cache (APC) 是一个开放自由的PHP opcode缓存。它的目标是提供一个自由、 开放，和健全的框架用于缓存和优化PHP的中间代码。 它是PHP PECL中的一个扩展。&lt;/p&gt;

&lt;h5 id=&quot;xcache&quot;&gt;xcache&lt;/h5&gt;

&lt;p&gt;XCache是国人自己开发的东西，性能比早期的eAccelerator加速器要优良。&lt;/p&gt;

&lt;h5 id=&quot;eaccelerator&quot;&gt;eAccelerator&lt;/h5&gt;

&lt;p&gt;eAccelerator的前身其实是truck-mmcache，因为开发truk-mmcache的人被Zend给招安了，所以开发eAccelerator的人继承了truk-mmcache的一些特性，设计出eAccelerator加速器。&lt;/p&gt;
</description>
        <pubDate>Sun, 07 Oct 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/10/07/opcode-cache/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/10/07/opcode-cache/</guid>
        
        <category>php</category>
        
        
      </item>
    
      <item>
        <title>nginx与php-fpm 连接数</title>
        <description>&lt;h2 id=&quot;apache连接请求机制&quot;&gt;Apache连接请求机制&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;/assets/img/posts/2018-08-11-php-nginx-connect/1.png&quot;&gt;&lt;img src=&quot;/assets/img/posts/2018-08-11-php-nginx-connect/1.png&quot; alt=&quot;1.png&quot; title=&quot;点击查看原图&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Apache的处理机制是每有一个请求就会去fork一个子进程来处理请求。&lt;br /&gt;
这样带来的缺点很明显：
当请求量大的时候，需要开启一样数量的进程，这样一来系统内存的消耗，二来cpu执行切换带来的上下文切换消耗非常大。&lt;/p&gt;

&lt;p&gt;Nginx是如何解决这些问题的呢？答案是使用I/O复用技术。
下面只是简单讲解什么是I/O复用，有兴趣的同学可以参考&lt;a href=&quot;/2018/08/04/computer-io.html&quot;&gt;I/O模型&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;nginx使用的io复用技术&quot;&gt;Nginx使用的I/O复用技术&lt;/h2&gt;

&lt;h4 id=&quot;初级io复用&quot;&gt;初级I/O复用&lt;/h4&gt;

&lt;p&gt;采用非阻塞的模式，当一个连接过来时，我们不阻塞住，这样一个进程可以同时处理多个连接了。
比如一个进程接受了10000个连接，这个进程每次从头到尾的问一遍这10000个连接：“有I/O事件没？有的话就交给我处理，没有的话我一会再来问一遍。”
然后进程就一直从头到尾问这10000个连接，如果这1000个连接都没有I/O事件，就会造成CPU的空转，并且效率也很低，不好不好。&lt;/p&gt;

&lt;h4 id=&quot;升级io复用selectpoll&quot;&gt;升级I/O复用（select、poll）&lt;/h4&gt;

&lt;p&gt;我们能不能引入一个代理，这个代理可以同时观察许多I/O流事件呢？&lt;br /&gt;
当没有I/O事件的时候，这个进程处于阻塞状态。当连接有I/O流事件产生的时候，就会去唤醒进程去处理。&lt;/p&gt;

&lt;p&gt;但是唤醒之后，因为不知道是哪个连接产生的I/O流事件，于是进程就挨个去问：“请问是你有事要处理吗？”。&lt;/p&gt;

&lt;p&gt;ps: select与poll原理是一样的，只不过select只能观察1024个连接，poll可以观察无限个连接。&lt;/p&gt;

&lt;h4 id=&quot;超级升级io复用epoll&quot;&gt;超级升级I/O复用（epoll）&lt;/h4&gt;

&lt;p&gt;有了epoll，可以知道是哪个连接产生的I/O流事件。理论上1个进程就可以无限数量的连接，而且无需轮询，真正解决了c10k的问题。&lt;/p&gt;

&lt;p&gt;nginx就是采用基于epoll的异步非阻塞服务器程序。&lt;/p&gt;

&lt;h2 id=&quot;nginx与php-fprm的连接处理&quot;&gt;nginx与php-fprm的连接处理&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;/assets/img/posts/2018-08-11-php-nginx-connect/2.png&quot;&gt;&lt;img src=&quot;/assets/img/posts/2018-08-11-php-nginx-connect/2.png&quot; alt=&quot;2.png&quot; title=&quot;点击查看原图&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;nginx&quot;&gt;nginx&lt;/h4&gt;

&lt;p&gt;worker为epoll异步处理请求。&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;worker_processes&lt;/td&gt;
      &lt;td&gt;worker数量&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;worker_connections&lt;/td&gt;
      &lt;td&gt;每个worker能处理的最大并发连接请求&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;php-fpm&quot;&gt;php-fpm&lt;/h4&gt;

&lt;p&gt;worker为poll异步处理请求。众多的 worker 进程组成了进程池，等待 master 进程分配任务，而且每个 worker 进程只能同时处理单个任务，前一个处理结束，才能为下一个服务。&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;pm&lt;/td&gt;
      &lt;td&gt;分为静态(static)和动态(dynamic)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;pm.max_children&lt;/td&gt;
      &lt;td&gt;static模式下创建的子进程数(固定)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;pm.start_servers&lt;/td&gt;
      &lt;td&gt;动态方式下的起始worker进程数量&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;pm.min_spare_servers&lt;/td&gt;
      &lt;td&gt;动态方式下服务器空闲时最小worker进程数量&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;pm.max_spare_servers&lt;/td&gt;
      &lt;td&gt;动态方式下服务器空闲时最大worker进程数量&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;超时设置&quot;&gt;超时设置&lt;/h2&gt;

&lt;h4 id=&quot;nginx-1&quot;&gt;nginx&lt;/h4&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;fastcgi_connect_timeout&lt;/td&gt;
      &lt;td&gt;后端链接时间&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;fastcgi_send_timeout&lt;/td&gt;
      &lt;td&gt;数据发送时间，两次成功发送时间差，不是整个发送时间&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;fastcgi_read_timeout&lt;/td&gt;
      &lt;td&gt;数据接收时间，两次成功接收时间差，不是整个接收时间&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;php-fpm-1&quot;&gt;php-fpm&lt;/h4&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;request_terminate_timeout&lt;/td&gt;
      &lt;td&gt;PHP脚本的最大执行时间&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;php&quot;&gt;php&lt;/h4&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;max_execution_time&lt;/td&gt;
      &lt;td&gt;PHP脚本的最大执行时间&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;ps:一些版本中php-fpm的配置会覆盖php.ini的配置，使php.ini的配置不起作用&lt;/p&gt;

&lt;h2 id=&quot;常见错误&quot;&gt;常见错误&lt;/h2&gt;

&lt;p&gt;1.502 Connection reset by peer&lt;/p&gt;

&lt;p&gt;php-fpm的worker进程执行php程序脚本时，超过了配置的最长执行时间，master进程将worker进程杀掉，直接返回502。&lt;/p&gt;

&lt;p&gt;2.502 Connection refused&lt;/p&gt;

&lt;p&gt;连接请求数(accpet之前)超出了端口所能监听的tcp连接的最大值(backlog的值)，进不了fpm等待accept的链接队列，直接返回502，这里可能会产生tcp重传。&lt;/p&gt;

&lt;p&gt;backlog的值是半连接和全连接的总和，他的存在也有短时间缓冲解耦nginx请求与fpm处理的作用，半连接指收到了syn请求，3次握手尚未建立，全连接指的是3次握手已经成功，不过尚未被accpet的请求，fpm里面有调节的参数，如果fpm的参数设置为-1，则默认走的是系统内核参数net.core.somaxconn的设置值，如果不设置可以在/proc/sys/net/core/somaxconn里查看，默认值是128，所以在连接请求较高的业务里要增大这个值。&lt;/p&gt;

&lt;p&gt;3.504 Connection timed out&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;php的worker进程池处理慢，无法尽快处理等待accept的链接队列，导致3次握手后的链接队列长时间没有被accept，nginx链接等待超时;&lt;/li&gt;
  &lt;li&gt;后端php-fpm执行脚本的时间太长，超过了nginx配置的超时机制，这个时候也是会报出504错误的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000007614502&quot;&gt;nginx、swoole高并发原理初探&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.2cto.com/net/201609/546064.html&quot;&gt;WebService之nginx+(php-fpm)结构模型剖析及优化&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 11 Aug 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/08/11/php-nginx-connect/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/08/11/php-nginx-connect/</guid>
        
        <category>php</category>
        
        
      </item>
    
      <item>
        <title>「转载」select、poll与epoll</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;转载自&lt;a href=&quot;https://cloud.tencent.com/developer/article/1005481&quot;&gt;大话 Select、Poll、Epoll&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;linux的socket-事件wakeup-callback机制&quot;&gt;Linux的socket 事件wakeup callback机制&lt;/h2&gt;

&lt;p&gt;言归正传，在介绍select、poll、epoll前，有必要说说linux(2.6+)内核的事件wakeup callback机制，这是IO多路复用机制存在的本质。Linux通过socket睡眠队列来管理所有等待socket的某个事件的process，同时通过wakeup机制来异步唤醒整个睡眠队列上等待事件的process，通知process相关事件发生。通常情况，socket的事件发生的时候，其会顺序遍历socket睡眠队列上的每个process节点，调用每个process节点挂载的callback函数。在遍历的过程中，如果遇到某个节点是排他的，那么就终止遍历，总体上会涉及两大逻辑：（1）睡眠等待逻辑；（2）唤醒逻辑。&lt;/p&gt;

&lt;p&gt;（1）睡眠等待逻辑：涉及select、poll、epoll_wait的阻塞等待逻辑&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;[1]select、poll、epoll_wait陷入内核，判断监控的socket是否有关心的事件发生了，如果没，则为当前process构建一个wait_entry节点，然后插入到监控socket的sleep_list  &lt;br /&gt;
[2]进入循环的schedule直到关心的事件发生了  &lt;br /&gt;
[3]关心的事件发生后，将当前process的wait_entry节点从socket的sleep_list中删除。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;（2）唤醒逻辑：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;[1]socket的事件发生了，然后socket顺序遍历其睡眠队列，依次调用每个wait_entry节点的callback函数  &lt;br /&gt;
[2]直到完成队列的遍历或遇到某个wait_entry节点是排他的才停止。  &lt;br /&gt;
[3]一般情况下callback包含两个逻辑：1.wait_entry自定义的私有逻辑；2.唤醒的公共逻辑，主要用于将该wait_entry的process放入CPU的就绪队列，让CPU随后可以调度其执行。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;下面就上面的两大逻辑，分别阐述select、poll、epoll的异同，为什么epoll能够比select、poll高效。&lt;/p&gt;

&lt;h2 id=&quot;select&quot;&gt;Select&lt;/h2&gt;

&lt;p&gt;在一个高性能的网络服务上，大多情况下一个服务进程(线程)process需要同时处理多个socket，我们需要公平对待所有socket，对于read而言，那个socket有数据可读，process就去读取该socket的数据来处理。于是对于read，一个朴素的需求就是关心的N个socket是否有数据”可读”，也就是我们期待”可读”事件的通知，而不是盲目地对每个socket调用recv/recvfrom来尝试接收数据。我们应该block在等待事件的发生上，这个事件简单点就是”关心的N个socket中一个或多个socket有数据可读了”，当block解除的时候，就意味着，我们一定可以找到一个或多个socket上有可读的数据。另一方面，根据上面的socket wakeup callback机制，我们不知道什么时候，哪个socket会有读事件发生，于是，process需要同时插入到这N个socket的sleep_list上等待任意一个socket可读事件发生而被唤醒，当时process被唤醒的时候，其callback里面应该有个逻辑去检查具体那些socket可读了。&lt;/p&gt;

&lt;p&gt;于是，select的多路复用逻辑就清晰了，select为每个socket引入一个poll逻辑，该poll逻辑用于收集socket发生的事件，对于可读事件来说，简单伪码如下：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;poll&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    //其他逻辑
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;recieve queque is not empty&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        sk_event |&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; POLL_IN；
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
   //其他逻辑
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;接下来就到select的逻辑了，下面是select的函数原型：5个参数，后面4个参数都是in/out类型(值可能会被修改返回)&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int &lt;span class=&quot;k&quot;&gt;select&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;int nfds, fd_set &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;readfds, fd_set &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;writefds, fd_set &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;exceptfds, struct timeval &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;timeout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;当用户process调用select的时候，select会将需要监控的readfds集合拷贝到内核空间（假设监控的仅仅是socket可读），然后遍历自己监控的socket sk，挨个调用sk的poll逻辑以便检查该sk是否有可读事件，遍历完所有的sk后，如果没有任何一个sk可读，那么select会调用schedule_timeout进入schedule循环，使得process进入睡眠。如果在timeout时间内某个sk上有数据可读了，或者等待timeout了，则调用select的process会被唤醒，接下来select就是遍历监控的sk集合，挨个收集可读事件并返回给用户了，相应的伪码如下：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;sk &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;readfds&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    sk_event.evt &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; sk.poll&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    sk_event.sk &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; sk&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    ret_event_for_process&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;通过上面的select逻辑过程分析，相信大家都意识到，select存在两个问题：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;[1] 被监控的fds需要从用户空间拷贝到内核空间  &lt;br /&gt;
   为了减少数据拷贝带来的性能损坏，内核对被监控的fds集合大小做了限制，并且这个是通过宏控制的，大小不可改变(限制为1024)。  &lt;br /&gt;
[2] 被监控的fds集合中，只要有一个有数据可读，整个socket集合就会被遍历一次调用sk的poll函数收集可读事件  &lt;br /&gt;
   由于当初的需求是朴素，仅仅关心是否有数据可读这样一个事件，当事件通知来的时候，由于数据的到来是异步的，我们不知道事件来的时候，有多少个被监控的socket有数据可读了，于是，只能挨个遍历每个socket来收集可读事件。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;到这里，我们有三个问题需要解决：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;被监控的fds集合限制为1024，1024太小了，我们希望能够有个比较大的可监控fds集合&lt;/li&gt;
  &lt;li&gt;fds集合需要从用户空间拷贝到内核空间的问题，我们希望不需要拷贝&lt;/li&gt;
  &lt;li&gt;当被监控的fds中某些有数据可读的时候，我们希望通知更加精细一点，就是我们希望能够从通知中得到有可读事件的fds列表，而不是需要遍历整个fds来收集。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;通知中得到有可读事件的fds列表，而不是需要遍历整个fds来收集。&lt;/p&gt;

&lt;h2 id=&quot;poll&quot;&gt;poll&lt;/h2&gt;

&lt;p&gt;select遗留的三个问题中，问题(1)是用法限制问题，问题(2)和(3)则是性能问题。poll和select非常相似，poll并没着手解决性能问题，poll只是解决了select的问题(1)fds集合大小1024限制问题。下面是poll的函数原型，poll改变了fds集合的描述方式，使用了pollfd结构而不是select的fd_set结构，使得poll支持的fds集合限制远大于select的1024。poll虽然解决了fds集合大小1024的限制问题，但是，它并没改变大量描述符数组被整体复制于用户态和内核态的地址空间之间，以及个别描述符就绪触发整体描述符集合的遍历的低效问题。poll随着监控的socket集合的增加性能线性下降，poll不适合用于大并发场景。&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int poll&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;struct pollfd &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;fds, nfds_t nfds, int &lt;span class=&quot;nb&quot;&gt;timeout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;epoll&quot;&gt;epoll&lt;/h2&gt;

&lt;p&gt;select遗留的三个问题，问题(1)是比较好解决，poll简单两三下就解决掉了，但是poll的解决有点鸡肋。要解决问题(2)和(3)似乎比较棘手，要怎么解决呢？我们知道，在计算机行业中，有两种解决问题的思想：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;[1] 计算机科学领域的任何问题, 都可以通过添加一个中间层来解决  &lt;br /&gt;
[2] 变集中(中央)处理为分散(分布式)处理&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;下面，我们看看，epoll在解决select的遗留问题(2)和(3)的时候，怎么运用这两个思想的。&lt;/p&gt;

&lt;h4 id=&quot;fds集合拷贝问题的解决&quot;&gt;fds集合拷贝问题的解决&lt;/h4&gt;

&lt;p&gt;对于IO多路复用，有两件事是必须要做的(对于监控可读事件而言)：1. 准备好需要监控的fds集合；2. 探测并返回fds集合中哪些fd可读了。细看select或poll的函数原型，我们会发现，每次调用select或poll都在重复地准备(集中处理)整个需要监控的fds集合。然而对于频繁调用的select或poll而言，fds集合的变化频率要低得多，我们没必要每次都重新准备(集中处理)整个fds集合。&lt;/p&gt;

&lt;p&gt;于是，epoll引入了epoll_ctl系统调用，将高频调用的epoll_wait和低频的epoll_ctl隔离开。同时，epoll_ctl通过(EPOLL_CTL_ADD、EPOLL_CTL_MOD、EPOLL_CTL_DEL)三个操作来分散对需要监控的fds集合的修改，做到了有变化才变更，将select或poll高频、大块内存拷贝(集中处理)变成epoll_ctl的低频、小块内存的拷贝(分散处理)，避免了大量的内存拷贝。同时，对于高频epoll_wait的可读就绪的fd集合返回的拷贝问题，epoll通过内核与用户空间mmap(内存映射)同一块内存来解决。mmap将用户空间的一块地址和内核空间的一块地址同时映射到相同的一块物理内存地址（不管是用户空间还是内核空间都是虚拟地址，最终要通过地址映射映射到物理地址），使得这块物理内存对内核和对用户均可见，减少用户态和内核态之间的数据交换。&lt;/p&gt;

&lt;p&gt;另外，epoll通过epoll_ctl来对监控的fds集合来进行增、删、改，那么必须涉及到fd的快速查找问题，于是，一个低时间复杂度的增、删、改、查的数据结构来组织被监控的fds集合是必不可少的了。在linux 2.6.8之前的内核，epoll使用hash来组织fds集合，于是在创建epoll fd的时候，epoll需要初始化hash的大小。于是epoll_create(int size)有一个参数size，以便内核根据size的大小来分配hash的大小。在linux 2.6.8以后的内核中，epoll使用红黑树来组织监控的fds集合，于是epoll_create(int size)的参数size实际上已经没有意义了。&lt;/p&gt;

&lt;h4 id=&quot;按需遍历就绪的fds集合&quot;&gt;按需遍历就绪的fds集合&lt;/h4&gt;

&lt;p&gt;通过上面的socket的睡眠队列唤醒逻辑我们知道，socket唤醒睡眠在其睡眠队列的wait_entry(process)的时候会调用wait_entry的回调函数callback，并且，我们可以在callback中做任何事情。为了做到只遍历就绪的fd，我们需要有个地方来组织那些已经就绪的fd。为此，epoll引入了一个中间层，一个双向链表(ready_list)，一个单独的睡眠队列(single_epoll_wait_list)，并且，与select或poll不同的是，epoll的process不需要同时插入到多路复用的socket集合的所有睡眠队列中，相反process只是插入到中间层的epoll的单独睡眠队列中，process睡眠在epoll的单独队列上，等待事件的发生。同时，引入一个中间的wait_entry_sk，它与某个socket sk密切相关，wait_entry_sk睡眠在sk的睡眠队列上，其callback函数逻辑是将当前sk排入到epoll的ready_list中，并唤醒epoll的single_epoll_wait_list。而single_epoll_wait_list上睡眠的process的回调函数就明朗了：遍历ready_list上的所有sk，挨个调用sk的poll函数收集事件，然后唤醒process从epoll_wait返回。
于是，整个过来可以分为以下几个逻辑：&lt;/p&gt;

&lt;p&gt;（1）epoll_ctl EPOLL_CTL_ADD逻辑&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;[1] 构建睡眠实体wait_entry_sk，将当前socket sk关联给wait_entry_sk，并设置wait_entry_sk的回调函数为epoll_callback_sk  &lt;br /&gt;
[2] 将wait_entry_sk排入当前socket sk的睡眠队列上&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;回调函数epoll_callback_sk的逻辑如下：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;[1] 将之前关联的sk排入epoll的ready_list  &lt;br /&gt;
[2] 然后唤醒epoll的单独睡眠队列single_epoll_wait_list&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;（2）epoll_wait逻辑&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;[1] 构建睡眠实体wait_entry_proc，将当前process关联给wait_entry_proc，并设置回调函数为epoll_callback_proc  &lt;br /&gt;
[2] 判断epoll的ready_list是否为空，如果为空，则将wait_entry_proc排入epoll的single_epoll_wait_list中，随后进入schedule循环，这会导致调用
epoll_wait的process睡眠。  &lt;br /&gt;
[3] wait_entry_proc被事件唤醒或超时醒来，wait_entry_proc将被从single_epoll_wait_list移除掉，然后wait_entry_proc执行回调函数epoll_callback_proc&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;回调函数epoll_callback_proc的逻辑如下：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;[1] 遍历epoll的ready_list，挨个调用每个sk的poll逻辑收集发生的事件，对于监控可读事件而已，ready_list上的每个sk都是有数据可读的，这里的遍历必要的(不同于select/poll的遍历，它不管有没数据可读都需要遍历一些来判断，这样就做了很多无用功。)  &lt;br /&gt;
[2] 将每个sk收集到的事件，通过epoll_wait传入的events数组回传并唤醒相应的process。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;（3）epoll唤醒逻辑&lt;/p&gt;

&lt;p&gt;整个epoll的协议栈唤醒逻辑如下(对于可读事件而言)：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;[1] 协议数据包到达网卡并被排入socket sk的接收队列  &lt;br /&gt;
[2] 睡眠在sk的睡眠队列wait_entry被唤醒，wait_entry_sk的回调函数epoll_callback_sk被执行  &lt;br /&gt;
[3] epoll_callback_sk将当前sk插入epoll的ready_list中  &lt;br /&gt;
[4] 唤醒睡眠在epoll的单独睡眠队列single_epoll_wait_list的wait_entry，wait_entry_proc被唤醒执行回调函数epoll_callback_proc  &lt;br /&gt;
[5] 遍历epoll的ready_list，挨个调用每个sk的poll逻辑收集发生的事件  &lt;br /&gt;
[6] 将每个sk收集到的事件，通过epoll_wait传入的events数组回传并唤醒相应的process。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;epoll巧妙的引入一个中间层解决了大量监控socket的无效遍历问题。细心的同学会发现，epoll在中间层上为每个监控的socket准备了一个单独的回调函数epoll_callback_sk，而对于select/poll，所有的socket都公用一个相同的回调函数。正是这个单独的回调epoll_callback_sk使得每个socket都能单独处理自身，当自己就绪的时候将自身socket挂入epoll的ready_list。同时，epoll引入了一个睡眠队列single_epoll_wait_list，分割了两类睡眠等待。process不再睡眠在所有的socket的睡眠队列上，而是睡眠在epoll的睡眠队列上，在等待”任意一个socket可读就绪”事件。而中间wait_entry_sk则代替process睡眠在具体的socket上，当socket就绪的时候，它就可以处理自身了。&lt;/p&gt;
</description>
        <pubDate>Sun, 05 Aug 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/08/05/computer-select-poll-epoll/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/08/05/computer-select-poll-epoll/</guid>
        
        <category>计算机</category>
        
        <category>转载</category>
        
        
      </item>
    
      <item>
        <title>I/O模型</title>
        <description>&lt;p&gt;I/O发生过程涉及的对象：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;调用该IO的线程(thread)&lt;/li&gt;
  &lt;li&gt;系统内核(kernel)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I/O发生过程步骤：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;等待数据准备&lt;/li&gt;
  &lt;li&gt;将数据从内核拷贝到用户的进程空间。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;阻塞型ioblocking-io&quot;&gt;阻塞型I/O（blocking I/O）&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;/assets/img/posts/2018-08-04-computer-io/1.jpg&quot;&gt;&lt;img src=&quot;/assets/img/posts/2018-08-04-computer-io/1.jpg&quot; alt=&quot;1.jpg&quot; title=&quot;点击查看原图&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;用户thread在整个过程当中，都需要等待kernel返回数据，所以整个过程都是被block的。&lt;/p&gt;

&lt;h4 id=&quot;非阻塞型ionon-blocking-io&quot;&gt;非阻塞型I/O（non-blocking I/O）&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;/assets/img/posts/2018-08-04-computer-io/2.jpg&quot;&gt;&lt;img src=&quot;/assets/img/posts/2018-08-04-computer-io/2.jpg&quot; alt=&quot;2.jpg&quot; title=&quot;点击查看原图&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;等待数据阶段，如果请求的数据没准备好，kernel会返回失败，用户thread是采用轮询方式进行的，所以在这个阶段不会被block。&lt;br /&gt;
拷贝数据阶段，当kernel返回成功，则发送拷贝数据请求，等待kennel把数据从内核拷贝到用户空间，所以这个阶段是被block的。&lt;/p&gt;

&lt;h4 id=&quot;io复用io-multiplexing&quot;&gt;I/O复用（IO multiplexing）&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;/assets/img/posts/2018-08-04-computer-io/3.jpg&quot;&gt;&lt;img src=&quot;/assets/img/posts/2018-08-04-computer-io/3.jpg&quot; alt=&quot;3.jpg&quot; title=&quot;点击查看原图&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;我们常用的select、epoll都是使用这种模型。&lt;br /&gt;
等待数据阶段，用户调用了select，并等待select返回结果，这个阶段是被block的。&lt;br /&gt;
读取数据阶段，当select返回了可读结果，则发送拷贝数据请求，等待kennel把数据从内核拷贝到用户空间，这个阶段也是被block的。&lt;/p&gt;

&lt;p&gt;这么看来其实I/O复用还不如阻塞I/O，虽然整个过程同样都是被block的，但需要发送两次系统请求，性能会有所下降。&lt;br /&gt;
用select的优势在于它可以同时处理多个connection。（多说一句。所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。&lt;/p&gt;

&lt;h4 id=&quot;异步ioasynchronous-io&quot;&gt;异步I/O（asynchronous I/O）&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;/assets/img/posts/2018-08-04-computer-io/4.jpg&quot;&gt;&lt;img src=&quot;/assets/img/posts/2018-08-04-computer-io/4.jpg&quot; alt=&quot;4.jpg&quot; title=&quot;点击查看原图&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;等待数据阶段，用户发送请求之后kernel会立即返回结果，之后用户进程就可以去处理其他事情了，这个阶段不会被block。  &lt;br /&gt;
拷贝数据阶段，用户也不需要感知，kernel在数据准备好之后，会立刻被数据拷贝到用户进程空间，然后给用户进程发信号去读取，这个阶段也不会被block。&lt;/p&gt;

&lt;h4 id=&quot;信号驱动io-signal-driven-io&quot;&gt;信号驱动I/O (signal-driven I/O）&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;/assets/img/posts/2018-08-04-computer-io/5.jpg&quot;&gt;&lt;img src=&quot;/assets/img/posts/2018-08-04-computer-io/5.jpg&quot; alt=&quot;5.jpg&quot; title=&quot;点击查看原图&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;对比&quot;&gt;对比&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;/assets/img/posts/2018-08-04-computer-io/.jpg&quot;&gt;&lt;img src=&quot;/assets/img/posts/2018-08-04-computer-io/6.jpg&quot; alt=&quot;6.jpg&quot; title=&quot;点击查看原图&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;同步和异步&lt;br /&gt;
其实只要判断在整个过程中，用户能不能去处理其他事情，如果能，就是异步，不能，就是同步。&lt;/p&gt;

&lt;p&gt;阻塞与非阻塞  &lt;br /&gt;
如果需要等待kernel返回结果，这个进程就会被block。所以主要判断用户是否需要等待kernel返回结果。&lt;br /&gt;
从这个点看，其实非阻塞I/O并不能完全算是非阻塞，毕竟拷贝数据阶段也是被block的。&lt;/p&gt;
</description>
        <pubDate>Sat, 04 Aug 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/08/04/computer-io/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/08/04/computer-io/</guid>
        
        <category>计算机</category>
        
        
      </item>
    
  </channel>
</rss>
