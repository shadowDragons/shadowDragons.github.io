<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ben Blog</title>
    <description>一个小白的成长学习历程</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sat, 20 Jul 2019 23:13:24 +0800</pubDate>
    <lastBuildDate>Sat, 20 Jul 2019 23:13:24 +0800</lastBuildDate>
    <generator>Jekyll v3.8.4</generator>
    
      <item>
        <title>「笔记」《师北辰写作课》</title>
        <description>&lt;p&gt;&lt;a href=&quot;/assets/img/posts/2019-06-23-note-sbc-write-course/1.png&quot;&gt;&lt;img src=&quot;/assets/img/posts/2019-06-23-note-sbc-write-course/1.png&quot; alt=&quot;1.png&quot; title=&quot;查看原图&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 23 Jun 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/06/23/note-sbc-write-course/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/06/23/note-sbc-write-course/</guid>
        
        <category>视频课程</category>
        
        <category>笔记</category>
        
        
      </item>
    
      <item>
        <title>如何选择开源许可协议</title>
        <description>&lt;p&gt;&lt;a href=&quot;/assets/img/posts/2019-06-16-open-licence/1.jpg&quot;&gt;&lt;img src=&quot;/assets/img/posts/2019-06-16-open-licence/1.jpg&quot; alt=&quot;1.jpg&quot; title=&quot;查看原图&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 16 Jun 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/06/16/open-licence/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/06/16/open-licence/</guid>
        
        <category>计算机</category>
        
        
      </item>
    
      <item>
        <title>「笔记」《蔡康永的情商课》</title>
        <description>&lt;p&gt;&lt;a href=&quot;/assets/img/posts/2019-06-16-note-eq/1.png&quot;&gt;&lt;img src=&quot;/assets/img/posts/2019-06-16-note-eq/1.png&quot; alt=&quot;1.png&quot; title=&quot;查看原图&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 16 Jun 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/06/16/note-eq/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/06/16/note-eq/</guid>
        
        <category>书籍</category>
        
        <category>笔记</category>
        
        
      </item>
    
      <item>
        <title>PHP如何读取大文件</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;下面会使用文件流来做大文件处理，不清楚PHP流的同学，可以先看这篇&lt;a href=&quot;/2019/06/10/php-stream/&quot;&gt;PHP-流(Stream)&lt;/a&gt;了解。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;测试文件&lt;a href=&quot;/assets/file/2019-06-11-php-read-big-file/shakespeare.txt&quot;&gt;shakespeare.txt&lt;/a&gt;下载&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;首先我们需要写个计算内存使用量的方法，新建一个&lt;code class=&quot;highlighter-rouge&quot;&gt;memory.php&lt;/code&gt;文件，内容如下：&lt;/p&gt;

&lt;div class=&quot;language-php highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// formatBytes is taken from the php.net documentation&lt;/span&gt;

&lt;span class=&quot;nb&quot;&gt;memory_get_peak_usage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;formatBytes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$bytes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$precision&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;$units&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;b&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;kb&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;mb&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;gb&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;tb&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;nv&quot;&gt;$bytes&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$bytes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;$pow&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;floor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$bytes&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$bytes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1024&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;$pow&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$pow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$units&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;nv&quot;&gt;$bytes&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$pow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;round&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$bytes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$precision&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot; &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$units&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$pow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;formatBytes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;memory_get_peak_usage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;逐行读取文件&quot;&gt;逐行读取文件&lt;/h3&gt;

&lt;div class=&quot;language-php highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// from reading-files-line-by-line-1.php&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;readTheFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;$lines&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[];&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;$handle&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;fopen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;r&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;feof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$handle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nv&quot;&gt;$lines&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;trim&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;fgets&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$handle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;nb&quot;&gt;fclose&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$handle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$lines&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;readTheFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;shakespeare.txt&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;require&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;memory.php&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个文件&lt;strong&gt;5.5MB&lt;/strong&gt;，用了&lt;strong&gt;12.8MB&lt;/strong&gt;内存。现在我们用生成器来读取文件：&lt;/p&gt;

&lt;div class=&quot;language-php highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// from reading-files-line-by-line-2.php&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;readTheFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;$handle&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;fopen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;r&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;feof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$handle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;trim&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;fgets&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$handle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;nb&quot;&gt;fclose&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$handle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;readTheFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;shakespeare.txt&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;require&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;memory.php&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;同样的文件大小，内存只用了&lt;strong&gt;393KB&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;我们也可以对文件内容做分块处理，这里我们以有连续两个空行的文本做分块：&lt;/p&gt;

&lt;div class=&quot;language-php highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// from reading-files-line-by-line-3.php&lt;/span&gt;

&lt;span class=&quot;nv&quot;&gt;$iterator&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;readTheFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;shakespeare.txt&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;nv&quot;&gt;$buffer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;foreach&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$iterator&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$iteration&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;preg_match&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;/&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;/&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$matches&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$matches&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;.&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;nv&quot;&gt;$buffer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nv&quot;&gt;$buffer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$iteration&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;PHP_EOL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;require&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;memory.php&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;即使分成了1,216块，也只用了&lt;strong&gt;459KB&lt;/strong&gt;内存。&lt;/p&gt;

&lt;h3 id=&quot;文件管道&quot;&gt;文件管道&lt;/h3&gt;

&lt;p&gt;把文件转移到另一个文件&lt;/p&gt;

&lt;div class=&quot;language-php highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// from piping-files-1.php&lt;/span&gt;

&lt;span class=&quot;nb&quot;&gt;file_put_contents&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;piping-files-1.txt&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;file_get_contents&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;shakespeare.txt&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;require&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;memory.php&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;内存占用跟文件大小差不多，这是因为它必须把整个文件的内容放到内存，直到拷贝完毕。&lt;/p&gt;

&lt;p&gt;接下来我们通过文件流来实现：&lt;/p&gt;

&lt;div class=&quot;language-php highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// from piping-files-2.php&lt;/span&gt;

&lt;span class=&quot;nv&quot;&gt;$handle1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;fopen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;shakespeare.txt&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;r&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$handle2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;fopen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;piping-files-2.txt&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;w&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;nb&quot;&gt;stream_copy_to_stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$handle1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$handle2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;nb&quot;&gt;fclose&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$handle1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;fclose&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$handle2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;require&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;memory.php&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;结果只有&lt;strong&gt;393KB&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;压缩&quot;&gt;压缩&lt;/h3&gt;

&lt;p&gt;如果我们用PHP的扩展&lt;code class=&quot;highlighter-rouge&quot;&gt;ZipArchive&lt;/code&gt;来做压缩：&lt;/p&gt;

&lt;div class=&quot;language-php highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// from filters-1.php&lt;/span&gt;

&lt;span class=&quot;nv&quot;&gt;$zip&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ZipArchive&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$filename&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;filters-1.zip&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;nv&quot;&gt;$zip&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$filename&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ZipArchive&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;CREATE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$zip&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addFromString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;shakespeare.txt&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;file_get_contents&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;shakespeare.txt&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$zip&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;require&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;memory.php&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;结果会用到&lt;strong&gt;10.75MB&lt;/strong&gt;的内存。&lt;/p&gt;

&lt;p&gt;我们同样用文件流来做优化：&lt;/p&gt;

&lt;div class=&quot;language-php highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// from filters-2.php&lt;/span&gt;

&lt;span class=&quot;nv&quot;&gt;$handle1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;fopen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;php://filter/zlib.deflate/resource=shakespeare.txt&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;r&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;nv&quot;&gt;$handle2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;fopen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;filters-2.deflated&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;w&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;nb&quot;&gt;stream_copy_to_stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$handle1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$handle2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;nb&quot;&gt;fclose&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$handle1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;fclose&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$handle2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里只用了&lt;strong&gt;896KB&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;解压：&lt;/p&gt;

&lt;div class=&quot;language-php highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;file_get_contents&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;php://filter/zlib.inflate/resource=filters-2.deflated&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其实如果使用了&lt;code class=&quot;highlighter-rouge&quot;&gt;ZipArchive&lt;/code&gt;扩展，不要使用&lt;code class=&quot;highlighter-rouge&quot;&gt;addFromString&lt;/code&gt;来添加文件，改用&lt;code class=&quot;highlighter-rouge&quot;&gt;addFile&lt;/code&gt;，内存使用上也可以在&lt;strong&gt;1MB&lt;/strong&gt;以内。&lt;/p&gt;
</description>
        <pubDate>Tue, 11 Jun 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/06/11/php-read-big-file/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/06/11/php-read-big-file/</guid>
        
        <category>php</category>
        
        
      </item>
    
      <item>
        <title>PHP-流(Stream)</title>
        <description>&lt;p&gt;在现代的&lt;code class=&quot;highlighter-rouge&quot;&gt;PHP&lt;/code&gt;特性中，流或许是最出色但最少使用的。虽然&lt;code class=&quot;highlighter-rouge&quot;&gt;PHP&lt;/code&gt; 4.3.0就 引人了流，但是
很多开发者不知道流的存在, 因为人们很少提及流，而且流的文档也匮乏。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;流在&lt;code class=&quot;highlighter-rouge&quot;&gt;PHP&lt;/code&gt; 4.3.0 中引入，作用是使用统一的方式处理文件、网络和数据压缩等共用同一套函数和用法的操作。 简单而言，流是具有流式行为的资源对象。因此，流可以线性读写，或许还能使用&lt;code class=&quot;highlighter-rouge&quot;&gt;fseek()&lt;/code&gt;函数定位到流中的任何位置。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这段定义很难理解是吧，下面我们简化一下，以便更易于理解。流的作用是在出发地和目的地之闾传输数据。就这么简单。 出发地和目的地可以是文件、命令行进程、网络连接、 &lt;code class=&quot;highlighter-rouge&quot;&gt;ZIP&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;TAR&lt;/code&gt;压缩文件、临时内存、标准输入或输出，或者是通过&lt;a href=&quot;http://php.net/manual/wrappers.php&quot;&gt;PHP流封装协议&lt;/a&gt;实现的任何其他资源。&lt;/p&gt;

&lt;p&gt;如果你读写过文件，就使用过流;如果你从&lt;code class=&quot;highlighter-rouge&quot;&gt;php://stdin&lt;/code&gt;读取过数据，或者把数据写人过&lt;code class=&quot;highlighter-rouge&quot;&gt;php://stdout&lt;/code&gt;, 就使用过流。流为PHP的很多&lt;code class=&quot;highlighter-rouge&quot;&gt;IO&lt;/code&gt;函数提供了底层实现, 例如&lt;code class=&quot;highlighter-rouge&quot;&gt;fi1e_get_contents()&lt;/code&gt;、 &lt;code class=&quot;highlighter-rouge&quot;&gt;fopen()&lt;/code&gt;、 &lt;code class=&quot;highlighter-rouge&quot;&gt;fgets()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;fwrite()&lt;/code&gt;。 &lt;code class=&quot;highlighter-rouge&quot;&gt;PHP&lt;/code&gt;的流函数提供了处理不同流资源 (出发地和目的地) 的统一接口。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意: 我把流理解为管道，相当于把水从一个地方引到另一个地方。在水从出发地流到目的地的过程中，我们可以过滤水，可以改变水质，可以添加水，也可以排出水（提示：水是数据的隐喻）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;流封装协议&quot;&gt;流封装协议&lt;/h3&gt;

&lt;p&gt;流式数据的种类各异，每种类型需要独特的协议，以便读写数据。我们称这些协议为&lt;a href=&quot;http://php.net/manual/wrappers.php&quot;&gt;流封装协议&lt;/a&gt;。例如，我们可以读写文件系统，可以通过HTTP、 HTTPS或SSH（安全的shell）与远程Web服务器通信，还可以打开并读写&lt;code class=&quot;highlighter-rouge&quot;&gt;ZIP&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;RAR&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;PHAR&lt;/code&gt;压缩文件。这些通信方式都包含下述相同的过程：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;开始通信。&lt;/li&gt;
  &lt;li&gt;读取数据。&lt;/li&gt;
  &lt;li&gt;写入数据。&lt;/li&gt;
  &lt;li&gt;结束通信。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;虽然过程是一祥的，但是读写文件系统中文件的方式与收发&lt;code class=&quot;highlighter-rouge&quot;&gt;HTTP&lt;/code&gt;消息的方式有所不同。流封装协议的作用是使用通用的接口封装这种差异。&lt;/p&gt;

&lt;p&gt;每个流邯有一个协议和一个目标。指定协议和目标的方法是使用流标识符，其格式如下所示，我们对此已经熟悉了:&lt;/p&gt;

&lt;div class=&quot;language-php highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;scheme&amp;gt;&lt;/span&gt;://&lt;span class=&quot;nt&quot;&gt;&amp;lt;target&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中，&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;scheme&amp;gt;&lt;/code&gt;是流的封装协议，&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;target&amp;gt;&lt;/code&gt;是流的数据源。如下所示使用&lt;code class=&quot;highlighter-rouge&quot;&gt;HTTP&lt;/code&gt;流封装协议创建了一个与&lt;code class=&quot;highlighter-rouge&quot;&gt;Flickr API&lt;/code&gt;通信的&lt;code class=&quot;highlighter-rouge&quot;&gt;PHP&lt;/code&gt;流。&lt;/p&gt;

&lt;div class=&quot;language-php highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?php&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$json&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;file_get_contents&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;s1&quot;&gt;'http://api.flickr.com/services/feeds/photos_public.gne?format=json'&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;不要误以为这是普通的网页&lt;code class=&quot;highlighter-rouge&quot;&gt;URL&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;file_get_contents()&lt;/code&gt;函数的字符串参数其实是一个流标识符。&lt;code class=&quot;highlighter-rouge&quot;&gt;http&lt;/code&gt;协议会让&lt;code class=&quot;highlighter-rouge&quot;&gt;PHP&lt;/code&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;HTTP&lt;/code&gt;流封装协议。 在这个参数中，&lt;code class=&quot;highlighter-rouge&quot;&gt;http&lt;/code&gt;之后是流的目标。流的目标之所以看起来像是普通的网页&lt;code class=&quot;highlighter-rouge&quot;&gt;URL&lt;/code&gt;，是因为&lt;code class=&quot;highlighter-rouge&quot;&gt;HTTP&lt;/code&gt;流封装协议就是这祥规定的。其他流封装协议可能不是这样。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意：前而一段要多读几遍，直到熟记为止。很多&lt;code class=&quot;highlighter-rouge&quot;&gt;PHP&lt;/code&gt;开发者不知道普通的&lt;code class=&quot;highlighter-rouge&quot;&gt;URL&lt;/code&gt;其实是&lt;code class=&quot;highlighter-rouge&quot;&gt;PHP&lt;/code&gt;流封装协议标识符的伪装。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&quot;file流封装协议&quot;&gt;file://流封装协议&lt;/h5&gt;

&lt;p&gt;我们使用&lt;code class=&quot;highlighter-rouge&quot;&gt;fi1e_get_contents()&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;fopen()&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;fwrite()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;fc1ose()&lt;/code&gt;函数读写文件系统。因为&lt;code class=&quot;highlighter-rouge&quot;&gt;PHP&lt;/code&gt;默认使用的流封装协议是&lt;code class=&quot;highlighter-rouge&quot;&gt;file://&lt;/code&gt;，所以我们很少认为这些函数使用的是&lt;code class=&quot;highlighter-rouge&quot;&gt;PHP&lt;/code&gt;流。我们在不经意间就使用了&lt;code class=&quot;highlighter-rouge&quot;&gt;PHP&lt;/code&gt;流！如下所示使用&lt;code class=&quot;highlighter-rouge&quot;&gt;file://&lt;/code&gt;流封装协议创建了一个读写&lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/hosts&lt;/code&gt;文件的流。&lt;/p&gt;

&lt;div class=&quot;language-php highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?php&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$handle&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;fopen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'/etc/hosts'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'rb'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;feof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$handle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;fgets&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$hand1e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;fclose&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$handle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;和下面示例的作用一样，不过这一次我们在流标识符中明确指定了&lt;code class=&quot;highlighter-rouge&quot;&gt;file://&lt;/code&gt;流封装协议。&lt;/p&gt;

&lt;div class=&quot;language-php highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?php&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$handle&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;fopen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'file:///etc/hosts'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'rb'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;feof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$hand1e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;fgets&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$handle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;fclose&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$handle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们通常会省略&lt;code class=&quot;highlighter-rouge&quot;&gt;file://&lt;/code&gt;封装协议，因为这是&lt;code class=&quot;highlighter-rouge&quot;&gt;PHP&lt;/code&gt;使用的默认值。&lt;/p&gt;

&lt;h5 id=&quot;php流封装协议&quot;&gt;php://流封装协议&lt;/h5&gt;

&lt;p&gt;编写命令行脚本的PHP开发者会感激&lt;code class=&quot;highlighter-rouge&quot;&gt;php://&lt;/code&gt;流封装协议。这个流封装协议的作用是与PHP脚本的标准输人、标准输出和标准错误文件描述符通信。我们可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;PHP&lt;/code&gt;提供的文件系统函数打开、读取或写入下述四个流：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;php://stdin&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这是个只读&lt;code class=&quot;highlighter-rouge&quot;&gt;PHP&lt;/code&gt;流，其中的数据来自标准输入。例如，&lt;code class=&quot;highlighter-rouge&quot;&gt;PHP&lt;/code&gt;脚本可以使用这个流接收命令行传入脚本的信息。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;php://stdout&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这个&lt;code class=&quot;highlighter-rouge&quot;&gt;PHP&lt;/code&gt;流的作用是把数据写入当前的输出缓冲区。这个流只能写，无法读或寻址。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;php://memory&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这个&lt;code class=&quot;highlighter-rouge&quot;&gt;PHP&lt;/code&gt;流的作用是从系统内存中读取数据，或者把数据写入系统内存。这个&lt;code class=&quot;highlighter-rouge&quot;&gt;PHP&lt;/code&gt;流的缺点是，可用内存是有限的。使用&lt;code class=&quot;highlighter-rouge&quot;&gt;php://temp&lt;/code&gt;流更安全。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;php://temp&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这个&lt;code class=&quot;highlighter-rouge&quot;&gt;PHP&lt;/code&gt;流的作用和&lt;code class=&quot;highlighter-rouge&quot;&gt;php://memoey&lt;/code&gt;类似，不过，没有可用内存时，&lt;code class=&quot;highlighter-rouge&quot;&gt;PHP&lt;/code&gt;会把数据写入临时文件。&lt;/p&gt;

&lt;h5 id=&quot;其他流封装协议&quot;&gt;其他流封装协议&lt;/h5&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;PHP&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;PHP&lt;/code&gt;扩展还提供了很多其他流封装协议，例如，与&lt;code class=&quot;highlighter-rouge&quot;&gt;ZIP&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;TAR&lt;/code&gt;压缩文件、&lt;code class=&quot;highlighter-rouge&quot;&gt;FTP&lt;/code&gt;服务器、数据压缩库、亚马逊&lt;code class=&quot;highlighter-rouge&quot;&gt;API&lt;/code&gt;等通信的流封装协议。开发者经常误以为&lt;code class=&quot;highlighter-rouge&quot;&gt;PHP&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;fopen()&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;fgets()&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;fputs()&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;feof()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;fc1ose()&lt;/code&gt;等文件系统函数只能用来处理文件系统中的文件。 事实并非如此。 PHP的文件系统函数能在所有支持这些函数的流封装协议中使用。例如，我们可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;fopen()&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;fgets()&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;fputs()&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;feof()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;fc1ose()&lt;/code&gt;函数处理&lt;code class=&quot;highlighter-rouge&quot;&gt;ZIP&lt;/code&gt;压缩文件和亚马逊S3服务（通过自定义的S3封装协议，http://bit.1y/streamwrap），甚至还能处理&lt;code class=&quot;highlighter-rouge&quot;&gt;Dropbox&lt;/code&gt;中的文件（通过自定义的&lt;a href=&quot;http://www.dropbbox-php.com&quot;&gt;Dropbox封装协议&lt;/a&gt;）。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意: 关于&lt;code class=&quot;highlighter-rouge&quot;&gt;php://&lt;/code&gt;流封装协议的更多信息，请查看&lt;code class=&quot;highlighter-rouge&quot;&gt;PHP&lt;/code&gt;的&lt;a href=&quot;http://bit.ly/s-wrapper&quot;&gt;网站&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&quot;自定义流封装协议&quot;&gt;自定义流封装协议&lt;/h5&gt;

&lt;p&gt;我们还可以白己编写&lt;code class=&quot;highlighter-rouge&quot;&gt;PHP&lt;/code&gt;流封装协议。&lt;code class=&quot;highlighter-rouge&quot;&gt;PHP&lt;/code&gt;提供了一个示例&lt;code class=&quot;highlighter-rouge&quot;&gt;streamWrapper&lt;/code&gt;类，演示如何编写自定义的流封装协议，支持部分或全部&lt;code class=&quot;highlighter-rouge&quot;&gt;PHP&lt;/code&gt;文件系统函数。关于如何编写自定义的&lt;code class=&quot;highlighter-rouge&quot;&gt;PHP&lt;/code&gt;流封装协议，更多信息参见：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://php.net/manual/class.streamwrapper.php&quot;&gt;http://php.net/manual/class.streamwrapper.php&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://php.net/manual/stream.streamwrapper.example-1.php&quot;&gt;http://php.net/manual/stream.streamwrapper.example-1.php&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;流上下文&quot;&gt;流上下文&lt;/h3&gt;

&lt;p&gt;有些&lt;code class=&quot;highlighter-rouge&quot;&gt;PHP&lt;/code&gt;流能接受一系列可选的参数，这些参数叫流上下文，用干定制流的行为。不同的流封装协议使用的上下义参数有所不同。流上下文使用&lt;code class=&quot;highlighter-rouge&quot;&gt;stream_context_create()&lt;/code&gt;函数创建。这个函数返回的上下文对象可以传入大多数文件系统和流函数。&lt;/p&gt;

&lt;p&gt;例如, 你知道可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;fi1e_get_contents()&lt;/code&gt;函数发送&lt;code class=&quot;highlighter-rouge&quot;&gt;HTTP POST&lt;/code&gt;请求吗? 如果想这么做，可以使用一个流上下文对象 (如下所示) 。&lt;/p&gt;

&lt;div class=&quot;language-php highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?php&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$quuestBody&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'{&quot;username&quot;:&quot;josh&quot;}'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$context&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;stream_context_create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;s1&quot;&gt;'http'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;s1&quot;&gt;'method'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'POST'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;s1&quot;&gt;'header'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Content-Type: application/json;charset=utf-8;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\r\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;
                    &lt;span class=&quot;s2&quot;&gt;&quot;Content-Length: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;mb_strlen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$requestBody&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
        &lt;span class=&quot;s1&quot;&gt;'content'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$requestBody&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;

&lt;span class=&quot;nv&quot;&gt;$response&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;file_get_contents&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'https://my-api.com/users'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;流上下文是个关联数组，最外层键是流封装协议的名称。流上下文数组中的值针对每个具体的流封装协议。可用的设置参见各个&lt;code class=&quot;highlighter-rouge&quot;&gt;PHP&lt;/code&gt;流封装协议的文档。&lt;/p&gt;

&lt;h3 id=&quot;流过滤器&quot;&gt;流过滤器&lt;/h3&gt;

&lt;p&gt;目前为止我们讨论了如何打开流，从流中读取数据，以及把数据写入流。可是，&lt;code class=&quot;highlighter-rouge&quot;&gt;PHP&lt;/code&gt;流真正强大的地方在于过滤、转换、添加或删除流中传输的数据。例如，我们可以打开一个流处理&lt;code class=&quot;highlighter-rouge&quot;&gt;Markdown&lt;/code&gt;文件，在把文件内容读入内存的过程中自动将其转换成HTML。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意：&lt;code class=&quot;highlighter-rouge&quot;&gt;PHP&lt;/code&gt;内置了几个流过滤器: &lt;code class=&quot;highlighter-rouge&quot;&gt;string.rot13&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;string.toupper&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;string.tolower&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;string.strip_tags&lt;/code&gt;。这些过滤器没什么用，我们要使用自定义的过滤器。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;若想把过滤器附加到现有的流上，要使用&lt;code class=&quot;highlighter-rouge&quot;&gt;stream_filter_append()&lt;/code&gt;函数。如下所示从本地文件系统中的文本文件里读取数据时使用了&lt;code class=&quot;highlighter-rouge&quot;&gt;string.toupper&lt;/code&gt;过滤器，目的是把义件中的内容转换成大写字母。我不建议使用这个过滤器，这里只是演示如何把过滤器附加到流上。&lt;/p&gt;

&lt;div class=&quot;language-php highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?php&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$handle&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;fopen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'data.txt'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'rb'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;stream_filter_append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$handle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'string.toupper'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;feof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$handle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;fgets&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$handle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// &amp;lt;-- 输出的全是大写字母&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;fclose&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$handle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们还可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;php://filter&lt;/code&gt;流封装协议把过滤器附加到流上。不过，使用这种方式之前必须先打开PHP流。和下面的示例的作用和前一个示例一样，可是这里我们使用&lt;code class=&quot;highlighter-rouge&quot;&gt;php://filter&lt;/code&gt;方式附加过滤器。&lt;/p&gt;

&lt;div class=&quot;language-php highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?php&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$handle&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;fopen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'php://filter/read=string.toupper/resource-data.txt'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'rb'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;whi1e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;feof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$handle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;fgets&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$hand1e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// &amp;lt;-- 输出的全是大写字母&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;fclose&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$handle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们要特别注意&lt;code class=&quot;highlighter-rouge&quot;&gt;fopen()&lt;/code&gt;函数的第一个参数。这个参数的值是&lt;code class=&quot;highlighter-rouge&quot;&gt;php://&lt;/code&gt;流封装协议的流标识符。达个流标识符中的目标如下所示:&lt;/p&gt;

&lt;div class=&quot;language-php highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;filter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;filter_name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;/&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;resource&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;scheme&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;://&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这种方式和&lt;code class=&quot;highlighter-rouge&quot;&gt;stream_fi1ter_append()&lt;/code&gt;函数相比较为繁琐。可是，&lt;code class=&quot;highlighter-rouge&quot;&gt;PHP&lt;/code&gt;的某些文件系统函数在调用后无法附加过滤器，例如&lt;code class=&quot;highlighter-rouge&quot;&gt;f11e()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;fpassthru()&lt;/code&gt;。所以，使用这些函数时只能使用&lt;code class=&quot;highlighter-rouge&quot;&gt;php://filter&lt;/code&gt;流封装协议附加流过滤器。&lt;/p&gt;

&lt;p&gt;下面看个更实际的流过滤器示例。 在&lt;a href=&quot;http://www.newmediacampaigns.com&quot;&gt;New Media Campaigns&lt;/a&gt;，我们内部的内容管理系统会把&lt;code class=&quot;highlighter-rouge&quot;&gt;nginx&lt;/code&gt;访问日志保存到&lt;a href=&quot;http://rsync.net&quot;&gt;rsync.net&lt;/a&gt;。我们把一天的访问情况保存在一个日志文件中，而且会使用&lt;code class=&quot;highlighter-rouge&quot;&gt;bzip2&lt;/code&gt;压缩每个日志文件。日志文件的名称使用&lt;code class=&quot;highlighter-rouge&quot;&gt;yyyy-MM-DD.log.bz2&lt;/code&gt;格式。领导让我提取过去30天某个域名的访问数据，这听起来有很多事要做，对吧？我要计算日期范围，确定日志文件的名称，通过&lt;code class=&quot;highlighter-rouge&quot;&gt;FTP&lt;/code&gt;连接&lt;code class=&quot;highlighter-rouge&quot;&gt;rsync.net&lt;/code&gt;，下载文件，解压缩文件，逐行迭代每个文件，把相应的行提取出来，然后把访间数据写入一个输出目标。你可能不相信，使用&lt;code class=&quot;highlighter-rouge&quot;&gt;PHP&lt;/code&gt;流，不到20行代码就能做完所有这些事情（如下所示）。&lt;/p&gt;

&lt;div class=&quot;language-php highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?php&lt;/span&gt;

&lt;span class=&quot;nv&quot;&gt;$dateStart&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;\DateTime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;nv&quot;&gt;$dateInterval&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;\DateInterval&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;createFromDateString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'-1 day'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$datePeriod&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;\DatePeriod&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$dateStart&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$dateInterval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;foreach&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$datePeriod&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$date&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;$file&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'sftp://USER:PASS@rsync.net/'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$date&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;format&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'Y—m-d'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'.log.bz2'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;file_exists&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nv&quot;&gt;$handle&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;fopen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'rb'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;nb&quot;&gt;stream_filter_append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$hand1e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'bzip2.decompress'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;feof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$handle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;nv&quot;&gt;$line&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;fgets&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$handle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;strpos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$line&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'www.example.com'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;nb&quot;&gt;fwrite&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;STDOUT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$line&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;nb&quot;&gt;fclose&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$handle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在上面的例子中：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;第2~4行创建一个持续30天的DatePeriod实例，一天一天反向向前推移。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;第6行使用每次迭代&lt;code class=&quot;highlighter-rouge&quot;&gt;DatePeriod&lt;/code&gt;实例得到的&lt;code class=&quot;highlighter-rouge&quot;&gt;DateTime&lt;/code&gt;实例创建日志文件的文件名。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;第8~9行使用&lt;code class=&quot;highlighter-rouge&quot;&gt;SFTP&lt;/code&gt;流封装协议打开位于&lt;code class=&quot;highlighter-rouge&quot;&gt;rsync.net&lt;/code&gt;上的日志文件流资源。我们把&lt;code class=&quot;highlighter-rouge&quot;&gt;bzip2-decompress&lt;/code&gt;流过滤器附加到日志文件流资源上，实时解压缩&lt;code class=&quot;highlighter-rouge&quot;&gt;bzip2&lt;/code&gt;格式的日志文件。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;第10~15行使用&lt;code class=&quot;highlighter-rouge&quot;&gt;PHP&lt;/code&gt;原生的文件系统函数迭代解压缩后的日志文件。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;第12~14行检查各行日志，看访问的是不是指定域名。如果是，把这一行日志写入标准输出。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;bzip2.decompress&lt;/code&gt;流过滤器可以在读取日志文件的同时自动解压缩。除此之外，我们还可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;shell_exe()&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;bzdecompress()&lt;/code&gt;函数，手动把日志文件解压缩到临时目录中，然后迭代解压缩后的文件，等&lt;code class=&quot;highlighter-rouge&quot;&gt;PHP&lt;/code&gt;脚本完成任务后再清理这些解压缩后的文件。不过，使用&lt;code class=&quot;highlighter-rouge&quot;&gt;PHP&lt;/code&gt;流更简单，也更忧雅。&lt;/p&gt;

&lt;h3 id=&quot;自定义流过滤器&quot;&gt;自定义流过滤器&lt;/h3&gt;

&lt;p&gt;我们还可以编写自定义的流过滤器。其实，犬多数情况下部要使用自定义的流过滤器。自定义的流过滤器是个&lt;code class=&quot;highlighter-rouge&quot;&gt;PHP&lt;/code&gt;类，扩展内置的&lt;a href=&quot;http://php.net/manual/en/Class.php—user-filter.php&quot;&gt;php_user_filter类&lt;/a&gt;这个类必须实现&lt;code class=&quot;highlighter-rouge&quot;&gt;filter()&lt;/code&gt;、 &lt;code class=&quot;highlighter-rouge&quot;&gt;onCreate()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;onC1ose()&lt;/code&gt;方法。而且，必须使用&lt;code class=&quot;highlighter-rouge&quot;&gt;stream_filter_register()&lt;/code&gt;函数注册自定义的流过滤器。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意 &lt;strong&gt;桶排成一排流过来了!&lt;/strong&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;PHP&lt;/code&gt;流会把数据分成按次序排列的桶，一个桶中盛放的流数据量是固定的（例如4096字节）。如果还用管道比喻，就是把水放在一个个水桶中，顺着管道从出发地溧流到目的地，在漂流的过程中会经过流过滤器，流过滤器一次能接收并处理一个或多个桶。一定时闾内过滤器接收到的桶叫做桶队列。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;下面我们自定义一个流过滤器，在把流中的数据读入内存时审查其中的脏字 (如下所示) 。首先，我们必须创建一个PHP类，让它扩展&lt;code class=&quot;highlighter-rouge&quot;&gt;php_user_filter&lt;/code&gt;类。这个类必须实现&lt;code class=&quot;highlighter-rouge&quot;&gt;filter()&lt;/code&gt;方法，这个方法是个筛子，用于过滤流经的桶。这个方法的参数是上游漂来的桶队列，处理过队列中的每个桶对象后，再把桶排成一排，向下游的目的地漂去。我们自定义的&lt;code class=&quot;highlighter-rouge&quot;&gt;DirtyWordsFilter&lt;/code&gt;流过滤器如下所示。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;建议: 桶队列中的每个桶对象都有两个公开属性：&lt;code class=&quot;highlighter-rouge&quot;&gt;data&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;datalen&lt;/code&gt;。这两个属性的值分别是桶中的内容和内容的长度。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-php highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DirtyWordsFilter&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;php_user_fi1ter&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;sd&quot;&gt;/**
    * @param resource $in 流来的桶队列
    * @param resource $out 流走的桶队列
    * @param int $consumed 处理的字节数
    * @param bool $closing 是流中的最后一个桶排序吗？
    */&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;filter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$in&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$out&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$consumed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$closing&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nv&quot;&gt;$words&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'inme'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'dirt'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'grease'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;nv&quot;&gt;$wordData&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;foreach&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$words&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$word&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;nv&quot;&gt;$replacement&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;array_fill&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;mh_strlen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$word&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'*'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;nv&quot;&gt;$wordData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$word&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;implode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;, &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$replacement&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;);
        }
        &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$bad&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; = array_keys(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$wordData&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;);
        &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$good&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; = array_values(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$wordData&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;);

        // 迭代流来的桶队列中的每个桶

        while (&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$bucket&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; = stream_bucket_make_writeable(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$in&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;)) {
            // 审查桶数据中的脏字
            &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$bucket-&amp;gt;data&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; = str_replace(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$bad&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;, &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$good&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;, &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$bucket-&amp;gt;data&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;);

            // 增加已处理的数据量

            &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$consumed&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; += &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$bucket-&amp;gt;datalen&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;;

            // 把桶放入流向下游的队列中
            stream_bucket_append(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$out&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;, &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$bucket&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;);
        }
        return PSFS_PASS_ON;
    }
}
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;filter()&lt;/code&gt;方法的作用是接收、处理再转运桶中的流数据。在&lt;code class=&quot;highlighter-rouge&quot;&gt;filter()&lt;/code&gt;方法中，我们迭代桶队列&lt;code class=&quot;highlighter-rouge&quot;&gt;$in&lt;/code&gt;中的桶，把脏字替换成审查后的值。这个方法的返回值是&lt;code class=&quot;highlighter-rouge&quot;&gt;PSFS_PASS_ON&lt;/code&gt;常量，表示操作成功。这个方法接收四个参数:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$in&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;上游流来的一个队列，有一个或多个桶，桶中是从出发地流来的数据。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$out&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;由一个桶或多个桶组成的队列，流向下游的流目的地。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;$consumed&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;自定义的过滤器处理的流数据总字节数。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$closing&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;filter())&lt;/code&gt;方法接收的是最后一个桶队列吗?&lt;/p&gt;

&lt;p&gt;然后，我们必须使用&lt;code class=&quot;highlighter-rouge&quot;&gt;stream_filter_register&lt;/code&gt;函数注册这个自定义的&lt;code class=&quot;highlighter-rouge&quot;&gt;DirtyWordsFilter&lt;/code&gt;流过滤器（如下所示）。&lt;/p&gt;

&lt;div class=&quot;language-php highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?php&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;stream_filter_register&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'dirty_words_filter'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'DirtyNordsFilter'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;第一个参数是用于识别这个自定义过滤器的过滤器名，第二个参数是这个自定义过滤器的类名。现在可以使用这个自定义的流过滤器了（如下所示）。&lt;/p&gt;

&lt;div class=&quot;language-php highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?php&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$hand1e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;fopen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'data.txt'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'rb'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;stream_filter_append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$handle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'dirty_words_filter'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;feof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$handle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;fgets&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$hand1e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// &amp;lt;-- 输出审查后的文本&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;fclose&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$handle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;建议：如果想进一步学习&lt;code class=&quot;highlighter-rouge&quot;&gt;PHP&lt;/code&gt;流，请观看&lt;code class=&quot;highlighter-rouge&quot;&gt;Nomad PHP&lt;/code&gt;网站中&lt;a href=&quot;http://bit.ly/nomad-php&quot;&gt;伊丽莎白-史密斯的演讲&lt;/a&gt;。这个视频不是免费的, 但值那个价。你还可以阅读&lt;a href=&quot;http://php.net/manual/en/books.stream.php&quot;&gt;PHP文档&lt;/a&gt;，进一步学习&lt;code class=&quot;highlighter-rouge&quot;&gt;PHP&lt;/code&gt;流。&lt;/p&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Mon, 10 Jun 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/06/10/php-stream/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/06/10/php-stream/</guid>
        
        <category>php</category>
        
        
      </item>
    
      <item>
        <title>「转载」命令行的艺术</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;原文地址&lt;a href=&quot;https://github.com/jlevy/the-art-of-command-line/edit/master/README-zh.md&quot;&gt;https://github.com/jlevy/the-art-of-command-line/edit/master/README-zh.md&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;命令行的艺术&quot;&gt;命令行的艺术&lt;/h1&gt;

&lt;p&gt;熟练使用命令行是一种常常被忽视，或被认为难以掌握的技能，但实际上，它会提高你作为工程师的灵活性以及生产力。本文是一份我在 Linux 上工作时，发现的一些命令行使用技巧的摘要。有些技巧非常基础，而另一些则相当复杂，甚至晦涩难懂。这篇文章并不长，但当你能够熟练掌握这里列出的所有技巧时，你就学会了很多关于命令行的东西了。&lt;/p&gt;

&lt;p&gt;这篇文章是&lt;a href=&quot;AUTHORS.md&quot;&gt;许多作者和译者&lt;/a&gt;共同的成果。
这里的部分内容
&lt;a href=&quot;http://www.quora.com/What-are-some-lesser-known-but-useful-Unix-commands&quot;&gt;首次&lt;/a&gt;
&lt;a href=&quot;http://www.quora.com/What-are-the-most-useful-Swiss-army-knife-one-liners-on-Unix&quot;&gt;出现&lt;/a&gt;
于 &lt;a href=&quot;http://www.quora.com/What-are-some-time-saving-tips-that-every-Linux-user-should-know&quot;&gt;Quora&lt;/a&gt;，
但已经迁移到了 Github，并由众多高手做出了许多改进。
如果你在本文中发现了错误或者存在可以改善的地方，请&lt;a href=&quot;/CONTRIBUTING.md&quot;&gt;&lt;strong&gt;贡献你的一份力量&lt;/strong&gt;&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;涵盖范围：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;这篇文章不仅能帮助刚接触命令行的新手，而且对具有经验的人也大有裨益。本文致力于做到&lt;em&gt;覆盖面广&lt;/em&gt;（涉及所有重要的内容），&lt;em&gt;具体&lt;/em&gt;（给出具体的最常用的例子），以及&lt;em&gt;简洁&lt;/em&gt;（避免冗余的内容，或是可以在其他地方轻松查到的细枝末节）。在特定应用场景下，本文的内容属于基本功或者能帮助您节约大量的时间。&lt;/li&gt;
  &lt;li&gt;本文主要为 Linux 所写，但在&lt;a href=&quot;#仅限-os-x-系统&quot;&gt;仅限 OS X 系统&lt;/a&gt;章节和&lt;a href=&quot;#仅限-windows-系统&quot;&gt;仅限 Windows 系统&lt;/a&gt;章节中也包含有对应操作系统的内容。除去这两个章节外，其它的内容大部分均可在其他类 Unix 系统或 OS X，甚至 Cygwin 中得到应用。&lt;/li&gt;
  &lt;li&gt;本文主要关注于交互式 Bash，但也有很多技巧可以应用于其他 shell 和 Bash 脚本当中。&lt;/li&gt;
  &lt;li&gt;除去“标准的”Unix 命令，本文还包括了一些依赖于特定软件包的命令（前提是它们具有足够的价值）。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;注意事项：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;为了能在一页内展示尽量多的东西，一些具体的信息可以在引用的页面中找到。我们相信机智的你知道如何使用 Google 或者其他搜索引擎来查阅到更多的详细信息。文中部分命令需要您使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;apt-get&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;yum&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;dnf&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;pacman&lt;/code&gt;，
&lt;code class=&quot;highlighter-rouge&quot;&gt;pip&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;brew&lt;/code&gt;（以及其它合适的包管理器）来安装依赖的程序。&lt;/li&gt;
  &lt;li&gt;遇到问题的话，请尝试使用 &lt;a href=&quot;http://explainshell.com/&quot;&gt;Explainshell&lt;/a&gt; 去获取相关命令、参数、管道等内容的解释。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;基础&quot;&gt;基础&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;学习 Bash 的基础知识。具体地，在命令行中输入 &lt;code class=&quot;highlighter-rouge&quot;&gt;man bash&lt;/code&gt; 并至少全文浏览一遍; 它理解起来很简单并且不冗长。其他的 shell 可能很好用，但 Bash 的功能已经足够强大并且到几乎总是可用的（ 如果你&lt;em&gt;只&lt;/em&gt;学习 zsh，fish 或其他的 shell 的话，在你自己的设备上会显得很方便，但过度依赖这些功能会给您带来不便，例如当你需要在服务器上工作时）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;熟悉至少一个基于文本的编辑器。通常而言 Vim （&lt;code class=&quot;highlighter-rouge&quot;&gt;vi&lt;/code&gt;） 会是你最好的选择，毕竟在终端中编辑文本时 Vim 是最好用的工具（甚至大部分情况下 Vim 要比 Emacs、大型 IDE 或是炫酷的编辑器更好用）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;学会如何使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;man&lt;/code&gt; 命令去阅读文档。学会使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;apropos&lt;/code&gt; 去查找文档。知道有些命令并不对应可执行文件，而是在 Bash 内置好的，此时可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;help&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;help -d&lt;/code&gt; 命令获取帮助信息。你可以用 &lt;code class=&quot;highlighter-rouge&quot;&gt;type 命令&lt;/code&gt; 来判断这个命令到底是可执行文件、shell 内置命令还是别名。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;学会使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;&lt;/code&gt; 来重定向输出和输入，学会使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;|&lt;/code&gt; 来重定向管道。明白 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&lt;/code&gt; 会覆盖了输出文件而 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&amp;gt;&lt;/code&gt; 是在文件末添加。了解标准输出 stdout 和标准错误 stderr。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;学会使用通配符 &lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt; （或许再算上 &lt;code class=&quot;highlighter-rouge&quot;&gt;?&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;[&lt;/code&gt;…&lt;code class=&quot;highlighter-rouge&quot;&gt;]&lt;/code&gt;） 和引用以及引用中 &lt;code class=&quot;highlighter-rouge&quot;&gt;'&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;&lt;/code&gt; 的区别（后文中有一些具体的例子）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;熟悉 Bash 中的任务管理工具：&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&lt;/code&gt;，&lt;strong&gt;ctrl-z&lt;/strong&gt;，&lt;strong&gt;ctrl-c&lt;/strong&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;jobs&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;fg&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;bg&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;kill&lt;/code&gt; 等。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;学会使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;ssh&lt;/code&gt; 进行远程命令行登录，最好知道如何使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;ssh-agent&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;ssh-add&lt;/code&gt; 等命令来实现基础的无密码认证登录。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;学会基本的文件管理工具：&lt;code class=&quot;highlighter-rouge&quot;&gt;ls&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;ls -l&lt;/code&gt; （了解 &lt;code class=&quot;highlighter-rouge&quot;&gt;ls -l&lt;/code&gt; 中每一列代表的意义），&lt;code class=&quot;highlighter-rouge&quot;&gt;less&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;head&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;tail&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;tail -f&lt;/code&gt; （甚至 &lt;code class=&quot;highlighter-rouge&quot;&gt;less +F&lt;/code&gt;），&lt;code class=&quot;highlighter-rouge&quot;&gt;ln&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;ln -s&lt;/code&gt; （了解硬链接与软链接的区别），&lt;code class=&quot;highlighter-rouge&quot;&gt;chown&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;chmod&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;du&lt;/code&gt; （硬盘使用情况概述：&lt;code class=&quot;highlighter-rouge&quot;&gt;du -hs *&lt;/code&gt;）。 关于文件系统的管理，学习 &lt;code class=&quot;highlighter-rouge&quot;&gt;df&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;mount&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;fdisk&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;mkfs&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;lsblk&lt;/code&gt;。知道 inode 是什么（与 &lt;code class=&quot;highlighter-rouge&quot;&gt;ls -i&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;df -i&lt;/code&gt; 等命令相关）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;学习基本的网络管理工具：&lt;code class=&quot;highlighter-rouge&quot;&gt;ip&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;ifconfig&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;dig&lt;/code&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;学习并使用一种版本控制管理系统，例如 &lt;code class=&quot;highlighter-rouge&quot;&gt;git&lt;/code&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;熟悉正则表达式，学会使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;grep&lt;/code&gt;／&lt;code class=&quot;highlighter-rouge&quot;&gt;egrep&lt;/code&gt;，它们的参数中 &lt;code class=&quot;highlighter-rouge&quot;&gt;-i&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;-o&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;-v&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;-A&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;-B&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;-C&lt;/code&gt; 这些是很常用并值得认真学习的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;学会使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;apt-get&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;yum&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;dnf&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;pacman&lt;/code&gt; （具体使用哪个取决于你使用的 Linux 发行版）来查找和安装软件包。并确保你的环境中有 &lt;code class=&quot;highlighter-rouge&quot;&gt;pip&lt;/code&gt; 来安装基于 Python 的命令行工具 （接下来提到的部分程序使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;pip&lt;/code&gt; 来安装会很方便）。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;日常使用&quot;&gt;日常使用&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;在 Bash 中，可以通过按 &lt;strong&gt;Tab&lt;/strong&gt; 键实现自动补全参数，使用 &lt;strong&gt;ctrl-r&lt;/strong&gt; 搜索命令行历史记录（按下按键之后，输入关键字便可以搜索，重复按下 &lt;strong&gt;ctrl-r&lt;/strong&gt; 会向后查找匹配项，按下 &lt;strong&gt;Enter&lt;/strong&gt; 键会执行当前匹配的命令，而按下右方向键会将匹配项放入当前行中，不会直接执行，以便做出修改）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在 Bash 中，可以按下 &lt;strong&gt;ctrl-w&lt;/strong&gt; 删除你键入的最后一个单词，&lt;strong&gt;ctrl-u&lt;/strong&gt; 可以删除行内光标所在位置之前的内容，&lt;strong&gt;alt-b&lt;/strong&gt; 和 &lt;strong&gt;alt-f&lt;/strong&gt; 可以以单词为单位移动光标，&lt;strong&gt;ctrl-a&lt;/strong&gt; 可以将光标移至行首，&lt;strong&gt;ctrl-e&lt;/strong&gt; 可以将光标移至行尾，&lt;strong&gt;ctrl-k&lt;/strong&gt; 可以删除光标至行尾的所有内容，&lt;strong&gt;ctrl-l&lt;/strong&gt; 可以清屏。键入 &lt;code class=&quot;highlighter-rouge&quot;&gt;man readline&lt;/code&gt; 可以查看 Bash 中的默认快捷键。内容有很多，例如 &lt;strong&gt;alt-.&lt;/strong&gt; 循环地移向前一个参数，而 &lt;strong&gt;alt-&lt;/strong&gt;* 可以展开通配符。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;你喜欢的话，可以执行 &lt;code class=&quot;highlighter-rouge&quot;&gt;set -o vi&lt;/code&gt; 来使用 vi 风格的快捷键，而执行 &lt;code class=&quot;highlighter-rouge&quot;&gt;set -o emacs&lt;/code&gt; 可以把它改回来。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;为了便于编辑长命令，在设置你的默认编辑器后（例如 &lt;code class=&quot;highlighter-rouge&quot;&gt;export EDITOR=vim&lt;/code&gt;），&lt;strong&gt;ctrl-x&lt;/strong&gt; &lt;strong&gt;ctrl-e&lt;/strong&gt; 会打开一个编辑器来编辑当前输入的命令。在 vi 风格下快捷键则是 &lt;strong&gt;escape-v&lt;/strong&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;键入 &lt;code class=&quot;highlighter-rouge&quot;&gt;history&lt;/code&gt; 查看命令行历史记录，再用 &lt;code class=&quot;highlighter-rouge&quot;&gt;!n&lt;/code&gt;（&lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt; 是命令编号）就可以再次执行。其中有许多缩写，最有用的大概就是 &lt;code class=&quot;highlighter-rouge&quot;&gt;!$&lt;/code&gt;， 它用于指代上次键入的参数，而 &lt;code class=&quot;highlighter-rouge&quot;&gt;!!&lt;/code&gt; 可以指代上次键入的命令了（参考 man 页面中的“HISTORY EXPANSION”）。不过这些功能，你也可以通过快捷键 &lt;strong&gt;ctrl-r&lt;/strong&gt; 和 &lt;strong&gt;alt-.&lt;/strong&gt; 来实现。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cd&lt;/code&gt; 命令可以切换工作路径，输入 &lt;code class=&quot;highlighter-rouge&quot;&gt;cd ~&lt;/code&gt; 可以进入 home 目录。要访问你的 home 目录中的文件，可以使用前缀 &lt;code class=&quot;highlighter-rouge&quot;&gt;~&lt;/code&gt;（例如 &lt;code class=&quot;highlighter-rouge&quot;&gt;~/.bashrc&lt;/code&gt;）。在 &lt;code class=&quot;highlighter-rouge&quot;&gt;sh&lt;/code&gt; 脚本里则用环境变量 &lt;code class=&quot;highlighter-rouge&quot;&gt;$HOME&lt;/code&gt; 指代 home 目录的路径。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;回到前一个工作路径：&lt;code class=&quot;highlighter-rouge&quot;&gt;cd -&lt;/code&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果你输入命令的时候中途改了主意，按下 &lt;strong&gt;alt-#&lt;/strong&gt; 在行首添加 &lt;code class=&quot;highlighter-rouge&quot;&gt;#&lt;/code&gt; 把它当做注释再按下回车执行（或者依次按下 &lt;strong&gt;ctrl-a&lt;/strong&gt;， &lt;strong&gt;#&lt;/strong&gt;， &lt;strong&gt;enter&lt;/strong&gt;）。这样做的话，之后借助命令行历史记录，你可以很方便恢复你刚才输入到一半的命令。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;xargs&lt;/code&gt; （ 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;parallel&lt;/code&gt;）。他们非常给力。注意到你可以控制每行参数个数（&lt;code class=&quot;highlighter-rouge&quot;&gt;-L&lt;/code&gt;）和最大并行数（&lt;code class=&quot;highlighter-rouge&quot;&gt;-P&lt;/code&gt;）。如果你不确定它们是否会按你想的那样工作，先使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;xargs echo&lt;/code&gt; 查看一下。此外，使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;-I{}&lt;/code&gt; 会很方便。例如：
    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    find &lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-name&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'*.py'&lt;/span&gt; | xargs &lt;span class=&quot;nb&quot;&gt;grep &lt;/span&gt;some_function
    &lt;span class=&quot;nb&quot;&gt;cat &lt;/span&gt;hosts | xargs &lt;span class=&quot;nt&quot;&gt;-I&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{}&lt;/span&gt; ssh root@&lt;span class=&quot;o&quot;&gt;{}&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;hostname&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;pstree -p&lt;/code&gt; 以一种优雅的方式展示进程树。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;pgrep&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;pkill&lt;/code&gt; 根据名字查找进程或发送信号（&lt;code class=&quot;highlighter-rouge&quot;&gt;-f&lt;/code&gt; 参数通常有用）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;了解你可以发往进程的信号的种类。比如，使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;kill -STOP [pid]&lt;/code&gt; 停止一个进程。使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;man 7 signal&lt;/code&gt; 查看详细列表。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;nohup&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;disown&lt;/code&gt; 使一个后台进程持续运行。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;netstat -lntp&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;ss -plat&lt;/code&gt; 检查哪些进程在监听端口（默认是检查 TCP 端口; 添加参数 &lt;code class=&quot;highlighter-rouge&quot;&gt;-u&lt;/code&gt; 则检查 UDP 端口）或者 &lt;code class=&quot;highlighter-rouge&quot;&gt;lsof -iTCP -sTCP:LISTEN -P -n&lt;/code&gt; (这也可以在 OS X 上运行)。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;lsof&lt;/code&gt; 来查看开启的套接字和文件。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;uptime&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;w&lt;/code&gt; 来查看系统已经运行多长时间。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;alias&lt;/code&gt; 来创建常用命令的快捷形式。例如：&lt;code class=&quot;highlighter-rouge&quot;&gt;alias ll='ls -latr'&lt;/code&gt; 创建了一个新的命令别名 &lt;code class=&quot;highlighter-rouge&quot;&gt;ll&lt;/code&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;可以把别名、shell 选项和常用函数保存在 &lt;code class=&quot;highlighter-rouge&quot;&gt;~/.bashrc&lt;/code&gt;，具体看下这篇&lt;a href=&quot;http://superuser.com/a/183980/7106&quot;&gt;文章&lt;/a&gt;。这样做的话你就可以在所有 shell 会话中使用你的设定。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;把环境变量的设定以及登陆时要执行的命令保存在 &lt;code class=&quot;highlighter-rouge&quot;&gt;~/.bash_profile&lt;/code&gt;。而对于从图形界面启动的 shell 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;cron&lt;/code&gt; 启动的 shell，则需要单独配置文件。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;要想在几台电脑中同步你的配置文件（例如 &lt;code class=&quot;highlighter-rouge&quot;&gt;.bashrc&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;.bash_profile&lt;/code&gt;），可以借助 Git。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当变量和文件名中包含空格的时候要格外小心。Bash 变量要用引号括起来，比如 &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;$FOO&quot;&lt;/code&gt;。尽量使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;-0&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;-print0&lt;/code&gt; 选项以便用 NULL 来分隔文件名，例如 &lt;code class=&quot;highlighter-rouge&quot;&gt;locate -0 pattern | xargs -0 ls -al&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;find / -print0 -type d | xargs -0 ls -al&lt;/code&gt;。如果 for 循环中循环访问的文件名含有空字符（空格、tab 等字符），只需用 &lt;code class=&quot;highlighter-rouge&quot;&gt;IFS=$'\n'&lt;/code&gt; 把内部字段分隔符设为换行符。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;在 Bash 脚本中，使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;set -x&lt;/code&gt; 去调试输出（或者使用它的变体 &lt;code class=&quot;highlighter-rouge&quot;&gt;set -v&lt;/code&gt;，它会记录原始输入，包括多余的参数和注释）。尽可能地使用严格模式：使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;set -e&lt;/code&gt; 令脚本在发生错误时退出而不是继续运行；使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;set -u&lt;/code&gt; 来检查是否使用了未赋值的变量；试试 &lt;code class=&quot;highlighter-rouge&quot;&gt;set -o pipefail&lt;/code&gt;，它可以监测管道中的错误。当牵扯到很多脚本时，使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;trap&lt;/code&gt; 来检测 ERR 和 EXIT。一个好的习惯是在脚本文件开头这样写，这会使它能够检测一些错误，并在错误发生时中断程序并输出信息：
    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;nb&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-euo&lt;/span&gt; pipefail
    &lt;span class=&quot;nb&quot;&gt;trap&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;echo 'error: Script failed: see failed command above'&quot;&lt;/span&gt; ERR
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;在 Bash 脚本中，子 shell（使用括号 &lt;code class=&quot;highlighter-rouge&quot;&gt;(...)&lt;/code&gt;）是一种组织参数的便捷方式。一个常见的例子是临时地移动工作路径，代码如下：
    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;c&quot;&gt;# do something in current dir&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; /some/other/dir &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; other-command&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;# continue in original dir&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在 Bash 中，变量有许多的扩展方式。&lt;code class=&quot;highlighter-rouge&quot;&gt;${name:?error message}&lt;/code&gt; 用于检查变量是否存在。此外，当 Bash 脚本只需要一个参数时，可以使用这样的代码 &lt;code class=&quot;highlighter-rouge&quot;&gt;input_file=${1:?usage: $0 input_file}&lt;/code&gt;。在变量为空时使用默认值：&lt;code class=&quot;highlighter-rouge&quot;&gt;${name:-default}&lt;/code&gt;。如果你要在之前的例子中再加一个（可选的）参数，可以使用类似这样的代码 &lt;code class=&quot;highlighter-rouge&quot;&gt;output_file=${2:-logfile}&lt;/code&gt;，如果省略了 $2，它的值就为空，于是 &lt;code class=&quot;highlighter-rouge&quot;&gt;output_file&lt;/code&gt; 就会被设为 &lt;code class=&quot;highlighter-rouge&quot;&gt;logfile&lt;/code&gt;。数学表达式：&lt;code class=&quot;highlighter-rouge&quot;&gt;i=$(( (i + 1) % 5 ))&lt;/code&gt;。序列：&lt;code class=&quot;highlighter-rouge&quot;&gt;{1..10}&lt;/code&gt;。截断字符串：&lt;code class=&quot;highlighter-rouge&quot;&gt;${var%suffix}&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;${var#prefix}&lt;/code&gt;。例如，假设 &lt;code class=&quot;highlighter-rouge&quot;&gt;var=foo.pdf&lt;/code&gt;，那么 &lt;code class=&quot;highlighter-rouge&quot;&gt;echo ${var%.pdf}.txt&lt;/code&gt; 将输出 &lt;code class=&quot;highlighter-rouge&quot;&gt;foo.txt&lt;/code&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用括号扩展（&lt;code class=&quot;highlighter-rouge&quot;&gt;{&lt;/code&gt;…&lt;code class=&quot;highlighter-rouge&quot;&gt;}&lt;/code&gt;）来减少输入相似文本，并自动化文本组合。这在某些情况下会很有用，例如 &lt;code class=&quot;highlighter-rouge&quot;&gt;mv foo.{txt,pdf} some-dir&lt;/code&gt;（同时移动两个文件），&lt;code class=&quot;highlighter-rouge&quot;&gt;cp somefile{,.bak}&lt;/code&gt;（会被扩展成 &lt;code class=&quot;highlighter-rouge&quot;&gt;cp somefile somefile.bak&lt;/code&gt;）或者 &lt;code class=&quot;highlighter-rouge&quot;&gt;mkdir -p test-{a,b,c}/subtest-{1,2,3}&lt;/code&gt;（会被扩展成所有可能的组合，并创建一个目录树）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;通过使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;(some command)&lt;/code&gt; 可以将输出视为文件。例如，对比本地文件 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/hosts&lt;/code&gt; 和一个远程文件：
    &lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    diff /etc/hosts &amp;lt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;ssh somehost &lt;span class=&quot;nb&quot;&gt;cat&lt;/span&gt; /etc/hosts&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;编写脚本时，你可能会想要把代码都放在大括号里。缺少右括号的话，代码就会因为语法错误而无法执行。如果你的脚本是要放在网上分享供他人使用的，这样的写法就体现出它的好处了，因为这样可以防止下载不完全代码被执行。
    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;# 在这里写代码&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;了解 Bash 中的“here documents”，例如 &lt;code class=&quot;highlighter-rouge&quot;&gt;cat &amp;lt;&amp;lt;EOF ...&lt;/code&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在 Bash 中，同时重定向标准输出和标准错误：&lt;code class=&quot;highlighter-rouge&quot;&gt;some-command &amp;gt;logfile 2&amp;gt;&amp;amp;1&lt;/code&gt; 或者 &lt;code class=&quot;highlighter-rouge&quot;&gt;some-command &amp;amp;&amp;gt;logfile&lt;/code&gt;。通常，为了保证命令不会在标准输入里残留一个未关闭的文件句柄捆绑在你当前所在的终端上，在命令后添加 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;/dev/null&lt;/code&gt; 是一个好习惯。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;man ascii&lt;/code&gt; 查看具有十六进制和十进制值的ASCII表。&lt;code class=&quot;highlighter-rouge&quot;&gt;man unicode&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;man utf-8&lt;/code&gt;，以及 &lt;code class=&quot;highlighter-rouge&quot;&gt;man latin1&lt;/code&gt; 有助于你去了解通用的编码信息。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;screen&lt;/code&gt; 或 &lt;a href=&quot;https://tmux.github.io/&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;tmux&lt;/code&gt;&lt;/a&gt; 来使用多份屏幕，当你在使用 ssh 时（保存 session 信息）将尤为有用。而 &lt;code class=&quot;highlighter-rouge&quot;&gt;byobu&lt;/code&gt; 可以为它们提供更多的信息和易用的管理工具。另一个轻量级的 session 持久化解决方案是 &lt;a href=&quot;https://github.com/bogner/dtach&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dtach&lt;/code&gt;&lt;/a&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ssh 中，了解如何使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;-L&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;-D&lt;/code&gt;（偶尔需要用 &lt;code class=&quot;highlighter-rouge&quot;&gt;-R&lt;/code&gt;）开启隧道是非常有用的，比如当你需要从一台远程服务器上访问 web 页面。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;对 ssh 设置做一些小优化可能是很有用的，例如这个 &lt;code class=&quot;highlighter-rouge&quot;&gt;~/.ssh/config&lt;/code&gt; 文件包含了防止特定网络环境下连接断开、压缩数据、多通道等选项：
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    TCPKeepAlive=yes
    ServerAliveInterval=15
    ServerAliveCountMax=6
    Compression=yes
    ControlMaster auto
    ControlPath /tmp/%r@%h:%p
    ControlPersist yes
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;一些其他的关于 ssh 的选项是与安全相关的，应当小心翼翼的使用。例如你应当只能在可信任的网络中启用 &lt;code class=&quot;highlighter-rouge&quot;&gt;StrictHostKeyChecking=no&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;ForwardAgent=yes&lt;/code&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;考虑使用 &lt;a href=&quot;https://mosh.mit.edu/&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;mosh&lt;/code&gt;&lt;/a&gt; 作为 ssh 的替代品，它使用 UDP 协议。它可以避免连接被中断并且对带宽需求更小，但它需要在服务端做相应的配置。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;获取八进制形式的文件访问权限（修改系统设置时通常需要，但 &lt;code class=&quot;highlighter-rouge&quot;&gt;ls&lt;/code&gt; 的功能不那么好用并且通常会搞砸），可以使用类似如下的代码：
    &lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;nb&quot;&gt;stat&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'%A %a %n'&lt;/span&gt; /etc/timezone
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用 &lt;a href=&quot;https://github.com/mooz/percol&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;percol&lt;/code&gt;&lt;/a&gt; 或者 &lt;a href=&quot;https://github.com/junegunn/fzf&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;fzf&lt;/code&gt;&lt;/a&gt; 可以交互式地从另一个命令输出中选取值。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;fpp&lt;/code&gt;（&lt;a href=&quot;https://github.com/facebook/PathPicker&quot;&gt;PathPicker&lt;/a&gt;）可以与基于另一个命令(例如 &lt;code class=&quot;highlighter-rouge&quot;&gt;git&lt;/code&gt;）输出的文件交互。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;将 web 服务器上当前目录下所有的文件（以及子目录）暴露给你所处网络的所有用户，使用：
&lt;code class=&quot;highlighter-rouge&quot;&gt;python -m SimpleHTTPServer 7777&lt;/code&gt; （使用端口 7777 和 Python 2）或&lt;code class=&quot;highlighter-rouge&quot;&gt;python -m http.server 7777&lt;/code&gt; （使用端口 7777 和 Python 3）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;以其他用户的身份执行命令，使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;sudo&lt;/code&gt;。默认以 root 用户的身份执行；使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;-u&lt;/code&gt; 来指定其他用户。使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;-i&lt;/code&gt; 来以该用户登录（需要输入_你自己的_密码）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;将 shell 切换为其他用户，使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;su username&lt;/code&gt; 或者 &lt;code class=&quot;highlighter-rouge&quot;&gt;sudo - username&lt;/code&gt;。加入 &lt;code class=&quot;highlighter-rouge&quot;&gt;-&lt;/code&gt; 会使得切换后的环境与使用该用户登录后的环境相同。省略用户名则默认为 root。切换到哪个用户，就需要输入_哪个用户的_密码。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;了解命令行的 &lt;a href=&quot;https://wiki.debian.org/CommonErrorMessages/ArgumentListTooLong&quot;&gt;128K 限制&lt;/a&gt;。使用通配符匹配大量文件名时，常会遇到“Argument list too long”的错误信息。（这种情况下换用 &lt;code class=&quot;highlighter-rouge&quot;&gt;find&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;xargs&lt;/code&gt; 通常可以解决。）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;当你需要一个基本的计算器时，可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;python&lt;/code&gt; 解释器（当然你要用 python 的时候也是这样）。例如：
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; 2+3
5
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;文件及数据处理&quot;&gt;文件及数据处理&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;在当前目录下通过文件名查找一个文件，使用类似于这样的命令：&lt;code class=&quot;highlighter-rouge&quot;&gt;find . -iname '*something*'&lt;/code&gt;。在所有路径下通过文件名查找文件，使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;locate something&lt;/code&gt; （但注意到 &lt;code class=&quot;highlighter-rouge&quot;&gt;updatedb&lt;/code&gt; 可能没有对最近新建的文件建立索引，所以你可能无法定位到这些未被索引的文件）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用 &lt;a href=&quot;https://github.com/ggreer/the_silver_searcher&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ag&lt;/code&gt;&lt;/a&gt; 在源代码或数据文件里检索（&lt;code class=&quot;highlighter-rouge&quot;&gt;grep -r&lt;/code&gt; 同样可以做到，但相比之下 &lt;code class=&quot;highlighter-rouge&quot;&gt;ag&lt;/code&gt; 更加先进）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;将 HTML 转为文本：&lt;code class=&quot;highlighter-rouge&quot;&gt;lynx -dump -stdin&lt;/code&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Markdown，HTML，以及所有文档格式之间的转换，试试 &lt;a href=&quot;http://pandoc.org/&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;pandoc&lt;/code&gt;&lt;/a&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当你要处理棘手的 XML 时候，&lt;code class=&quot;highlighter-rouge&quot;&gt;xmlstarlet&lt;/code&gt; 算是上古时代流传下来的神器。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用 &lt;a href=&quot;http://stedolan.github.io/jq/&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;jq&lt;/code&gt;&lt;/a&gt; 处理 JSON。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用 &lt;a href=&quot;https://github.com/0k/shyaml&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;shyaml&lt;/code&gt;&lt;/a&gt; 处理 YAML。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;要处理 Excel 或 CSV 文件的话，&lt;a href=&quot;https://github.com/onyxfish/csvkit&quot;&gt;csvkit&lt;/a&gt; 提供了 &lt;code class=&quot;highlighter-rouge&quot;&gt;in2csv&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;csvcut&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;csvjoin&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;csvgrep&lt;/code&gt; 等方便易用的工具。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当你要处理 Amazon S3 相关的工作的时候，&lt;a href=&quot;https://github.com/s3tools/s3cmd&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;s3cmd&lt;/code&gt;&lt;/a&gt; 是一个很方便的工具而 &lt;a href=&quot;https://github.com/bloomreach/s4cmd&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;s4cmd&lt;/code&gt;&lt;/a&gt; 的效率更高。Amazon 官方提供的 &lt;a href=&quot;https://github.com/aws/aws-cli&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;aws&lt;/code&gt;&lt;/a&gt; 以及  &lt;a href=&quot;https://github.com/donnemartin/saws&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;saws&lt;/code&gt;&lt;/a&gt; 是其他 AWS 相关工作的基础，值得学习。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;了解如何使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;sort&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;uniq&lt;/code&gt;，包括 uniq 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;-u&lt;/code&gt; 参数和 &lt;code class=&quot;highlighter-rouge&quot;&gt;-d&lt;/code&gt; 参数，具体内容在后文单行脚本节中。另外可以了解一下 &lt;code class=&quot;highlighter-rouge&quot;&gt;comm&lt;/code&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;了解如何使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;cut&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;paste&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;join&lt;/code&gt; 来更改文件。很多人都会使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;cut&lt;/code&gt;，但遗忘了 &lt;code class=&quot;highlighter-rouge&quot;&gt;join&lt;/code&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;了解如何运用 &lt;code class=&quot;highlighter-rouge&quot;&gt;wc&lt;/code&gt; 去计算新行数（&lt;code class=&quot;highlighter-rouge&quot;&gt;-l&lt;/code&gt;），字符数（&lt;code class=&quot;highlighter-rouge&quot;&gt;-m&lt;/code&gt;），单词数（&lt;code class=&quot;highlighter-rouge&quot;&gt;-w&lt;/code&gt;）以及字节数（&lt;code class=&quot;highlighter-rouge&quot;&gt;-c&lt;/code&gt;）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;了解如何使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;tee&lt;/code&gt; 将标准输入复制到文件甚至标准输出，例如 &lt;code class=&quot;highlighter-rouge&quot;&gt;ls -al | tee file.txt&lt;/code&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;要进行一些复杂的计算，比如分组、逆序和一些其他的统计分析，可以考虑使用 &lt;a href=&quot;https://www.gnu.org/software/datamash/&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;datamash&lt;/code&gt;&lt;/a&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;注意到语言设置（中文或英文等）对许多命令行工具有一些微妙的影响，比如排序的顺序和性能。大多数 Linux 的安装过程会将 &lt;code class=&quot;highlighter-rouge&quot;&gt;LANG&lt;/code&gt; 或其他有关的变量设置为符合本地的设置。要意识到当你改变语言设置时，排序的结果可能会改变。明白国际化可能会使 sort 或其他命令运行效率下降&lt;em&gt;许多倍&lt;/em&gt;。某些情况下（例如集合运算）你可以放心的使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;export LC_ALL=C&lt;/code&gt; 来忽略掉国际化并按照字节来判断顺序。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;你可以单独指定某一条命令的环境，只需在调用时把环境变量设定放在命令的前面，例如 &lt;code class=&quot;highlighter-rouge&quot;&gt;TZ=Pacific/Fiji date&lt;/code&gt; 可以获取斐济的时间。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;了解如何使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;awk&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;sed&lt;/code&gt; 来进行简单的数据处理。 参阅 &lt;a href=&quot;#one-liners&quot;&gt;One-liners&lt;/a&gt; 获取示例。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;替换一个或多个文件中出现的字符串：
    &lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    perl &lt;span class=&quot;nt&quot;&gt;-pi&lt;/span&gt;.bak &lt;span class=&quot;nt&quot;&gt;-e&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'s/old-string/new-string/g'&lt;/span&gt; my-files-&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;使用 &lt;a href=&quot;https://github.com/jlevy/repren&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;repren&lt;/code&gt;&lt;/a&gt; 来批量重命名文件，或是在多个文件中搜索替换内容。（有些时候 &lt;code class=&quot;highlighter-rouge&quot;&gt;rename&lt;/code&gt; 命令也可以批量重命名，但要注意，它在不同 Linux 发行版中的功能并不完全一样。）
    &lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;c&quot;&gt;# 将文件、目录和内容全部重命名 foo -&amp;gt; bar:&lt;/span&gt;
    repren &lt;span class=&quot;nt&quot;&gt;--full&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--preserve-case&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--from&lt;/span&gt; foo &lt;span class=&quot;nt&quot;&gt;--to&lt;/span&gt; bar &lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;# 还原所有备份文件 whatever.bak -&amp;gt; whatever:&lt;/span&gt;
    repren &lt;span class=&quot;nt&quot;&gt;--renames&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--from&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'(.*)\.bak'&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--to&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'\1'&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;.bak
    &lt;span class=&quot;c&quot;&gt;# 用 rename 实现上述功能（若可用）:&lt;/span&gt;
    rename &lt;span class=&quot;s1&quot;&gt;'s/\.bak$//'&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;.bak
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;根据 man 页面的描述，&lt;code class=&quot;highlighter-rouge&quot;&gt;rsync&lt;/code&gt; 是一个快速且非常灵活的文件复制工具。它闻名于设备之间的文件同步，但其实它在本地情况下也同样有用。在安全设置允许下，用 &lt;code class=&quot;highlighter-rouge&quot;&gt;rsync&lt;/code&gt; 代替 &lt;code class=&quot;highlighter-rouge&quot;&gt;scp&lt;/code&gt; 可以实现文件续传，而不用重新从头开始。它同时也是删除大量文件的&lt;a href=&quot;https://web.archive.org/web/20130929001850/http://linuxnote.net/jianingy/en/linux/a-fast-way-to-remove-huge-number-of-files.html&quot;&gt;最快方法&lt;/a&gt;之一：
    &lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;mkdir &lt;/span&gt;empty &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; rsync &lt;span class=&quot;nt&quot;&gt;-r&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--delete&lt;/span&gt; empty/ some-dir &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;rmdir &lt;/span&gt;some-dir
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;若要在复制文件时获取当前进度，可使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;pv&lt;/code&gt;，&lt;a href=&quot;https://github.com/dmerejkowsky/pycp&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;pycp&lt;/code&gt;&lt;/a&gt;，&lt;a href=&quot;https://github.com/Xfennec/progress&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;progress&lt;/code&gt;&lt;/a&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;rsync --progress&lt;/code&gt;。若所执行的复制为block块拷贝，可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;dd status=progress&lt;/code&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;shuf&lt;/code&gt; 可以以行为单位来打乱文件的内容或从一个文件中随机选取多行。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;了解 &lt;code class=&quot;highlighter-rouge&quot;&gt;sort&lt;/code&gt; 的参数。显示数字时，使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;-n&lt;/code&gt; 或者 &lt;code class=&quot;highlighter-rouge&quot;&gt;-h&lt;/code&gt; 来显示更易读的数（例如 &lt;code class=&quot;highlighter-rouge&quot;&gt;du -h&lt;/code&gt; 的输出）。明白排序时关键字的工作原理（&lt;code class=&quot;highlighter-rouge&quot;&gt;-t&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;-k&lt;/code&gt;）。例如，注意到你需要 &lt;code class=&quot;highlighter-rouge&quot;&gt;-k1，1&lt;/code&gt; 来仅按第一个域来排序，而 &lt;code class=&quot;highlighter-rouge&quot;&gt;-k1&lt;/code&gt; 意味着按整行排序。稳定排序（&lt;code class=&quot;highlighter-rouge&quot;&gt;sort -s&lt;/code&gt;）在某些情况下很有用。例如，以第二个域为主关键字，第一个域为次关键字进行排序，你可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;sort -k1，1 | sort -s -k2，2&lt;/code&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果你想在 Bash 命令行中写 tab 制表符，按下 &lt;strong&gt;ctrl-v&lt;/strong&gt; &lt;strong&gt;[Tab]&lt;/strong&gt; 或键入 &lt;code class=&quot;highlighter-rouge&quot;&gt;$'\t'&lt;/code&gt; （后者可能更好，因为你可以复制粘贴它）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;标准的源代码对比及合并工具是 &lt;code class=&quot;highlighter-rouge&quot;&gt;diff&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;patch&lt;/code&gt;。使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;diffstat&lt;/code&gt; 查看变更总览数据。注意到 &lt;code class=&quot;highlighter-rouge&quot;&gt;diff -r&lt;/code&gt; 对整个文件夹有效。使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;diff -r tree1 tree2 | diffstat&lt;/code&gt; 查看变更的统计数据。&lt;code class=&quot;highlighter-rouge&quot;&gt;vimdiff&lt;/code&gt; 用于比对并编辑文件。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对于二进制文件，使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;hd&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;hexdump&lt;/code&gt; 或者 &lt;code class=&quot;highlighter-rouge&quot;&gt;xxd&lt;/code&gt; 使其以十六进制显示，使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;bvi&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;hexedit&lt;/code&gt; 或者 &lt;code class=&quot;highlighter-rouge&quot;&gt;biew&lt;/code&gt; 来进行二进制编辑。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;同样对于二进制文件，&lt;code class=&quot;highlighter-rouge&quot;&gt;strings&lt;/code&gt;（包括 &lt;code class=&quot;highlighter-rouge&quot;&gt;grep&lt;/code&gt; 等工具）可以帮助在二进制文件中查找特定比特。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;制作二进制差分文件（Delta 压缩），使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;xdelta3&lt;/code&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;iconv&lt;/code&gt; 更改文本编码。需要更高级的功能，可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;uconv&lt;/code&gt;，它支持一些高级的 Unicode 功能。例如，这条命令移除了所有重音符号：
    &lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    uconv &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; utf-8 &lt;span class=&quot;nt&quot;&gt;-t&lt;/span&gt; utf-8 &lt;span class=&quot;nt&quot;&gt;-x&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'::Any-Lower; ::Any-NFD; [:Nonspacing Mark:] &amp;gt;; ::Any-NFC; '&lt;/span&gt; &amp;lt; input.txt &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; output.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;拆分文件可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;split&lt;/code&gt;（按大小拆分）和 &lt;code class=&quot;highlighter-rouge&quot;&gt;csplit&lt;/code&gt;（按模式拆分）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;操作日期和时间表达式，可以用 &lt;a href=&quot;http://www.fresse.org/dateutils/&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dateutils&lt;/code&gt;&lt;/a&gt; 中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;dateadd&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;datediff&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;strptime&lt;/code&gt; 等工具。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;zless&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;zmore&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;zcat&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;zgrep&lt;/code&gt; 对压缩过的文件进行操作。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;文件属性可以通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;chattr&lt;/code&gt; 进行设置，它比文件权限更加底层。例如，为了保护文件不被意外删除，可以使用不可修改标记：&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo chattr +i /critical/directory/or/file&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;getfacl&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;setfacl&lt;/code&gt; 以保存和恢复文件权限。例如：
    &lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; getfacl &lt;span class=&quot;nt&quot;&gt;-R&lt;/span&gt; /some/path &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; permissions.txt
 setfacl &lt;span class=&quot;nt&quot;&gt;--restore&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;permissions.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;为了高效地创建空文件，请使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;truncate&lt;/code&gt;（创建&lt;a href=&quot;https://zh.wikipedia.org/wiki/稀疏文件&quot;&gt;稀疏文件&lt;/a&gt;），&lt;code class=&quot;highlighter-rouge&quot;&gt;fallocate&lt;/code&gt;（用于 ext4，xfs，btrf 和 ocfs2 文件系统），&lt;code class=&quot;highlighter-rouge&quot;&gt;xfs_mkfile&lt;/code&gt;（适用于几乎所有的文件系统，包含在 xfsprogs 包中），&lt;code class=&quot;highlighter-rouge&quot;&gt;mkfile&lt;/code&gt;（用于类 Unix 操作系统，比如 Solaris 和 Mac OS）。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;系统调试&quot;&gt;系统调试&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;curl&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;curl -I&lt;/code&gt; 可以被轻松地应用于 web 调试中，它们的好兄弟 &lt;code class=&quot;highlighter-rouge&quot;&gt;wget&lt;/code&gt; 也是如此，或者也可以试试更潮的 &lt;a href=&quot;https://github.com/jkbrzt/httpie&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;httpie&lt;/code&gt;&lt;/a&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;获取 CPU 和硬盘的使用状态，通常使用使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;top&lt;/code&gt;（&lt;code class=&quot;highlighter-rouge&quot;&gt;htop&lt;/code&gt; 更佳），&lt;code class=&quot;highlighter-rouge&quot;&gt;iostat&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;iotop&lt;/code&gt;。而 &lt;code class=&quot;highlighter-rouge&quot;&gt;iostat -mxz 15&lt;/code&gt; 可以让你获悉 CPU 和每个硬盘分区的基本信息和性能表现。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;netstat&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;ss&lt;/code&gt; 查看网络连接的细节。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dstat&lt;/code&gt; 在你想要对系统的现状有一个粗略的认识时是非常有用的。然而若要对系统有一个深度的总体认识，使用 &lt;a href=&quot;https://github.com/nicolargo/glances&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;glances&lt;/code&gt;&lt;/a&gt;，它会在一个终端窗口中向你提供一些系统级的数据。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;若要了解内存状态，运行并理解 &lt;code class=&quot;highlighter-rouge&quot;&gt;free&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;vmstat&lt;/code&gt; 的输出。值得留意的是“cached”的值，它指的是 Linux 内核用来作为文件缓存的内存大小，而与空闲内存无关。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Java 系统调试则是一件截然不同的事，一个可以用于 Oracle 的 JVM 或其他 JVM 上的调试的技巧是你可以运行 &lt;code class=&quot;highlighter-rouge&quot;&gt;kill -3 &amp;lt;pid&amp;gt;&lt;/code&gt; 同时一个完整的栈轨迹和堆概述（包括 GC 的细节）会被保存到标准错误或是日志文件。JDK 中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;jps&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;jstat&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;jstack&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;jmap&lt;/code&gt; 很有用。&lt;a href=&quot;https://github.com/aragozin/jvm-tools&quot;&gt;SJK tools&lt;/a&gt; 更高级。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用 &lt;a href=&quot;http://www.bitwizard.nl/mtr/&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;mtr&lt;/code&gt;&lt;/a&gt; 去跟踪路由，用于确定网络问题。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;用 &lt;a href=&quot;https://dev.yorhel.nl/ncdu&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ncdu&lt;/code&gt;&lt;/a&gt; 来查看磁盘使用情况，它比寻常的命令，如 &lt;code class=&quot;highlighter-rouge&quot;&gt;du -sh *&lt;/code&gt;，更节省时间。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查找正在使用带宽的套接字连接或进程，使用 &lt;a href=&quot;http://www.ex-parrot.com/~pdw/iftop/&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;iftop&lt;/code&gt;&lt;/a&gt; 或 &lt;a href=&quot;https://github.com/raboof/nethogs&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;nethogs&lt;/code&gt;&lt;/a&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ab&lt;/code&gt; 工具（Apache 中自带）可以简单粗暴地检查 web 服务器的性能。对于更复杂的负载测试，使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;siege&lt;/code&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://wireshark.org/&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;wireshark&lt;/code&gt;&lt;/a&gt;，&lt;a href=&quot;https://www.wireshark.org/docs/wsug_html_chunked/AppToolstshark.html&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;tshark&lt;/code&gt;&lt;/a&gt; 和 &lt;a href=&quot;http://ngrep.sourceforge.net/&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ngrep&lt;/code&gt;&lt;/a&gt; 可用于复杂的网络调试。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;了解 &lt;code class=&quot;highlighter-rouge&quot;&gt;strace&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;ltrace&lt;/code&gt;。这俩工具在你的程序运行失败、挂起甚至崩溃，而你却不知道为什么或你想对性能有个总体的认识的时候是非常有用的。注意 profile 参数（&lt;code class=&quot;highlighter-rouge&quot;&gt;-c&lt;/code&gt;）和附加到一个运行的进程参数 （&lt;code class=&quot;highlighter-rouge&quot;&gt;-p&lt;/code&gt;）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;了解使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;ldd&lt;/code&gt; 来检查共享库。但是&lt;a href=&quot;http://www.catonmat.net/blog/ldd-arbitrary-code-execution/&quot;&gt;永远不要在不信任的文件上运行&lt;/a&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;了解如何运用 &lt;code class=&quot;highlighter-rouge&quot;&gt;gdb&lt;/code&gt; 连接到一个运行着的进程并获取它的堆栈轨迹。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;学会使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;/proc&lt;/code&gt;。它在调试正在出现的问题的时候有时会效果惊人。比如：&lt;code class=&quot;highlighter-rouge&quot;&gt;/proc/cpuinfo&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;/proc/meminfo&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;/proc/cmdline&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;/proc/xxx/cwd&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;/proc/xxx/exe&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;/proc/xxx/fd/&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;/proc/xxx/smaps&lt;/code&gt;（这里的 &lt;code class=&quot;highlighter-rouge&quot;&gt;xxx&lt;/code&gt; 表示进程的 id 或 pid）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当调试一些之前出现的问题的时候，&lt;a href=&quot;http://sebastien.godard.pagesperso-orange.fr/&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sar&lt;/code&gt;&lt;/a&gt; 非常有用。它展示了 cpu、内存以及网络等的历史数据。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;关于更深层次的系统分析以及性能分析，看看 &lt;code class=&quot;highlighter-rouge&quot;&gt;stap&lt;/code&gt;（&lt;a href=&quot;https://sourceware.org/systemtap/wiki&quot;&gt;SystemTap&lt;/a&gt;），&lt;a href=&quot;https://en.wikipedia.org/wiki/Perf_(Linux)&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;perf&lt;/code&gt;&lt;/a&gt;，以及&lt;a href=&quot;https://github.com/draios/sysdig&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sysdig&lt;/code&gt;&lt;/a&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查看你当前使用的系统，使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;uname&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;uname -a&lt;/code&gt;（Unix／kernel 信息）或者 &lt;code class=&quot;highlighter-rouge&quot;&gt;lsb_release -a&lt;/code&gt;（Linux 发行版信息）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;无论什么东西工作得很欢乐（可能是硬件或驱动问题）时可以试试 &lt;code class=&quot;highlighter-rouge&quot;&gt;dmesg&lt;/code&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果你删除了一个文件，但通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;du&lt;/code&gt; 发现没有释放预期的磁盘空间，请检查文件是否被进程占用：
&lt;code class=&quot;highlighter-rouge&quot;&gt;lsof | grep deleted | grep &quot;filename-of-my-big-file&quot;&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;单行脚本&quot;&gt;单行脚本&lt;/h2&gt;

&lt;p&gt;一些命令组合的例子：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;当你需要对文本文件做集合交、并、差运算时，&lt;code class=&quot;highlighter-rouge&quot;&gt;sort&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;uniq&lt;/code&gt; 会是你的好帮手。具体例子请参照代码后面的，此处假设 &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; 与 &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt; 是两内容不同的文件。这种方式效率很高，并且在小文件和上 G 的文件上都能运用（注意尽管在 &lt;code class=&quot;highlighter-rouge&quot;&gt;/tmp&lt;/code&gt; 在一个小的根分区上时你可能需要 &lt;code class=&quot;highlighter-rouge&quot;&gt;-T&lt;/code&gt; 参数，但是实际上 &lt;code class=&quot;highlighter-rouge&quot;&gt;sort&lt;/code&gt; 并不被内存大小约束），参阅前文中关于 &lt;code class=&quot;highlighter-rouge&quot;&gt;LC_ALL&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;sort&lt;/code&gt; 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;-u&lt;/code&gt; 参数的部分。
    &lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;nb&quot;&gt;sort &lt;/span&gt;a b | &lt;span class=&quot;nb&quot;&gt;uniq&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; c   &lt;span class=&quot;c&quot;&gt;# c 是 a 并 b&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;sort &lt;/span&gt;a b | &lt;span class=&quot;nb&quot;&gt;uniq&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; c   &lt;span class=&quot;c&quot;&gt;# c 是 a 交 b&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;sort &lt;/span&gt;a b b | &lt;span class=&quot;nb&quot;&gt;uniq&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-u&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; c   &lt;span class=&quot;c&quot;&gt;# c 是 a - b&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;grep . *&lt;/code&gt;（每行都会附上文件名）或者 &lt;code class=&quot;highlighter-rouge&quot;&gt;head -100 *&lt;/code&gt;（每个文件有一个标题）来阅读检查目录下所有文件的内容。这在检查一个充满配置文件的目录（如 &lt;code class=&quot;highlighter-rouge&quot;&gt;/sys&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;/proc&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;/etc&lt;/code&gt;）时特别好用。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;计算文本文件第三列中所有数的和（可能比同等作用的 Python 代码快三倍且代码量少三倍）：
    &lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;nb&quot;&gt;awk&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'{ x += $3 } END { print x }'&lt;/span&gt; myfile
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;如果你想在文件树上查看大小/日期，这可能看起来像递归版的 &lt;code class=&quot;highlighter-rouge&quot;&gt;ls -l&lt;/code&gt; 但比 &lt;code class=&quot;highlighter-rouge&quot;&gt;ls -lR&lt;/code&gt; 更易于理解：
    &lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    find &lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-type&lt;/span&gt; f &lt;span class=&quot;nt&quot;&gt;-ls&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;假设你有一个类似于 web 服务器日志文件的文本文件，并且一个确定的值只会出现在某些行上，假设一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;acct_id&lt;/code&gt; 参数在 URI 中。如果你想计算出每个 &lt;code class=&quot;highlighter-rouge&quot;&gt;acct_id&lt;/code&gt; 值有多少次请求，使用如下代码：
    &lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    egrep &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'acct_id=[0-9]+'&lt;/span&gt; access.log | &lt;span class=&quot;nb&quot;&gt;cut&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-f2&lt;/span&gt; | &lt;span class=&quot;nb&quot;&gt;sort&lt;/span&gt; | &lt;span class=&quot;nb&quot;&gt;uniq&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; | &lt;span class=&quot;nb&quot;&gt;sort&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-rn&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;要持续监测文件改动，可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;watch&lt;/code&gt;，例如检查某个文件夹中文件的改变，可以用 &lt;code class=&quot;highlighter-rouge&quot;&gt;watch -d -n 2 'ls -rtlh | tail'&lt;/code&gt;；或者在排查 WiFi 设置故障时要监测网络设置的更改，可以用 &lt;code class=&quot;highlighter-rouge&quot;&gt;watch -d -n 2 ifconfig&lt;/code&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;运行这个函数从这篇文档中随机获取一条技巧（解析 Markdown 文件并抽取项目）：
    &lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;k&quot;&gt;function &lt;/span&gt;taocl&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      curl &lt;span class=&quot;nt&quot;&gt;-s&lt;/span&gt; https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README-zh.md|
        pandoc &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; markdown &lt;span class=&quot;nt&quot;&gt;-t&lt;/span&gt; html |
        iconv &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'utf-8'&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-t&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'unicode'&lt;/span&gt; |
        xmlstarlet fo &lt;span class=&quot;nt&quot;&gt;--html&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--dropdtd&lt;/span&gt; |
        xmlstarlet sel &lt;span class=&quot;nt&quot;&gt;-t&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;(html/body/ul/li[count(p)&amp;gt;0])[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$RANDOM&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; mod last()+1]&quot;&lt;/span&gt; |
        xmlstarlet unesc | &lt;span class=&quot;nb&quot;&gt;fmt&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-80&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;冷门但有用&quot;&gt;冷门但有用&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;expr&lt;/code&gt;：计算表达式或正则匹配&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;m4&lt;/code&gt;：简单的宏处理器&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yes&lt;/code&gt;：多次打印字符串&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cal&lt;/code&gt;：漂亮的日历&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;env&lt;/code&gt;：执行一个命令（脚本文件中很有用）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;printenv&lt;/code&gt;：打印环境变量（调试时或在写脚本文件时很有用）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;look&lt;/code&gt;：查找以特定字符串开头的单词或行&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cut&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;paste&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;join&lt;/code&gt;：数据修改&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;fmt&lt;/code&gt;：格式化文本段落&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;pr&lt;/code&gt;：将文本格式化成页／列形式&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;fold&lt;/code&gt;：包裹文本中的几行&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;column&lt;/code&gt;：将文本格式化成多个对齐、定宽的列或表格&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;expand&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;unexpand&lt;/code&gt;：制表符与空格之间转换&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;nl&lt;/code&gt;：添加行号&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;seq&lt;/code&gt;：打印数字&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;bc&lt;/code&gt;：计算器&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;factor&lt;/code&gt;：分解因数&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://gnupg.org/&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;gpg&lt;/code&gt;&lt;/a&gt;：加密并签名文件&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;toe&lt;/code&gt;：terminfo 入口列表&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;nc&lt;/code&gt;：网络调试及数据传输&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;socat&lt;/code&gt;：套接字代理，与 &lt;code class=&quot;highlighter-rouge&quot;&gt;netcat&lt;/code&gt; 类似&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/mattthias/slurm&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;slurm&lt;/code&gt;&lt;/a&gt;：网络流量可视化&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dd&lt;/code&gt;：文件或设备间传输数据&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;file&lt;/code&gt;：确定文件类型&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;tree&lt;/code&gt;：以树的形式显示路径和文件，类似于递归的 &lt;code class=&quot;highlighter-rouge&quot;&gt;ls&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;stat&lt;/code&gt;：文件信息&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;time&lt;/code&gt;：执行命令，并计算执行时间&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;timeout&lt;/code&gt;：在指定时长范围内执行命令，并在规定时间结束后停止进程&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;lockfile&lt;/code&gt;：使文件只能通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;rm -f&lt;/code&gt; 移除&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;logrotate&lt;/code&gt;： 切换、压缩以及发送日志文件&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;watch&lt;/code&gt;：重复运行同一个命令，展示结果并／或高亮有更改的部分&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/joh/when-changed&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;when-changed&lt;/code&gt;&lt;/a&gt;：当检测到文件更改时执行指定命令。参阅 &lt;code class=&quot;highlighter-rouge&quot;&gt;inotifywait&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;entr&lt;/code&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;tac&lt;/code&gt;：反向输出文件&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;shuf&lt;/code&gt;：文件中随机选取几行&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;comm&lt;/code&gt;：一行一行的比较排序过的文件&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;strings&lt;/code&gt;：从二进制文件中抽取文本&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;tr&lt;/code&gt;：转换字母&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;iconv&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;uconv&lt;/code&gt;：文本编码转换&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;split&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;csplit&lt;/code&gt;：分割文件&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sponge&lt;/code&gt;：在写入前读取所有输入，在读取文件后再向同一文件写入时比较有用，例如 &lt;code class=&quot;highlighter-rouge&quot;&gt;grep -v something some-file | sponge some-file&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;units&lt;/code&gt;：将一种计量单位转换为另一种等效的计量单位（参阅 &lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/share/units/definitions.units&lt;/code&gt;）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;apg&lt;/code&gt;：随机生成密码&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;xz&lt;/code&gt;：高比例的文件压缩&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ldd&lt;/code&gt;：动态库信息&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;nm&lt;/code&gt;：提取 obj 文件中的符号&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ab&lt;/code&gt; 或 &lt;a href=&quot;https://github.com/wg/wrk&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;wrk&lt;/code&gt;&lt;/a&gt;：web 服务器性能分析&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;strace&lt;/code&gt;：调试系统调用&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://www.bitwizard.nl/mtr/&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;mtr&lt;/code&gt;&lt;/a&gt;：更好的网络调试跟踪工具&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cssh&lt;/code&gt;：可视化的并发 shell&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rsync&lt;/code&gt;：通过 ssh 或本地文件系统同步文件和文件夹&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://wireshark.org/&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;wireshark&lt;/code&gt;&lt;/a&gt; 和 &lt;a href=&quot;https://www.wireshark.org/docs/wsug_html_chunked/AppToolstshark.html&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;tshark&lt;/code&gt;&lt;/a&gt;：抓包和网络调试工具&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://ngrep.sourceforge.net/&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ngrep&lt;/code&gt;&lt;/a&gt;：网络层的 grep&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;host&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;dig&lt;/code&gt;：DNS 查找&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;lsof&lt;/code&gt;：列出当前系统打开文件的工具以及查看端口信息&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dstat&lt;/code&gt;：系统状态查看&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/nicolargo/glances&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;glances&lt;/code&gt;&lt;/a&gt;：高层次的多子系统总览&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;iostat&lt;/code&gt;：硬盘使用状态&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;mpstat&lt;/code&gt;： CPU 使用状态&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;vmstat&lt;/code&gt;： 内存使用状态&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;htop&lt;/code&gt;：top 的加强版&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;last&lt;/code&gt;：登入记录&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;w&lt;/code&gt;：查看处于登录状态的用户&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;id&lt;/code&gt;：用户/组 ID 信息&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://sebastien.godard.pagesperso-orange.fr/&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sar&lt;/code&gt;&lt;/a&gt;：系统历史数据&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://www.ex-parrot.com/~pdw/iftop/&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;iftop&lt;/code&gt;&lt;/a&gt; 或 &lt;a href=&quot;https://github.com/raboof/nethogs&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;nethogs&lt;/code&gt;&lt;/a&gt;：套接字及进程的网络利用情况&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ss&lt;/code&gt;：套接字数据&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dmesg&lt;/code&gt;：引导及系统错误信息&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sysctl&lt;/code&gt;： 在内核运行时动态地查看和修改内核的运行参数&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;hdparm&lt;/code&gt;：SATA/ATA 磁盘更改及性能分析&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;lsblk&lt;/code&gt;：列出块设备信息：以树形展示你的磁盘以及磁盘分区信息&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;lshw&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;lscpu&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;lspci&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;lsusb&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;dmidecode&lt;/code&gt;：查看硬件信息，包括 CPU、BIOS、RAID、显卡、USB设备等&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;lsmod&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;modinfo&lt;/code&gt;：列出内核模块，并显示其细节&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;fortune&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;ddate&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;sl&lt;/code&gt;：额，这主要取决于你是否认为蒸汽火车和莫名其妙的名人名言是否“有用”&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;仅限-os-x-系统&quot;&gt;仅限 OS X 系统&lt;/h2&gt;

&lt;p&gt;以下是&lt;em&gt;仅限于&lt;/em&gt; OS X 系统的技巧。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;用 &lt;code class=&quot;highlighter-rouge&quot;&gt;brew&lt;/code&gt; （Homebrew）或者 &lt;code class=&quot;highlighter-rouge&quot;&gt;port&lt;/code&gt; （MacPorts）进行包管理。这些可以用来在 OS X 系统上安装以上的大多数命令。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;用 &lt;code class=&quot;highlighter-rouge&quot;&gt;pbcopy&lt;/code&gt; 复制任何命令的输出到桌面应用，用 &lt;code class=&quot;highlighter-rouge&quot;&gt;pbpaste&lt;/code&gt; 粘贴输入。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;若要在 OS X 终端中将 Option 键视为 alt 键（例如在上面介绍的 &lt;strong&gt;alt-b&lt;/strong&gt;、&lt;strong&gt;alt-f&lt;/strong&gt; 等命令中用到），打开 偏好设置 -&amp;gt; 描述文件 -&amp;gt; 键盘 并勾选“使用 Option 键作为 Meta 键”。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;用 &lt;code class=&quot;highlighter-rouge&quot;&gt;open&lt;/code&gt; 或者 &lt;code class=&quot;highlighter-rouge&quot;&gt;open -a /Applications/Whatever.app&lt;/code&gt; 使用桌面应用打开文件。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Spotlight：用 &lt;code class=&quot;highlighter-rouge&quot;&gt;mdfind&lt;/code&gt; 搜索文件，用 &lt;code class=&quot;highlighter-rouge&quot;&gt;mdls&lt;/code&gt; 列出元数据（例如照片的 EXIF 信息）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;注意 OS X 系统是基于 BSD UNIX 的，许多命令（例如 &lt;code class=&quot;highlighter-rouge&quot;&gt;ps&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;ls&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;tail&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;awk&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;sed&lt;/code&gt;）都和 Linux 中有微妙的不同（ Linux 很大程度上受到了 System V-style Unix 和 GNU 工具影响）。你可以通过标题为 “BSD General Commands Manual” 的 man 页面发现这些不同。在有些情况下 GNU 版本的命令也可能被安装（例如 &lt;code class=&quot;highlighter-rouge&quot;&gt;gawk&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;gsed&lt;/code&gt; 对应 GNU 中的 awk 和 sed ）。如果要写跨平台的 Bash 脚本，避免使用这些命令（例如，考虑 Python 或者 &lt;code class=&quot;highlighter-rouge&quot;&gt;perl&lt;/code&gt; ）或者经过仔细的测试。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;用 &lt;code class=&quot;highlighter-rouge&quot;&gt;sw_vers&lt;/code&gt; 获取 OS X 的版本信息。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;仅限-windows-系统&quot;&gt;仅限 Windows 系统&lt;/h2&gt;

&lt;p&gt;以下是&lt;em&gt;仅限于&lt;/em&gt; Windows 系统的技巧。&lt;/p&gt;

&lt;h3 id=&quot;在-winodws-下获取-unix-工具&quot;&gt;在 Winodws 下获取 Unix 工具&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;可以安装 &lt;a href=&quot;https://cygwin.com/&quot;&gt;Cygwin&lt;/a&gt; 允许你在 Microsoft Windows 中体验 Unix shell 的威力。这样的话，本文中介绍的大多数内容都将适用。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在 Windows 10 上，你可以使用 &lt;a href=&quot;https://msdn.microsoft.com/commandline/wsl/about&quot;&gt;Bash on Ubuntu on Windows&lt;/a&gt;，它提供了一个熟悉的 Bash 环境，包含了不少 Unix 命令行工具。好处是它允许 Linux 上编写的程序在 Windows 上运行，而另一方面，Windows 上编写的程序却无法在 Bash 命令行中运行。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果你在 Windows 上主要想用 GNU 开发者工具（例如 GCC），可以考虑 &lt;a href=&quot;http://www.mingw.org/&quot;&gt;MinGW&lt;/a&gt; 以及它的 &lt;a href=&quot;http://www.mingw.org/wiki/msys&quot;&gt;MSYS&lt;/a&gt; 包，这个包提供了例如 bash，gawk，make 和 grep 的工具。MSYS 并不包含所有可以与 Cygwin 媲美的特性。当制作 Unix 工具的原生 Windows 端口时 MinGW 将特别地有用。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;另一个在 Windows 下实现接近 Unix 环境外观效果的选项是 &lt;a href=&quot;https://github.com/dthree/cash&quot;&gt;Cash&lt;/a&gt;。注意在此环境下只有很少的 Unix 命令和命令行可用。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;实用-windows-命令行工具&quot;&gt;实用 Windows 命令行工具&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;wmic&lt;/code&gt; 在命令行环境下给大部分 Windows 系统管理任务编写脚本以及执行这些任务。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Windows 实用的原生命令行网络工具包括 &lt;code class=&quot;highlighter-rouge&quot;&gt;ping&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;ipconfig&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;tracert&lt;/code&gt;，和 &lt;code class=&quot;highlighter-rouge&quot;&gt;netstat&lt;/code&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;Rundll32&lt;/code&gt; 命令来实现&lt;a href=&quot;http://www.thewindowsclub.com/rundll32-shortcut-commands-windows&quot;&gt;许多有用的 Windows 任务&lt;/a&gt; 。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;cygwin-技巧&quot;&gt;Cygwin 技巧&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;通过 Cygwin 的包管理器来安装额外的 Unix 程序。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;mintty&lt;/code&gt; 作为你的命令行窗口。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;要访问 Windows 剪贴板，可以通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;/dev/clipboard&lt;/code&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;运行 &lt;code class=&quot;highlighter-rouge&quot;&gt;cygstart&lt;/code&gt; 以通过默认程序打开一个文件。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;要访问 Windows 注册表，可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;regtool&lt;/code&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;注意 Windows 驱动器路径 &lt;code class=&quot;highlighter-rouge&quot;&gt;C:\&lt;/code&gt; 在 Cygwin 中用 &lt;code class=&quot;highlighter-rouge&quot;&gt;/cygdrive/c&lt;/code&gt; 代表，而 Cygwin 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;/&lt;/code&gt; 代表 Windows 中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;C:\cygwin&lt;/code&gt;。要转换 Cygwin 和 Windows 风格的路径可以用 &lt;code class=&quot;highlighter-rouge&quot;&gt;cygpath&lt;/code&gt;。这在需要调用 Windows 程序的脚本里很有用。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;学会使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;wmic&lt;/code&gt;，你就可以从命令行执行大多数 Windows 系统管理任务，并编成脚本。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;要在 Windows 下获得 Unix 的界面和体验，另一个办法是使用 &lt;a href=&quot;https://github.com/dthree/cash&quot;&gt;Cash&lt;/a&gt;。需要注意的是，这个环境支持的 Unix 命令和命令行参数非常少。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;要在 Windows 上获取 GNU 开发者工具（比如 GCC）的另一个办法是使用 &lt;a href=&quot;http://www.mingw.org/&quot;&gt;MinGW&lt;/a&gt; 以及它的 &lt;a href=&quot;http://www.mingw.org/wiki/msys&quot;&gt;MSYS&lt;/a&gt; 软件包，该软件包提供了 bash、gawk、make、grep 等工具。然而 MSYS 提供的功能没有 Cygwin 完善。MinGW 在创建 Unix 工具的 Windows 原生移植方面非常有用。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;更多资源&quot;&gt;更多资源&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/alebcay/awesome-shell&quot;&gt;awesome-shell&lt;/a&gt;：一份精心组织的命令行工具及资源的列表。&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/herrbischoff/awesome-osx-command-line&quot;&gt;awesome-osx-command-line&lt;/a&gt;：一份针对 OS X 命令行的更深入的指南。&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://redsymbol.net/articles/unofficial-bash-strict-mode/&quot;&gt;Strict mode&lt;/a&gt;：为了编写更好的脚本文件。&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/koalaman/shellcheck&quot;&gt;shellcheck&lt;/a&gt;：一个静态 shell 脚本分析工具，本质上是 bash／sh／zsh 的 lint。&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.dwheeler.com/essays/filenames-in-shell.html&quot;&gt;Filenames and Pathnames in Shell&lt;/a&gt;：有关如何在 shell 脚本里正确处理文件名的细枝末节。&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://datascienceatthecommandline.com/#tools&quot;&gt;Data Science at the Command Line&lt;/a&gt;：用于数据科学的一些命令和工具，摘自同名书籍。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;免责声明&quot;&gt;免责声明&lt;/h2&gt;

&lt;p&gt;除去特别小的工作，你编写的代码应当方便他人阅读。能力往往伴随着责任，你 &lt;em&gt;有能力&lt;/em&gt; 在 Bash 中玩一些奇技淫巧并不意味着你应该去做！;)&lt;/p&gt;

&lt;h2 id=&quot;授权条款&quot;&gt;授权条款&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://creativecommons.org/licenses/by-sa/4.0/&quot;&gt;&lt;img src=&quot;https://i.creativecommons.org/l/by-sa/4.0/88x31.png&quot; alt=&quot;Creative Commons License&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本文使用授权协议 &lt;a href=&quot;http://creativecommons.org/licenses/by-sa/4.0/&quot;&gt;Creative Commons Attribution-ShareAlike 4.0 International License&lt;/a&gt;。&lt;/p&gt;
</description>
        <pubDate>Tue, 04 Jun 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/06/04/the-art-of-command-line/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/06/04/the-art-of-command-line/</guid>
        
        <category>计算机</category>
        
        <category>转载</category>
        
        
      </item>
    
      <item>
        <title>php-fpm查看状态</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;php-fpm&lt;/code&gt;提供了一种方式，可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;web&lt;/code&gt;来查看自身运行状态。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;配置&quot;&gt;配置&lt;/h3&gt;

&lt;h5 id=&quot;php-fpm&quot;&gt;php-fpm&lt;/h5&gt;

&lt;p&gt;打开&lt;code class=&quot;highlighter-rouge&quot;&gt;php-fpm.conf&lt;/code&gt;文件，打开并设置下面的配置项：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pm.status_path = /status
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;nginx&quot;&gt;nginx&lt;/h5&gt;

&lt;p&gt;设置虚拟主机，并对上面设置的&lt;code class=&quot;highlighter-rouge&quot;&gt;/status&lt;/code&gt;指向&lt;code class=&quot;highlighter-rouge&quot;&gt;php&lt;/code&gt;解析器：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;server {
    listen       80;
    server_name  local.phpfpm.com;
    
    location ~^/status$ {
        fastcgi_pass   127.0.0.1:9000;
        include        fastcgi_params;
        fastcgi_param  SCRIPT_FILENAME $fastcgi_script_name;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;把&lt;code class=&quot;highlighter-rouge&quot;&gt;local.phpfpm.com&lt;/code&gt;添加到&lt;code class=&quot;highlighter-rouge&quot;&gt;host&lt;/code&gt;即可。&lt;/p&gt;

&lt;h3 id=&quot;运行&quot;&gt;运行&lt;/h3&gt;

&lt;h5 id=&quot;实例&quot;&gt;实例&lt;/h5&gt;

&lt;p&gt;我们通过curl来访问&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;curl http://local.phpfpm.com/status
pool:                 www
process manager:      dynamic
start &lt;span class=&quot;nb&quot;&gt;time&lt;/span&gt;:           04/Jun/2019:07:33:50 +0000
start since:          11858
accepted conn:        234
listen queue:         0
max listen queue:     0
listen queue len:     128
idle processes:       4
active processes:     1
total processes:      5
max active processes: 4
max children reached: 0
slow requests:        0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;参数说明&quot;&gt;参数说明&lt;/h5&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;参数&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;pool&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;fpm池子名称，大多数为www&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;process manager&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;进程管理方式,值：static, dynamic or ondemand. dynamic&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;start time&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;启动日期,如果reload了php-fpm，时间会更新&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;start since&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;运行时长&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;accepted conn&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;当前池子接受的请求数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;listen queue&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;请求等待队列&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;max listen queue&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;请求等待队列最高的数量&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;listen queue len&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;socket等待队列长度&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;idle processes&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;空闲进程数量&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;active processes&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;活跃进程数量&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;total processes&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;总进程数量&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;max active processes&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;最大的活跃进程数量（FPM启动开始算）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;max children reached&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;达到进程最大数量限制的次数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;slow requests&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;启用了php-fpm slow-log，缓慢请求的数量&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h5 id=&quot;结果输出&quot;&gt;结果输出&lt;/h5&gt;

&lt;p&gt;可以指定结果的输出格式。&lt;/p&gt;

&lt;p&gt;输出&lt;code class=&quot;highlighter-rouge&quot;&gt;json&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl http://local.phpfpm.com/status?json
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;输出&lt;code class=&quot;highlighter-rouge&quot;&gt;xml&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl http://local.phpfpm.com/status?xml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;输出&lt;code class=&quot;highlighter-rouge&quot;&gt;html&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl http://local.phpfpm.com/status?html
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Tue, 04 Jun 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/06/04/php-fpm-status/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/06/04/php-fpm-status/</guid>
        
        <category>php</category>
        
        
      </item>
    
      <item>
        <title>gitbook制作电子书</title>
        <description>&lt;h3 id=&quot;安装&quot;&gt;安装&lt;/h3&gt;

&lt;p&gt;这里以&lt;code class=&quot;highlighter-rouge&quot;&gt;mac&lt;/code&gt;电脑安装为例。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;GitBook&lt;/code&gt;的安装其实非常简单。最好方法是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;npm&lt;/code&gt;安装。&lt;/p&gt;

&lt;p&gt;首先安装&lt;code class=&quot;highlighter-rouge&quot;&gt;nodejs&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;npm&lt;/code&gt;。&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;brew &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;node
brew &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;npm
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;接下来就可以安装&lt;code class=&quot;highlighter-rouge&quot;&gt;gitbook&lt;/code&gt;了。&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;gitbook-cli &lt;span class=&quot;nt&quot;&gt;-g&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;执行执行&lt;code class=&quot;highlighter-rouge&quot;&gt;gitbook -V&lt;/code&gt;验证：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ gitbook -V
CLI version: 2.3.2
GitBook version: 3.2.3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;到这里安装就完成了。&lt;/p&gt;

&lt;h3 id=&quot;初始化&quot;&gt;初始化&lt;/h3&gt;

&lt;p&gt;进入创建书籍的目录，执行：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gitbook init
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这时会在目录下生成两个文件。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;README.md&lt;/code&gt; 书籍的简介&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SUMMARY.md&lt;/code&gt; 书籍的目录&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;写书&quot;&gt;写书&lt;/h3&gt;

&lt;p&gt;一般&lt;code class=&quot;highlighter-rouge&quot;&gt;GitBook&lt;/code&gt;的目录结构是这样的:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.
├── book.json
├── README.md
├── SUMMARY.md
├── cover.png
├── chapter-1/
|   ├── README.md
|   ├── something1.md
|   └── something2.md
└── chapter-2/
    ├── README.md
    ├── something1.md
    └── something2.md
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;由于初始化只生成了&lt;code class=&quot;highlighter-rouge&quot;&gt;README.md&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;SUMMARY.md&lt;/code&gt;，其他文件和目录需要我们手动创建。&lt;/p&gt;

&lt;h5 id=&quot;bookjson&quot;&gt;book.json&lt;/h5&gt;

&lt;p&gt;这个文件相当于书籍的配置文件，书籍相关的配置包括书名、作者等信息。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;变量&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;root&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;包含所有图书文件的根文件夹的路径，除了&lt;code class=&quot;highlighter-rouge&quot;&gt;book.json&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;structure&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;指定自述，摘要，词汇表等的路径。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;title&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;书的标题，默认值从README中提取。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;description&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;您的图书说明，默认值从自述文件中提取。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;author&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;作者姓名。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;isbn&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;书的国际码ISBN&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;language&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;语言ISO规范的书的语言，默认值是&lt;code class=&quot;highlighter-rouge&quot;&gt;en&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;direction&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;文本的方向。可以是&lt;code class=&quot;highlighter-rouge&quot;&gt;rtl&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;ltr&lt;/code&gt;，默认值取决于&lt;code class=&quot;highlighter-rouge&quot;&gt;language&lt;/code&gt;的值&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;gitbook&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;GitBook&lt;/code&gt;的版本。使用SemVer规范并接受诸如“&amp;gt; = 3.0.0”的条件&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h5 id=&quot;summarymd&quot;&gt;SUMMARY.md&lt;/h5&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SUMMARY.md&lt;/code&gt;定义文档的菜单。&lt;/p&gt;

&lt;p&gt;里面的&lt;code class=&quot;highlighter-rouge&quot;&gt;[]&lt;/code&gt;内的内容是标题，&lt;code class=&quot;highlighter-rouge&quot;&gt;()&lt;/code&gt;内是文档的路径，章节和子章节用四个空格或者tab键来分级。&lt;/p&gt;

&lt;p&gt;示例如下：&lt;/p&gt;

&lt;div class=&quot;language-markdown highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;简介&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;sx&quot;&gt;README.md&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;第一部分&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;sx&quot;&gt;chapter-1/README.md&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;    *&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;Writing很牛&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;sx&quot;&gt;chapter-1/something1.md&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;    *&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;GitBook很牛&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;sx&quot;&gt;chapter-1/something2.md&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;第二部分&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;sx&quot;&gt;chapter-1/README.md&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;    *&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;我们喜欢社交网络&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;sx&quot;&gt;chapter-1/something1.md&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;    *&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;更好的写作工具&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;sx&quot;&gt;chapter-1/something2.md&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;coverpng&quot;&gt;cover.png&lt;/h5&gt;

&lt;p&gt;书籍封面。&lt;/p&gt;

&lt;p&gt;我们可以通过模板快速制作我们的封面。&lt;a href=&quot;https://www.chuangkit.com/sj-pi1-si168-or0-pt0-pn1.html&quot;&gt;工具链接 &amp;gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;通过在线工具生成了我们下面的测试封面。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/img/posts/2019-05-26-gitbook/2.png&quot;&gt;&lt;img src=&quot;/assets/img/posts/2019-05-26-gitbook/2.png&quot; alt=&quot;2.png&quot; title=&quot;查看原图&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;调试&quot;&gt;调试&lt;/h3&gt;

&lt;p&gt;在书籍根目录下运行：&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gitbook serve
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;输出结果：&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;gitbook serve
Live reload server started on port: 35729
Press CTRL+C to quit ...

info: 7 plugins are installed 
info: loading plugin &lt;span class=&quot;s2&quot;&gt;&quot;livereload&quot;&lt;/span&gt;... OK 
info: loading plugin &lt;span class=&quot;s2&quot;&gt;&quot;highlight&quot;&lt;/span&gt;... OK 
info: loading plugin &lt;span class=&quot;s2&quot;&gt;&quot;search&quot;&lt;/span&gt;... OK 
info: loading plugin &lt;span class=&quot;s2&quot;&gt;&quot;lunr&quot;&lt;/span&gt;... OK 
info: loading plugin &lt;span class=&quot;s2&quot;&gt;&quot;sharing&quot;&lt;/span&gt;... OK 
info: loading plugin &lt;span class=&quot;s2&quot;&gt;&quot;fontsettings&quot;&lt;/span&gt;... OK 
info: loading plugin &lt;span class=&quot;s2&quot;&gt;&quot;theme-default&quot;&lt;/span&gt;... OK 
info: found 7 pages 
info: found 1 asset files 
info: &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; generation finished with success &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;0.7s &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt; 

Starting server ...
Serving book on http://localhost:4000
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;现在就可以通过浏览器访问&lt;code class=&quot;highlighter-rouge&quot;&gt;http://localhost:4000&lt;/code&gt;进行浏览。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/img/posts/2019-05-26-gitbook/1.png&quot;&gt;&lt;img src=&quot;/assets/img/posts/2019-05-26-gitbook/1.png&quot; alt=&quot;1.png&quot; title=&quot;查看原图&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;生成书籍&quot;&gt;生成书籍&lt;/h3&gt;

&lt;p&gt;命令语法：&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gitbook &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;文件类型] &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;书籍根目录] &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;生成文件路径/文件名]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;生成pdf文件&quot;&gt;生成PDF文件&lt;/h4&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;gitbook pdf ./ ./mybook.pdf
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;结果截图：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/img/posts/2019-05-26-gitbook/3.png&quot;&gt;&lt;img src=&quot;/assets/img/posts/2019-05-26-gitbook/3.png&quot; alt=&quot;3.png&quot; title=&quot;查看原图&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h5 id=&quot;生成epub文件&quot;&gt;生成ePub文件&lt;/h5&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;gitbook epub ./ ./mybook.epub
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;生成mobi文件&quot;&gt;生成Mobi文件&lt;/h5&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;gitbook mobi ./ ./mybook.mobi
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sun, 26 May 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/05/26/gitbook/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/05/26/gitbook/</guid>
        
        <category>工具</category>
        
        
      </item>
    
      <item>
        <title>「转载」Serverless 架构应用开发指南</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;Serverless 架构是指大量依赖第三方服务（也叫做后端即服务，即“BaaS”）或暂存容器中运行的自定义代码（函数即服务，即“FaaS”）的应用程序，函数是无服务器架构中抽象语言运行时的最小单位。在这种架构中，我们并不看重运行一个函数需要多少 CPU 或 RAM 或任何其他资源，而是更看重运行函数所需的时间，我们也只为这些函数的运行时间付费。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;注意事项&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在本系列的文章中，主要采用了 Serverless Framework 来简化开发和部署流程。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Serverless Framework是无服务器应用框架和生态系统，旨在简化开发和部署AWS Lambda应用程序的工作。Serverless Framework 作为 Node.js NPM 模块提供，填补了AWS Lambda 存在的许多缺口。它提供了多个样本模板，可以迅速启动 AWS Lambda 开发。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;serverless-架构&quot;&gt;Serverless 架构&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;花了 1000G，我终于弄清楚了 Serverless 是什么？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在过去的 24 小时，我通过微信公众号的『电子书』一事，大概处理了 8000 个请求：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/img/posts/2019-05-24-serverless-app-dev-guide/counts.png&quot;&gt;&lt;img src=&quot;/assets/img/posts/2019-05-24-serverless-app-dev-guide/counts.png&quot; alt=&quot;Serverless 请求统计&quot; title=&quot;查看原图&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;大部分的请求都是在 200ms 内完成的，而在最开始的请求潮里（刚发推送的时候，十分钟里近 1500 个请求），平均的响应时间都在 50ms 内。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/img/posts/2019-05-24-serverless-app-dev-guide/times.png&quot;&gt;&lt;img src=&quot;/assets/img/posts/2019-05-24-serverless-app-dev-guide/times.png&quot; alt=&quot;Serverless 请求时间&quot; title=&quot;查看原图&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这也表明了，Serverless 相当的可靠。显然，当请求越多的时候，响应时间越快，这简直有违常理——一般来说，随着请求的增加，响应时间会越来越慢。&lt;/p&gt;

&lt;p&gt;毫无疑问，在最近的几年里，微服务渐渐成为了一个相当流行的架构风格。微服务大致从 2014 年起，开始流行开来，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/img/posts/2019-05-24-serverless-app-dev-guide/microservice-compare-serverless.png&quot;&gt;&lt;img src=&quot;/assets/img/posts/2019-05-24-serverless-app-dev-guide/microservice-compare-serverless.png&quot; alt=&quot;microservices vs serverless&quot; title=&quot;查看原图&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;而 Serverless 是从 2016 年起，开始受到开发者的关注。并且从其发展趋势来看，它大有可能在两年后，拥有今天微服务一样的地位。可见，它是一个相当具有潜力的架构。&lt;/p&gt;

&lt;h2 id=&quot;什么是-serverless-架构&quot;&gt;什么是 Serverless 架构？？&lt;/h2&gt;

&lt;p&gt;为了弄清 Serverless 究竟是什么东西，Serverless 到底是个什么，我使用 Serverless 尝试了一个又一个示例，我自己也做了四五个应用，总算是对 Serverelss 有了一个大致上的认识。&lt;/p&gt;

&lt;h3 id=&quot;虚拟化与隔离&quot;&gt;虚拟化与隔离&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;开发人员为了保证开发环境的正确（即，这个 Bug 不是环境因素造成的），想出了一系列的隔离方式：虚拟机、容器虚拟化、语言虚拟机、应用容器（如 Java 的 Tomcat）、虚拟环境（如 Python 中的 virtualenv），甚至是独立于语言的 DSL。&lt;sup id=&quot;fnref:full_stack&quot;&gt;&lt;a href=&quot;#fn:full_stack&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;从最早的物理服务器开始，我们都在不断地抽象或者虚拟化服务器。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/img/posts/2019-05-24-serverless-app-dev-guide/server-growth.jpg&quot;&gt;&lt;img src=&quot;/assets/img/posts/2019-05-24-serverless-app-dev-guide/server-growth.jpg&quot; alt=&quot;服务器发展&quot; title=&quot;查看原图&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;我们使用 XEN、KVM等虚拟化技术，隔离了硬件以及运行在这之上的操作系统。&lt;/li&gt;
  &lt;li&gt;我们使用云计算进一步地自动管理这些虚拟化的资源。&lt;/li&gt;
  &lt;li&gt;我们使用 Docker 等容器技术，隔离了应用的操作系统与服务器的操作。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;现在，我们有了 Serverless，我们可以隔离操作系统，乃至更底层的技术细节。&lt;/p&gt;

&lt;h3 id=&quot;为什么是花了-1000g-&quot;&gt;为什么是花了 1000G ？&lt;/h3&gt;

&lt;p&gt;现在，让我简单地解释『花了 1000G，我终于弄清楚了 Serverless 是什么？』这句话，来说说 Serverless 到底是什么鬼？&lt;/p&gt;

&lt;p&gt;在实践的过程中，我采用的是 AWS Lambda 作为 Serverless 服务背后的计算引擎。AWS Lambda 是一种函数即服务（Function-as-a-Servcie，FaaS）的计算服务，简单的来说就是：开发人员直接编写运行在云上的函数、功能、服务。由云服务产商提供操作系统、运行环境、网关等一系列的基础环境，我们只需要关注于编写我们的业务代码即可。&lt;/p&gt;

&lt;p&gt;是的，你没听错，我们只需要&lt;strong&gt;考虑怎么用代码提供价值即可&lt;/strong&gt;。我们甚至连可扩展、蓝绿部署等一系列的问题都不用考虑，Amazon 优秀的运营工程师已经帮助我们打造了这一系列的基础设施。并且与传统的 AWS 服务一样，如 Elastic Compute Cloud（EC2），它们都是按流量算钱的。&lt;/p&gt;

&lt;p&gt;那么问题又来了，它到底是怎么对一个函数收钱的。我在 Lambda 函数上运行一个 Hello, world 它会怎么收我的钱呢？&lt;/p&gt;

&lt;p&gt;如果要对一个运行的函数收费，那么想必只有运行时间、CPU、内存占用、硬盘这几个条件。可针对于不同的需求，提供不同的 CPU 是一件很麻烦的事。对于代码来说，一个应用占用的硬盘空间几乎可以忽略不计。当然，这些应用会在你的 S3 上有一个备份。于是，诸如 AWS 采用的是运行时间 + 内存的计算方式。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;内存 (MB)&lt;/th&gt;
      &lt;th&gt;每个月的免费套餐秒数&lt;/th&gt;
      &lt;th&gt;每 100ms 的价格 (USD)&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;128&lt;/td&gt;
      &lt;td&gt;3,200,000&lt;/td&gt;
      &lt;td&gt;0.000000208&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;192&lt;/td&gt;
      &lt;td&gt;2,133,333&lt;/td&gt;
      &lt;td&gt;0.000000313&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;256&lt;/td&gt;
      &lt;td&gt;1,600,000&lt;/td&gt;
      &lt;td&gt;0.000000417&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;…&lt;/td&gt;
      &lt;td&gt;…&lt;/td&gt;
      &lt;td&gt;…&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1024&lt;/td&gt;
      &lt;td&gt;400,000&lt;/td&gt;
      &lt;td&gt;0.000001667&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;…&lt;/td&gt;
      &lt;td&gt;…&lt;/td&gt;
      &lt;td&gt;…&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;在运行程序的时候，AWS 会统计出一个时间和内存，如下所示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;REPORT RequestId: 041138f9-bc81-11e7-aa63-0dbab83f773d	Duration: 2.49 ms	Billed Duration: 100 ms 	Memory Size: 1024 MB	Max Memory Used: 20 MB
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Memory Size&lt;/code&gt; 即是我们选用的套餐类型，Duration 即是运行的时间，Max Memory Used 是我们应用运行时占用的内存。根据我们的 Max Memory Used 数值及应用的计算量，我们可以很轻松地计算出我们所需要的套餐。&lt;/p&gt;

&lt;p&gt;当然，选择不同大小的内存，也意味着选择不同功率的 CPU。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在 AWS Lambda 资源模型中，您可以选择您想为函数分配的内存量，并按 CPU 功率和其他资源的比例进行分配。例如，选择 256MB 的内存分配至您的 Lambda 函数的 CPU 功率约是请求 128MB 内存的两倍，若选择 512MB 的内存，其分配的 CPU 功率约是一半。您可以在 128MB 到 1.5GB 的范围间以 64MB 的增量设置您的内存。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;因此，如果我们选用 1024M 的套餐，然后运行了 320 次，一共算是使用了 320G 的计算量。而其运行时间会被舍入到最近的 100ms，就算我们运行了 2.49ms，那么也是按 100ms 算的。那么假设，我们的 320 次计算都花了 1s，也就是 10×100ms，那么我们要支付的费用是：10×320×0.000001667=0.0053344刀，即使转成人民币也就是不到 4 毛钱的 0.03627392。&lt;/p&gt;

&lt;p&gt;如果我们先用的是 128M 的套餐，那么运行了 2000 次，就是 200G 的计算量了。&lt;/p&gt;

&lt;p&gt;如果我们先用的是 128M 的套餐，那么运行了 8000 次，就是 1000G 的计算量了。&lt;/p&gt;

&lt;p&gt;不过如上表所示，AWS 为 Lambda 提供了一个免费套餐（无期限地提供给新老用户）包含每月 1M 免费请求以及每月 400 000 GB 秒的计算时间。这就意味着，在很长的时间里，我们一分钱都不用花。&lt;/p&gt;

&lt;h3 id=&quot;serverless-是什么&quot;&gt;Serverless 是什么？&lt;/h3&gt;

&lt;p&gt;而从上节的内容中，我们可以知道这么几点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在 Serverless 应用中，开发者只需要专注于业务，剩下的运维等工作都不需要操心&lt;/li&gt;
  &lt;li&gt;Serverless 是&lt;strong&gt;真正的按需使用&lt;/strong&gt;，请求到来时才开始运行&lt;/li&gt;
  &lt;li&gt;Serverless 是按运行时间和内存来算钱的&lt;/li&gt;
  &lt;li&gt;Serverless 应用严重依赖于特定的云平台、第三方服务&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当然这些都是一些虚无缥缈地东西。&lt;/p&gt;

&lt;p&gt;按 AWS 官方对于 Serverless 的介绍是这样的：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;服务器架构是基于互联网的系统，其中应用开发不使用常规的服务进程。相反，它们仅依赖于第三方服务（例如AWS Lambda服务），客户端逻辑和服务托管远程过程调用的组合。”&lt;sup id=&quot;fnref:aws_serverless&quot;&gt;&lt;a href=&quot;#fn:aws_serverless&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在一个基于 AWS 的 Serverless 应用里，应用的组成是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;网关 API Gateway
 来接受和处理成千上万个并发 API 调用，包括流量管理、授权和访问控制、监控等&lt;/li&gt;
  &lt;li&gt;计算服务 Lambda 来进行代码相关的一切计算工作，诸如授权验证、请求、输出等等&lt;/li&gt;
  &lt;li&gt;基础设施管理 CloudFormation 来创建和配置 AWS 基础设施部署，诸如所使用的 S3 存储桶的名称等&lt;/li&gt;
  &lt;li&gt;静态存储 S3 作为前端代码和静态资源存放的地方&lt;/li&gt;
  &lt;li&gt;数据库 DynamoDB 来存储应用的数据&lt;/li&gt;
  &lt;li&gt;等等&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以博客系统为例，当我们访问一篇博客的时候，只是一个 GET 请求，可以由 S3 为我们提供前端的静态资源和响应的 HTML。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/img/posts/2019-05-24-serverless-app-dev-guide/serverless-spa-architecture.png&quot;&gt;&lt;img src=&quot;/assets/img/posts/2019-05-24-serverless-app-dev-guide/serverless-spa-architecture.png&quot; alt=&quot;Serverless SPA 架构&quot; title=&quot;查看原图&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;而当我们创建一个博客的时候：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;我们的请求先来到了 API Gateway，API Gateway 计费器 + 1&lt;/li&gt;
  &lt;li&gt;接着请求来到了 Lambda，进行数据处理，如生成 ID、创建时间等等，Lambda 计费器 + 1&lt;/li&gt;
  &lt;li&gt;Lambda 在计算完后，将数据存储到 DynamoDB 上，DynamoDB 计费器 + 1&lt;/li&gt;
  &lt;li&gt;最后，我们会生成静态的博客到 S3 上，而 S3 只在使用的时候按存储收费。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在这个过程中，我们使用了一系列稳定存在的云服务，并且只在使用时才计费。由于这些服务可以自然、方便地进行调用，我们实际上只需要关注在我们的 Lambda 函数上，以及如何使用这些服务完成整个开发流程。&lt;/p&gt;

&lt;p&gt;因此，Serverless 并不意味着没有服务器，只是服务器以特定功能的第三方服务的形式存在。&lt;/p&gt;

&lt;p&gt;当然并不一定使用这些云服务（如 AWS），才能称为 Serverless。诸如我的同事在 《&lt;a href=&quot;https://blog.jimmylv.info/2017-06-30-serverless-in-action-build-personal-reading-statistics-system/&quot;&gt;Serverless 实战：打造个人阅读追踪系统&lt;/a&gt;》，采用的是：IFTTT + WebTask + GitHub Webhook 的技术栈。它只是意味着，你所有的应用中的一部分服务直接使用的是第三方服务。&lt;/p&gt;

&lt;p&gt;在这种情况下，系统间的分层可能会变成一个又一个的服务。原本，在今天主流的微服务设计里，每一个领域或者子域都是一个服务。而在 Serverless 应用中，这些领域及子域因为他们的功能，又可能会进一步切分成一个又一个 Serverless 函数。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/img/posts/2019-05-24-serverless-app-dev-guide/mono-ms-sls.jpg&quot;&gt;&lt;img src=&quot;/assets/img/posts/2019-05-24-serverless-app-dev-guide/mono-ms-sls.jpg&quot; alt=&quot;更小的函数&quot; title=&quot;查看原图&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;只是这些服务、函数比以往的粒度更加细致。&lt;/p&gt;

&lt;h3 id=&quot;事件驱动编程&quot;&gt;事件驱动编程&lt;/h3&gt;

&lt;p&gt;Serverless 的运行才计算，便意味着他是一种 “严格” 的事件驱动式计算。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;事件驱动编程（英语：Event-driven programming）是一种电脑程序设计模型。这种模型的程序运行流程是由用户的动作（如鼠标的按键，键盘的按键动作）或者是由其他程序的消息来决定的。相对于批处理程序设计（batch programming）而言，程序运行的流程是由程序员来决定。批量的程序设计在初级程序设计教学课程上是一种方式。然而，事件驱动程序设计这种设计模型是在交互程序（Interactive program）的情况下孕育而生的。&lt;sup id=&quot;fnref:wiki_event_driver&quot;&gt;&lt;a href=&quot;#fn:wiki_event_driver&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这也意味着，系统在编程模型上有着巨大的改变。在我们编写 GUI 程序，如桌面程序、Web 前端应用，我们都通过监听用户对按钮、链接等组件操作，才开始相应的处理逻辑。这和 Serverless 是相似的，只在用户使用的时候，才会对应用户的行为进行响应。&lt;/p&gt;

&lt;h2 id=&quot;serverless-的优势&quot;&gt;Serverless 的优势&lt;/h2&gt;

&lt;p&gt;在我使用 Serverless Framework 开发 AWS Serverless 应用的过程中，最方便的莫过于，第一次部署和第二次、第三次部署没有什么区别。只需要执行 &lt;code class=&quot;highlighter-rouge&quot;&gt;serverless deploy&lt;/code&gt;，几分钟后，我们代码就运行在线上。如果是一个传统的 AWS 应用，我需要 SSH 到我的服务器上部署，这样才能写好我的自动部署脚本。除此，我还需要担忧这个过程中，有哪些用户有使用。&lt;/p&gt;

&lt;p&gt;除了，我觉得的部署方便，还有就是价格合理。我的 AWS EC2 实例上运行着我的博客、以及其他的一些网络。然而，我那 PV 只有 500 左右的博客，大部分时间都是在空转。便觉得有些浪费，可是运行才收费的 Serverless 就不会有这样的问题。可以让我大胆地去使用这些服务。当然了，还有其它一些显著的优势。&lt;/p&gt;

&lt;h3 id=&quot;降低启动成本&quot;&gt;降低启动成本&lt;/h3&gt;

&lt;p&gt;当我们作为一家公司开发一个 Web 应用时，在开发的时候，我们需要版本管理服务器、持续集成服务器、测试服务器、应用版本管理仓库等作为基础的服务。线上运行的时候，为了应对大量的请求，我们需要一个好的数据库服务器。当我们的应用面向了普通的用户时，我们需要：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;邮件服务，用于发送提醒、注册等服务&lt;/li&gt;
  &lt;li&gt;短信服务（依国家实名规定），用于注册、登录等用户授权操作&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对于大公司而言，这些都是现成的基础设施。可对于新创企业来说，这都是一些启动成本。&lt;/p&gt;

&lt;h4 id=&quot;减少运营成本&quot;&gt;减少运营成本&lt;/h4&gt;

&lt;p&gt;对于初创公司来说，他们没有基础设施，也没有财力，也可能没有能力去建设基础设施。采用云服务往往是最好的选择，可以节省大量的资金。他们可以将注意力放在：创造对用户有价值的产品上。如果一家创业公司采用云服务，而不是自己搭建服务器。那么，他就会拥有&lt;strong&gt;更多的时间&lt;/strong&gt;开发业务功能，而不是关注在这些。只需要为运行时的软件付钱。&lt;/p&gt;

&lt;p&gt;而采用&lt;strong&gt;函数计算&lt;/strong&gt;的 Serverless 与云服务器最大的不同之处在于：&lt;strong&gt;云服务器需要一直运行，而函数计算是按需计算&lt;/strong&gt;。按需计算就意味着，在请求到来的时候，才运行函数。没有请求的时候，是不算钱的。&lt;/p&gt;

&lt;p&gt;项目初期，其用户数往往是缓慢增长的，而我们在选择服务器的时候，往往会依可能出现的用户来估算。在这个时候，往往会浪费一些不必要的成本。不过，就算用户突然间爆发，Serverless 应用也可以轻松处理。只需要修改一下数据库配置，再重新部署一份。&lt;/p&gt;

&lt;h4 id=&quot;降低开发成本&quot;&gt;降低开发成本&lt;/h4&gt;

&lt;p&gt;一个成功的 Serverless 服务供应商，应该能提供一系列的&lt;strong&gt;配套服务&lt;/strong&gt;。这意味着，你只需要在配置文件上写下，这个数据库的表名，那么我们的数据就会存储到对应的数据库里。甚至于，**如果一个当服务提供者提供一系列的函数计算模板，那么我们只需要写好我们的配置即可。这一系列的东西都可以自动、高效的完成。&lt;/p&gt;

&lt;p&gt;在这种情况下，&lt;strong&gt;使用某一个云服务，就会调用某一个系统自带的 API 一样简单&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;当然，将应用设计成无状态应用，对于早期的系统，可能是一种挑战。除此，诸如 AWS 这样庞大的系统，对于新手程序员来说，也不能容易消化掉的一个系统。&lt;/p&gt;

&lt;h3 id=&quot;实现快速上线&quot;&gt;实现快速上线&lt;/h3&gt;

&lt;p&gt;对于一个 Web 项目来说，启动一个项目需要一系列的 hello, world。当我们在本地搭建环境的时候，是一个 hello, world，当我们将程序部署到开发环境时，也是一个部署相关的 hello, world。虽然看上去有些不同，但是总的来说，都是 it works!。&lt;/p&gt;

&lt;p&gt;Serverless 在部署上的优势，使得你可以轻松地实现上线。&lt;/p&gt;

&lt;h4 id=&quot;更快的部署流水线&quot;&gt;更快的部署流水线&lt;/h4&gt;

&lt;p&gt;实际上，Serverless 应用之所以在部署上有优势，是因为其相当于&lt;strong&gt;内建自动化部署&lt;/strong&gt;——我们在开发应用的时候，已经在不断地增强部署功能。&lt;/p&gt;

&lt;p&gt;在我们日常的开发中，为了实现自动化部署，我们需要先手动部署，以设计出一个相关无错的部署配置，如 Docker 的 Dockerfile，又或者是 Ansible 的 playbook。除此，我们还需要设计好蓝绿发布等等的功能。&lt;/p&gt;

&lt;p&gt;而在函数计算、Serverless 应用里，这些都是由供应商提供的功能。每次我们写完代码，只需要运行一下：&lt;code class=&quot;highlighter-rouge&quot;&gt;sls deploy&lt;/code&gt; 就足够了。在诸如 AWS Lambda 的函数计算里，函数一般在上传后几秒钟内，就能做好调用准备。&lt;/p&gt;

&lt;p&gt;这就意味着，当我们和日常一样，使用一个模板来开发我们的应用。我们就可以在 Clone 完代码后的几分钟内，完成第一次部署。&lt;/p&gt;

&lt;p&gt;唯一的难点，可能是要选用什么配置类型的服务，如选用哪个级别吞吐量的 DynamoDB、哪个内存大小的 Lambda 计算。&lt;/p&gt;

&lt;h4 id=&quot;更快的开发速度&quot;&gt;更快的开发速度&lt;/h4&gt;

&lt;p&gt;由于 Serverless 服务提供者，已经准备好了一系列的基础服务。作为开发人员的我们，只需要关注于如何更好去实现业务，而非技术上的一些限制。&lt;/p&gt;

&lt;p&gt;服务提供者已经向我们准备，并测试好了这一系列的服务。它们基本上是稳定、可靠的，不会遇上特别大的问题。事实上，当我们拥有足够强大的代码，如使用测试来保证健壮性，那么结合持续集成，我们就可以在 PUSH 代码的时候，直接部署到生产环境。当然，可能不需要这么麻烦，我们只需要添加一个 predeploy 的 hook，在这个 hook 里做一些自动测试的工作，就可以在本地直接发布新的版本。&lt;/p&gt;

&lt;p&gt;这个过程里，我们并不需要考虑太多的发布事宜。&lt;/p&gt;

&lt;h3 id=&quot;系统安全性更高&quot;&gt;系统安全性更高&lt;/h3&gt;

&lt;p&gt;依我维护我博客的经验来看，要保持服务器一直运行不是一件容易的事。在不经意的时候，总会发现有 Cracker 在攻击你网站。我们需要防范不同类型的攻击，如在我的服务器里一直有黑客在尝试密码登录，可是我的博客的服务器是要密钥才能登录的。在一次神奇的尝试登录攻击后，我的 SSH 守护进程崩溃了。这意味着，我只能从 EC2 后台重启服务器。&lt;/p&gt;

&lt;p&gt;有了 Serverless，我不再需要担心有人尝试登录系统，因为我都不知道怎么登录服务器。&lt;/p&gt;

&lt;p&gt;我不再需要考虑系统底层安全问题，每次登录 AWS EC2，我总需要更新一遍软件；每当我看到某个软件有漏洞时，如之前的 OpenSSH，我就登录上去看一下版本，更新一下软件。真 TM 费时又费力，还没有一点好处。&lt;/p&gt;

&lt;p&gt;唯一需要担心的，可能是有人发起 DDOS 攻击。而根据&lt;a href=&quot;https://thenewstack.io/zombie-toasters-eat-startup/&quot;&gt;Could Zombie Toasters DDoS My Serverless Deployment?&lt;/a&gt;的计算，每百万的请求，大概是 0.2 刀，每小时 360000000 个请求，也就 72 刀。&lt;/p&gt;

&lt;h3 id=&quot;适应微服务架构&quot;&gt;适应微服务架构&lt;/h3&gt;

&lt;p&gt;如我们所见在最近几年里看到的那样，微服务并不没有大量地替换掉单体应用——毕竟使用新的架构来替换旧的系统，在业务上的价值并不大。因此，对于很多企业来说，并没有这样的强烈需求及紧迫性。活着，才是一件更紧迫的事。&lt;/p&gt;

&lt;p&gt;而 Serverless 天生就与微服务架构是&lt;strong&gt;相辅相成&lt;/strong&gt;的。一个 Serverless 应用拥有自己的网关、数据库、接口，你可还以使用自己喜欢的语言（受限于服务提供者）来开发服务。换句话来说，在这种情形下，一个 Serverless 可能是一个完美的微服务实例。&lt;/p&gt;

&lt;p&gt;在可见的一二年里，Serverless 将替换到某些系统中的一些组件、服务。&lt;/p&gt;

&lt;h3 id=&quot;自动扩展能力&quot;&gt;自动扩展能力&lt;/h3&gt;

&lt;p&gt;Serverless 的背后是 诸如 AWS Lambda 这样的 FaaS（Function as a Services）。&lt;/p&gt;

&lt;p&gt;对于传统应用来说，要应对更多的请求的方式，就是部署更多的实例。然而，这个时候往往已经来不及了。而对于 FaaS 来说，我们并不需要这么做，FaaS 会自动的扩展。它可以在需要时尽可能多地启动实例副本，而不会发生冗长的部署和配置延迟。&lt;/p&gt;

&lt;p&gt;这依赖于我们的服务是无状态的，我们才能次无忌惮地不断运行起新的实例。&lt;/p&gt;

&lt;h2 id=&quot;serverless-的问题&quot;&gt;Serverless 的问题&lt;/h2&gt;

&lt;p&gt;作为一个运行时，才启动的应用来说，Serverless 也存在着一个个我们所需要的问题。&lt;/p&gt;

&lt;h3 id=&quot;不适合长时间运行应用&quot;&gt;不适合长时间运行应用&lt;/h3&gt;

&lt;p&gt;Serverless 在请求到来时才运行。这意味着，当应用不运行的时候就会进入 “休眠状态”，下次当请求来临时，应用将会需要一个启动时间，即&lt;strong&gt;冷启动&lt;/strong&gt;。这个时候，可以结合 CRON 的方式或者 CloudWatch 来定期唤醒应用。&lt;/p&gt;

&lt;p&gt;如果你的应用需要一直长期不间断的运行、处理大量的请求，那么你可能就不适合采用 Serverless 架构。在这种情况下，采用 EC2 这样的云服务器往往是一种更好的选择。因为 EC2 从价格上来说，更加便宜。&lt;/p&gt;

&lt;p&gt;引用 &lt;a href=&quot;https://www.zhihu.com/people/lu-zou-36&quot;&gt;Lu Zou&lt;/a&gt; 在 《&lt;a href=&quot;https://zhuanlan.zhihu.com/p/31122433&quot;&gt;花了 1000G，我终于弄清楚了 Serverless 是什么（上）：什么是 Serverless 架构？&lt;/a&gt;》上的评论：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;EC2 相当于你买了一辆车，而 Lambda 相当于你租了你一辆车。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;长期租车的成本肯定比买车贵，但是你就少掉了一部分的维护成本。因此，这个问题实际上是一个值得深入计算的问题。&lt;/p&gt;

&lt;h3 id=&quot;完全依赖于第三方服务&quot;&gt;完全依赖于第三方服务&lt;/h3&gt;

&lt;p&gt;是的，当你决定使用某个云服务的时候，也就意味着你可能走了一条不归路。在这种情况下，只能将不重要的 API 放在 Serverless 上。&lt;/p&gt;

&lt;p&gt;当你已经有大量的基础设施的时候，Serverless 对于你来说，并不是一个好东西。当我们采用 Serverless 架构的时候，我们就和特别的服务供应商绑定了。我们使用了 AWS 家的服务，那么我们再将服务迁到 Google Cloud 上就没有那么容易了。&lt;/p&gt;

&lt;p&gt;我们需要修改一下系列的底层代码，能采取的应对方案，便是建立隔离层。这意味着，在设计应用的时候，就需要：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;隔离 API 网关&lt;/li&gt;
  &lt;li&gt;隔离数据库层，考虑到市面上还没有成熟的 ORM 工具，让你即支持 Firebase，又支持 DynamoDB&lt;/li&gt;
  &lt;li&gt;等等&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这些也将带给我们一些额外的成本，可能&lt;strong&gt;带来的问题会比解决的问题多&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;冷启动时间&quot;&gt;冷启动时间&lt;/h3&gt;

&lt;p&gt;如上所说，Serverless 应用存在一个冷启动时间的问题。&lt;/p&gt;

&lt;p&gt;据 New Relic 官方博客《&lt;a href=&quot;https://blog.newrelic.com/2017/01/11/aws-lambda-cold-start-optimization/&quot;&gt;Understanding AWS Lambda Performance—How Much Do Cold Starts Really Matter?&lt;/a&gt;》称，AWS Lambda 的冷启动时间。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./images/aws-lambda-monitoring-functions-chart.png&quot; alt=&quot;AWS 启动时间&quot; /&gt;&lt;/p&gt;

&lt;p&gt;又或者是我之前统计的请求响应时间：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/img/posts/2019-05-24-serverless-app-dev-guide/times.png&quot;&gt;&lt;img src=&quot;/assets/img/posts/2019-05-24-serverless-app-dev-guide/times.png&quot; alt=&quot;Serverless 请求时间&quot; title=&quot;查看原图&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;尽管这个冷启动时间大部分情况下，可以在 50ms 以内。而这是对于 Node.js 应用来说，对于拥有虚拟机的 Java 和 C# 可能就没有那么幸运了。&lt;/p&gt;

&lt;h3 id=&quot;缺乏调试和开发工具&quot;&gt;缺乏调试和开发工具&lt;/h3&gt;

&lt;p&gt;当我使用 Serverless Framework 的时候，遇到了这样的问题：缺乏调试和开发工具。后来，我发现了 serverless-offline、dynamodb-local 等一系列插件之后，问题有一些改善。&lt;/p&gt;

&lt;p&gt;然而，对于日志系统来说，这仍然是一个艰巨的挑战。&lt;/p&gt;

&lt;p&gt;每次你调试的时候，你需要一遍又一遍地上传代码。而每次上传的时候，你就好像是在部署服务器。然后 Fuck 了，我并不能总是快速地定位出问题在哪。于是，我修改了一下代码，添加了一行 &lt;code class=&quot;highlighter-rouge&quot;&gt;console.log&lt;/code&gt;，然后又一次地部署了下代码。问题解决了，挺好的，我删了一下 &lt;code class=&quot;highlighter-rouge&quot;&gt;console.log&lt;/code&gt;，然后又一次地部署了下代码。&lt;/p&gt;

&lt;p&gt;后来，我学乖了，找了一个类似于 log4j 这样的可以分级别纪录日志的 Node.js 库 &lt;code class=&quot;highlighter-rouge&quot;&gt;winston&lt;/code&gt;。它可以支持 error、warn、info、verbose、debug、silly 六个不同级别的日志。&lt;/p&gt;

&lt;h3 id=&quot;构建复杂&quot;&gt;构建复杂&lt;/h3&gt;

&lt;p&gt;Serverless 很便宜，但是这并不意味着它很简单。&lt;/p&gt;

&lt;p&gt;早先，在知道 AWS Lambda 之后，我本来想进行一些尝试。但是 CloudForamtion 让我觉得太难了，它的配置是如此的复杂，并且难以阅读及编写（JSON 格式）。&lt;/p&gt;

&lt;p&gt;考虑到 CloudForamtion 的复杂度，我是在接触了 Serverless Framework 之后，才重新燃起了一些信心。&lt;/p&gt;

&lt;p&gt;Serverless Framework 的配置更加简单，采用的是 YAML 格式。在部署的时候，Serverless Framework 会根据我们的配置生成 CloudForamtion 配置。&lt;/p&gt;

&lt;p&gt;在那篇《&lt;a href=&quot;https://www.phodal.com/blog/serverless-development-guide-use-kinesis-firehose-stream-data-s3/&quot;&gt;Kinesis Firehose 持久化数据到 S3&lt;/a&gt;》想着的数据统计文章里，我们介绍了 Serverless 框架的配置。与一般的 Lambda 配置来说，这里的配置就稍微复杂一些。然而，这也并非是一个真正用于生产的配置。我的意思是，真实的应用场景远远比这复杂。&lt;/p&gt;

&lt;h3 id=&quot;语言版本落后&quot;&gt;语言版本落后&lt;/h3&gt;

&lt;p&gt;在 Node.js 6 出来的时候，AWS Lambda 只支持 Node.js 4.3.2；在 Node.js 9.0 出来的时候，AWS Lambda 支持到 6.10.3。&lt;/p&gt;

&lt;p&gt;如下是 AWS Lambda 支持以下运行时版本：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Node.js – v4.3.2 和 6.10.3&lt;/li&gt;
  &lt;li&gt;Java - Java 8&lt;/li&gt;
  &lt;li&gt;Python – Python 3.6 和 2.7&lt;/li&gt;
  &lt;li&gt;.NET 内核 – .NET 内核 1.0.1 (C#)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对于 Java 和 Python 来说，他们的版本上可能基本都是够用的，我不知道 C# 怎么样。但是 Node.js 的版本显然是有点老旧的，但是都 Node.js 9.2.0 了。不过，话说来说，这可能与版本帝 Chrome 带来的前端版本潮有一点关系。&lt;/p&gt;

&lt;h2 id=&quot;serverless-的适用场景&quot;&gt;Serverless 的适用场景&lt;/h2&gt;

&lt;p&gt;尽管 Serverless 在编写传统的 Web 应用上，有一定的缺点。然而，它的事件驱动及运行时计算，使得它在某些场景上相当的合适。&lt;/p&gt;

&lt;h3 id=&quot;发送通知&quot;&gt;发送通知&lt;/h3&gt;

&lt;p&gt;由我们在上一节中提到的，对于诸如 PUSH Notification、&lt;a href=&quot;https://www.phodal.com/blog/serverless-development-guide-aws-simple-email-service/&quot;&gt;邮件通知接口&lt;/a&gt;、短信，这一类服务来说，他们都需要基础设施来搭建。并且，他们对实时性的要求相对没有那么高。&lt;/p&gt;

&lt;p&gt;即使在时间上晚来几秒钟，用户还是能接受的。在我们所见到的短信发送的例子里，一般都会假设用户能在 60 秒内收到短信。因此，在这种时间 1s 的误差，用户也不会恼火的。而对于 APP 的消息推送而言，这种要求就更低了，用户反而不太希望能收到这样的推送&lt;/p&gt;

&lt;h3 id=&quot;webhook&quot;&gt;WebHook&lt;/h3&gt;

&lt;p&gt;当我们没有服务器，又想要一个 Webhook 来触发我们一系列的操作的时候。我们就可以考虑使用 Serverless，我们不需要一直就这么支付一个服务器的费用。通过 Serverless，我们就可以轻松完成这样的工作，并且节省大量的费用。&lt;/p&gt;

&lt;p&gt;一个比较明显的例子，就如 &lt;a href=&quot;https://www.phodal.com/blog/serverless-development-guide-create-github-hooks/&quot;&gt;GitHub Hooks&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;GitHub 上的 Webhook 允许我们构建或设置在 GitHub.com 上订阅某些事件的 GitHub 应用程序。当触发这些事件之一时，我们将向 webhook 配置的 URL 发送 HTTP POST 有效内容。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;比如说，当我们 PUSH 了代码，我们想触发我们的持续集成。这个时候，就可以通过一个 Webhook 来做这样的事情。&lt;/p&gt;

&lt;h3 id=&quot;轻量级-api&quot;&gt;轻量级 API&lt;/h3&gt;

&lt;p&gt;Serverless 特别适合于，轻量级快速变化地 API。&lt;/p&gt;

&lt;p&gt;其实，我一直没有想到一个合适的例子。在我的假想里，一个 AutoSuggest 的 API 可能就是这样的 API，但是这种 API 在有些时候，往往会伴随着相当复杂的业务。&lt;/p&gt;

&lt;p&gt;于是，便想举一个 Featrue Toggle 的例子，尽管有一些不合适。但是，可能是最有价值的部分。&lt;/p&gt;

&lt;h3 id=&quot;物联网&quot;&gt;物联网&lt;/h3&gt;

&lt;p&gt;当我们谈及物联网的时候，我们会讨论事件触发、传输协议、海量数据（数据存储、数据分析）。而有了 Serverless，那么再多的数据，处理起来也是相当容易的一件事。&lt;/p&gt;

&lt;p&gt;对于一个物联网应用的服务端来说，系统需要收集来自各个地方的数据，并创建一个个 pipeline 来处理、过滤、转换这些数据，并将数据存储到数据库中。&lt;/p&gt;

&lt;p&gt;对于硬件开发人员来说，对接不同的硬件，本身就是一种挑战。而直接使用诸如 AWS IoT 这样国，可以在某种程度上，帮助我们更好地开发出写服务端连接的应用。&lt;/p&gt;

&lt;p&gt;同时，对于物联网应用的客户端来说，则需要从数据库抽取数据进行展示。这部分，可能算不上是一个挑战点。&lt;/p&gt;

&lt;h3 id=&quot;数据统计分析&quot;&gt;数据统计分析&lt;/h3&gt;

&lt;p&gt;数据统计本身只需要很少的计算量，但是生成图表，则可以定期生成。&lt;/p&gt;

&lt;p&gt;在接收数据的时候，我们不需要考虑任何延时带来的问题。50~200 ms 的延时，并不会对我们的系统造成什么影响。&lt;/p&gt;

&lt;h3 id=&quot;trigger-及定时任务&quot;&gt;Trigger 及定时任务&lt;/h3&gt;

&lt;p&gt;对于哪些需要爬虫来抓取和生成的程序来说，Serverless &lt;strong&gt;可能&lt;/strong&gt;是一个不错的舞台。&lt;/p&gt;

&lt;p&gt;尽管，这样的工作也可以由云服务器来做，我们只需要定时的启动一下服务器。通过服务器中的自启动脚本来做相应的事，但是当我们完成了一系列的工作之后。我们需要将数据存储在一个远程的服务器上。而为了让系统中的其它应用，也能直接访问这些数据。那么，我们可能会考虑使用一个云数据库。这个时候，Serverless 应用看上去更具有吸引力。&lt;/p&gt;

&lt;p&gt;在那篇《CRON 定时执行 Lambda 任务》中，我们也可以看到 AWS Lambda 可以支持 Lambda 计算，定时启动服务，并计算。&lt;/p&gt;

&lt;h3 id=&quot;精益创业&quot;&gt;精益创业&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;/assets/img/posts/2019-05-24-serverless-app-dev-guide/launch-page.jpg&quot;&gt;&lt;img src=&quot;/assets/img/posts/2019-05-24-serverless-app-dev-guide/launch-page.jpg&quot; alt=&quot;Landing Page&quot; title=&quot;查看原图&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Serverless 的快速上线、开发，意味着它可以快速验证一个想法 MVP。如 Dropbox 在开始的时候，只创造了一个 Landing Page。作为一个想使用这个服务的用户，我们会在其中填上我们的邮箱。&lt;/p&gt;

&lt;p&gt;而如果是使用 Serverless 来构建这样的应用，那么我们只需要创建一个静态页面，然后用一个 Serverless 服务来保存用户的邮箱到数据库中，如我在 GitHub 上的 &lt;a href=&quot;https://github.com/phodal/serverless-landingpage&quot;&gt;serverless-landingpage&lt;/a&gt; 所做的那样。&lt;/p&gt;

&lt;h3 id=&quot;chat-机器人&quot;&gt;Chat 机器人&lt;/h3&gt;

&lt;p&gt;聊天机器人，也是一个相当好的应用场景。&lt;/p&gt;

&lt;p&gt;But，由于国内的条件限制（信息监管），这并不是一件容易的事。因此，从渠道（如微信、blabla）上，都在尽可能地降低这方面的可能性。&lt;/p&gt;

&lt;p&gt;但是，我们还可以做一个微信公众号的服务。当用户输入一个关键词时，做出相应的回复，这实质上和聊天机器人是差不多的。只需要结合《&lt;a href=&quot;https://www.phodal.com/blog/serverless-development-guide-serverless-lambda-wechat-public-platform/&quot;&gt;基于 Serverless 与 Lambda 的微信公共平台&lt;/a&gt;》 就可以轻松实现，并实现快速上线。&lt;/p&gt;

&lt;h2 id=&quot;其它&quot;&gt;其它&lt;/h2&gt;

&lt;h3 id=&quot;迁移方案&quot;&gt;迁移方案&lt;/h3&gt;

&lt;p&gt;Express 应用示例&lt;/p&gt;

&lt;h3 id=&quot;serverless-framework&quot;&gt;Serverless Framework&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Serverless Framework是无服务器应用框架和生态系统，旨在简化开发和部署AWS Lambda应用程序的工作。Serverless Framework 作为 Node.js NPM 模块提供，填补了AWS Lambda 存在的许多缺口。它提供了多个样本模板，可以迅速启动 AWS Lambda 开发。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;apex&quot;&gt;Apex&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Apex可以轻松地构建、部署和管理AWS Lambda功能。通过节点可使用由AWS Lambda(如Golang)所不支持的语言，js shim注入到构建中，为测试功能、回滚部署、查看度量、跟踪日志、连接到构建系统以及更多的功能提供了各种工作流相关工具。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;apache-openwhisk&quot;&gt;Apache OpenWhisk&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;OpenWhisk是一个分布式的、事件驱动的计算服务。OpenWhisk运行应用程序逻辑，以应对事件或直接通过HTTP调用网络或移动应用。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;serverless-的-hello-world&quot;&gt;Serverless 的 hello, world&lt;/h1&gt;

&lt;p&gt;原文链接：&lt;a href=&quot;https://www.phodal.com/blog/serverless-development-guid-serverless-framework-hello-world/&quot;&gt;Serverless 应用开发指南：serverless 的 hello, world&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在翻译了几篇 serverless 与物联网相关的文章之后，我开始想着好好掌握一下 serverless 的相关知识。&lt;/p&gt;

&lt;p&gt;我对于 serverless 的第一认知是：&lt;strong&gt;Serverless 是由一堆云服务构建后端服务的，如存储、计算、授权都是由不同的服务来构建的。&lt;/strong&gt;而作为一个开发人员，我们所要做的就是了解如何搭配不同的云服务。&lt;/p&gt;

&lt;p&gt;因此，在进行更多的定义之前，我打算先熟悉一下 serverless，以便于我更好地了解什么是 serverless 应用开发。&lt;/p&gt;

&lt;h2 id=&quot;serverless-框架-hello-world&quot;&gt;Serverless 框架 hello, world&lt;/h2&gt;

&lt;p&gt;考虑到直接使用 aws lambda 编写 serverless，对于我这样的新手相当的有挑战性。于是，我便先选择了 Serverless 框架，GitHub: https://github.com/serverless/serverless。&lt;/p&gt;

&lt;p&gt;先让我们按官网的 demo，进行实验。开始之前，除了拥有一台电脑，你还需要有一个 AWS 账号。AWS 提供一年的免费试用，你所需要做的就是办一张支持 visa 的信用卡。&lt;/p&gt;

&lt;h3 id=&quot;一安装--serverless-框架&quot;&gt;一、安装  serverless 框架&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm install -g serverless
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;或者，和我一样使用：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yarn global add serverless
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;二设置-aws-凭证&quot;&gt;二、设置 aws 凭证。&lt;/h3&gt;

&lt;p&gt;1.登录 AWS 账号，然后点击进入 IAM  (即，Identity &amp;amp; Access Management)。&lt;/p&gt;

&lt;p&gt;2.点击用户，然后添加用户，如 serveless-admin，并在『选择 AWS 访问类型』里，勾上&lt;strong&gt;编程访问&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/img/posts/2019-05-24-serverless-app-dev-guide/enable-programming.png&quot;&gt;&lt;img src=&quot;/assets/img/posts/2019-05-24-serverless-app-dev-guide/enable-programming.png&quot; alt=&quot;编程访问 serverless&quot; title=&quot;查看原图&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;3.点击&lt;strong&gt;下一步权限&lt;/strong&gt;，选择『直接附加现有策略』，输入&lt;strong&gt;AdministratorAccess&lt;/strong&gt;，然后创建用户。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;注意&lt;/code&gt;：由于是 &lt;strong&gt;AdministratorAccess&lt;/strong&gt; 权限，所以不要泄漏你的密钥出去。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;创建用户。随后，会生成&lt;strong&gt;访问密钥 ID&lt;/strong&gt; 和 &lt;strong&gt;私有访问密钥&lt;/strong&gt;。请妥善保存好。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;然后导出证书，并使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;serverless depoy&lt;/code&gt; 保存到本地。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;export AWS_ACCESS_KEY_ID=&amp;lt;your-key-here&amp;gt;
export AWS_SECRET_ACCESS_KEY=&amp;lt;your-secret-key-here&amp;gt;

serverless deploy
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;将会自动生成配置到 ~/.aws/credentials&lt;/p&gt;

&lt;p&gt;或者，如官方的示例：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;serverless config credentials --provider aws --key AKIAIOSFODNN7EXAMPLE --secret wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;三创建-hello-world-服务&quot;&gt;三、创建 hello-world 服务&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;serverless create --template aws-nodejs --path hello-world
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Serverless: Generating boilerplate...
Serverless: Generating boilerplate in &quot;/Users/fdhuang/learing/serverless-guide/hello-world&quot;
 _______                             __
|   _   .-----.----.--.--.-----.----|  .-----.-----.-----.
|   |___|  -__|   _|  |  |  -__|   _|  |  -__|__ --|__ --|
|____   |_____|__|  \___/|_____|__| |__|_____|_____|_____|
|   |   |             The Serverless Application Framework
|       |                           serverless.com, v1.23.0
 -------'

Serverless: Successfully generated boilerplate for template: &quot;aws-nodejs&quot;
(play-env)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;生成两个文件；&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;├── handler.js
└── serverless.yml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中的 handler.js 的内容是：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;'use strict';

module.exports.hello = (event, context, callback) =&amp;gt; {
  const response = {
    statusCode: 200,
    body: JSON.stringify({
      message: 'Go Serverless v1.0! Your function executed successfully!',
      input: event,
    }),
  };

  callback(null, response);

  // Use this code if you don't use the http event with the LAMBDA-PROXY integration
  // callback(null, { message: 'Go Serverless v1.0! Your function executed successfully!', event });
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;而 &lt;code class=&quot;highlighter-rouge&quot;&gt;serverless.yml&lt;/code&gt; 的内容，因为注释所有的内容，因此相当于是空的。&lt;/p&gt;

&lt;h3 id=&quot;四部署及测试&quot;&gt;四、部署及测试：&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$serverless deploy -v
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;日志如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Serverless: Packaging service...
Serverless: Excluding development dependencies...
Serverless: Uploading CloudFormation file to S3...
Serverless: Uploading artifacts...
Serverless: Uploading service .zip file to S3 (409 B)...
Serverless: Validating template...
Serverless: Updating Stack...
Serverless: Checking Stack update progress...
CloudFormation - UPDATE_IN_PROGRESS - AWS::CloudFormation::Stack - hello-world-dev
CloudFormation - CREATE_IN_PROGRESS - AWS::Logs::LogGroup - HelloLogGroup
CloudFormation - CREATE_IN_PROGRESS - AWS::IAM::Role - IamRoleLambdaExecution
CloudFormation - CREATE_IN_PROGRESS - AWS::Logs::LogGroup - HelloLogGroup
CloudFormation - CREATE_IN_PROGRESS - AWS::IAM::Role - IamRoleLambdaExecution
CloudFormation - CREATE_COMPLETE - AWS::Logs::LogGroup - HelloLogGroup
CloudFormation - CREATE_COMPLETE - AWS::IAM::Role - IamRoleLambdaExecution
CloudFormation - CREATE_IN_PROGRESS - AWS::Lambda::Function - HelloLambdaFunction
CloudFormation - CREATE_IN_PROGRESS - AWS::Lambda::Function - HelloLambdaFunction
CloudFormation - CREATE_COMPLETE - AWS::Lambda::Function - HelloLambdaFunction
CloudFormation - CREATE_IN_PROGRESS - AWS::Lambda::Version - HelloLambdaVersionPSzzisjnTvvYknuXwQOlAvdkQZ67qXYSvgoAi9T8W0
CloudFormation - CREATE_IN_PROGRESS - AWS::Lambda::Version - HelloLambdaVersionPSzzisjnTvvYknuXwQOlAvdkQZ67qXYSvgoAi9T8W0
CloudFormation - CREATE_COMPLETE - AWS::Lambda::Version - HelloLambdaVersionPSzzisjnTvvYknuXwQOlAvdkQZ67qXYSvgoAi9T8W0
CloudFormation - UPDATE_COMPLETE_CLEANUP_IN_PROGRESS - AWS::CloudFormation::Stack - hello-world-dev
CloudFormation - UPDATE_COMPLETE - AWS::CloudFormation::Stack - hello-world-dev
Serverless: Stack update finished...
Service Information
service: hello-world
stage: dev
region: us-east-1
stack: hello-world-dev
api keys:
  None
endpoints:
  None
functions:
  hello: hello-world-dev-hello

Stack Outputs
HelloLambdaFunctionQualifiedArn: arn:aws:lambda:us-east-1:706605665335:function:hello-world-dev-hello:1
ServerlessDeploymentBucketName: hello-world-dev-serverlessdeploymentbucket-bk066p5c9zgl
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后，让我们来触发一下这个函数：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ serverless invoke -f hello -l
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;服务器返回了下面的结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{
    &quot;statusCode&quot;: 200,
    &quot;body&quot;: &quot;{\&quot;message\&quot;:\&quot;Go Serverless v1.0! Your function executed successfully!\&quot;,\&quot;input\&quot;:{}}&quot;
}
--------------------------------------------------------------------
START RequestId: 041138f9-bc81-11e7-aa63-0dbab83f773d Version: $LATEST
END RequestId: 041138f9-bc81-11e7-aa63-0dbab83f773d
REPORT RequestId: 041138f9-bc81-11e7-aa63-0dbab83f773d	Duration: 2.49 ms	Billed Duration: 100 ms 	Memory Size: 1024 MB	Max Memory Used: 20 MB
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这意味着，我们的第一个服务已经成功上线了。&lt;/p&gt;

&lt;p&gt;我们也可以通过下面的命令来获取相应的日志：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;serverless logs -f hello -t
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;aws-lambda-动态编程返回-html&quot;&gt;AWS Lambda 动态编程返回 HTML&lt;/h1&gt;

&lt;p&gt;原文链接：&lt;a href=&quot;https://www.phodal.com/blog/serverless-development-guide-nodejs-create-dymamic-html/&quot;&gt;Serverless 应用开发指南： Node.js 编程返回动态 HTML&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在我们进行 Serverless + SPA 应用开发之前，先看看官方的相应 DEMO。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;serverless install -u https://github.com/serverless/examples/tree/master/aws-node-serve-dynamic-html-via-http-endpoint -n node-serve-html
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后执行部署&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;serverless deploy
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;serverless.yml&lt;/code&gt; 文件，如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;service: node-serve-html

provider:
  name: aws
  runtime: nodejs4.3

functions:
  landingPage:
    handler: handler.landingPage
    events:
      - http:
          method: get
          path: landing-page
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;对应的，我们的 &lt;code class=&quot;highlighter-rouge&quot;&gt;handler.js&lt;/code&gt; 文件：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;'use strict';

module.exports.landingPage = (event, context, callback) =&amp;gt; {
  let dynamicHtml = '&lt;span class=&quot;nt&quot;&gt;&amp;lt;p&amp;gt;&lt;/span&gt;Hey Unknown!&lt;span class=&quot;nt&quot;&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;';
  // check for GET params and use if available
  if (event.queryStringParameters &lt;span class=&quot;err&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; event.queryStringParameters.name) {
    dynamicHtml = `&lt;span class=&quot;nt&quot;&gt;&amp;lt;p&amp;gt;&lt;/span&gt;Hey ${event.queryStringParameters.name}!&lt;span class=&quot;nt&quot;&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;`;
  }

  const html = `
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;html&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;style&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;h1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;#73757d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/style&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;h1&amp;gt;&lt;/span&gt;Landing Page&lt;span class=&quot;nt&quot;&gt;&amp;lt;/h1&amp;gt;&lt;/span&gt;
      ${dynamicHtml}
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;`;

  const response = {
    statusCode: 200,
    headers: {
      'Content-Type': 'text/html',
    },
    body: html,
  };

  // callback is sending HTML back
  callback(null, response);
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面的代码所做的就是，当我们对 &lt;code class=&quot;highlighter-rouge&quot;&gt;landing-page&lt;/code&gt; 发出请求的时候，便执行上面的 &lt;code class=&quot;highlighter-rouge&quot;&gt;landingPage&lt;/code&gt; 代码。然后返回对应的 HTML body、statusCode、headers。&lt;/p&gt;

&lt;p&gt;相应的部署日志如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;..............................
Serverless: Stack update finished...
Service Information
service: node-serve-html
stage: dev
region: us-east-1
stack: node-serve-html-dev
api keys:
  None
endpoints:
  GET - https://uocym5fe3m.execute-api.us-east-1.amazonaws.com/dev/landing-page
functions:
  landingPage: node-serve-html-dev-landingPage
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后我们访问：&lt;a href=&quot;https://uocym5fe3m.execute-api.us-east-1.amazonaws.com/dev/landing-page?name=phodal&quot;&gt;https://uocym5fe3m.execute-api.us-east-1.amazonaws.com/dev/landing-page&lt;/a&gt;，就会返回对应的 HTML，即：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Landing Page

Hey phodal!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;将网站部署到-s3-上&quot;&gt;将网站部署到 S3 上&lt;/h1&gt;

&lt;p&gt;原文链接：&lt;a href=&quot;https://www.phodal.com/blog/serverless-development-guide-use-serverless-finch-deploy-s3-static-html/&quot;&gt;Serverless 应用开发指南：使用 S3 部署静态网站&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在尝试了使用 Router53 路由到 S3 后，并想试试能否使用 serverless 框架来上传静态内容。在探索官方的 DEMO 后，找到了一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;serverless-finch&lt;/code&gt; 插件可以做相应的事情。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;serverless create --template aws-nodejs s3-static-file s3-static-file
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;配置-serverless-finch&quot;&gt;配置 serverless-finch&lt;/h2&gt;

&lt;p&gt;官网的 &lt;code class=&quot;highlighter-rouge&quot;&gt;serverless-client-s3&lt;/code&gt; 已经停止维护了，并推荐使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;serverless-finch&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;serverless-finch&lt;/code&gt; 的安装方式是：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm install --save serverless-finch
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;默认的官网生成的项目，并没有 &lt;code class=&quot;highlighter-rouge&quot;&gt;package.json&lt;/code&gt; 文件，需要手动执行 &lt;code class=&quot;highlighter-rouge&quot;&gt;npm inti&lt;/code&gt;，再安装插件。&lt;/p&gt;

&lt;p&gt;因此修改完后的 &lt;code class=&quot;highlighter-rouge&quot;&gt;package.json&lt;/code&gt; 文件如下所示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{
  &quot;name&quot;: &quot;s3-static-file&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;amp;&amp;amp; exit 1&quot;
  },
  &quot;author&quot;: &quot;Phodal Huang&quot;,
  &quot;license&quot;: &quot;MIT&quot;,
  &quot;dependencies&quot;: {
    &quot;serverless-finch&quot;: &quot;^1.1.1&quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在这个时候，我们需要按 serverless 框架的插件要求，添加如下的内容：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;plugins:
  - serverless-finch
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;并配置好我们的 S3 存储桶的名字，最后 &lt;code class=&quot;highlighter-rouge&quot;&gt;serverless.yml&lt;/code&gt; 文件的内容如下所示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;service: s3-static-file


plugins:
  - serverless-finch

provider:
  name: aws
  runtime: nodejs6.10

custom:
  client:
    bucketName: wdsm.io
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们配置的 S3 存储桶的名字是: &lt;strong&gt;wdsm.io&lt;/strong&gt;，然后其使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;client/dist&lt;/code&gt; 文件来放置静态文件。&lt;/p&gt;

&lt;h2 id=&quot;静态内容&quot;&gt;静态内容&lt;/h2&gt;

&lt;p&gt;如我们的 &lt;code class=&quot;highlighter-rouge&quot;&gt;index.html&lt;/code&gt; 文件的路径是： &lt;code class=&quot;highlighter-rouge&quot;&gt;client/dist/index.html&lt;/code&gt;，对应的内容是：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;html&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;lang=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;en&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;meta&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;charset=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;UTF-8&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;title&amp;gt;&lt;/span&gt;WDSM.io&lt;span class=&quot;nt&quot;&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
 	&lt;span class=&quot;nt&quot;&gt;&amp;lt;h1&amp;gt;&lt;/span&gt;WDSM&lt;span class=&quot;nt&quot;&gt;&amp;lt;/h1&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;最后，执行 &lt;code class=&quot;highlighter-rouge&quot;&gt;serverless client deploy&lt;/code&gt; 就可以部署我们的网站。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;再次提醒&lt;/code&gt;，这次我们用的是 &lt;code class=&quot;highlighter-rouge&quot;&gt;serverless client deploy&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;相应的过程日志如下所示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Serverless: Deploying client to stage &quot;dev&quot; in region &quot;us-east-1&quot;...
Serverless: Bucket wdsm.io exists
Serverless: Listing objects in bucket wdsm.io...
Serverless: Deleting all objects from bucket wdsm.io...
Serverless: Configuring website bucket wdsm.io...
Serverless: Configuring policy for bucket wdsm.io...
Serverless: Configuring CORS policy for bucket wdsm.io...
Serverless: Uploading file error.html to bucket wdsm.io...
Serverless: If successful this should be deployed at: https://s3.amazonaws.com/wdsm.io/error.html
Serverless: Uploading file index.html to bucket wdsm.io...
Serverless: If successful this should be deployed at: https://s3.amazonaws.com/wdsm.io/index.html
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;由于配置了 Router53 指向了 S3，因此可以直接访问：&lt;a href=&quot;http://wdsm.io/&quot;&gt;http://wdsm.io/&lt;/a&gt; 来看最后的内容。&lt;/p&gt;

&lt;p&gt;并且，对应的删除命令也变成了：&lt;code class=&quot;highlighter-rouge&quot;&gt;serverless client remove&lt;/code&gt;。&lt;/p&gt;

&lt;h1 id=&quot;为基于-s3-的网站支持-crud&quot;&gt;为基于 S3 的网站支持 CRUD&lt;/h1&gt;

&lt;p&gt;原文链接：&lt;a href=&quot;https://www.phodal.com/blog/serverless-development-guide-use-s3-api-gateway-create-crud/&quot;&gt;Serverless 应用开发指南：API Gateway + S3 + AWS Lambda 打造 CRUD&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在前两篇文章《Serverless 应用开发指南： serverless 的 hello, world》和 《&lt;a href=&quot;https://www.phodal.com/blog/serverless-guide-development-aws-iot-serverless-example/&quot;&gt;Serverless 开发指南：AWS IoT 服务开发&lt;/a&gt;》 里，我们简单地介绍了如何用 Serverless 和 AWS IoT 开发入门级的 Serverless 应用。&lt;/p&gt;

&lt;p&gt;在这一篇文章里，我们将开始进入正式的应用开发领域里：一个 CRUD 示例。&lt;/p&gt;

&lt;p&gt;原先，我考虑直接先使用 DynamoDB 进行实验，但是考虑到我之前误用 DynamoDB 被扣 500 刀，再追回来的经历。我决定先用 S3 练练手——主要是已经有一个成型的 DEMO。&lt;/p&gt;

&lt;h2 id=&quot;概念api-gateway-与-s3&quot;&gt;概念：API Gateway 与 S3&lt;/h2&gt;

&lt;p&gt;以下是来自官网对于 API Gateway 和 S3 的介绍：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Amazon API Gateway 是一种完全托管的服务，可以帮助开发者轻松创建、发布、维护、监控和保护任意规模的 API。只需在 AWS 管理控制台中点击几下，您便可以创建可充当应用程序“前门”的 API，从后端服务访问数据、业务逻辑或功能，例如基于 Amazon Elastic Compute Cloud (Amazon EC2) 运行的工作负载、基于 AWS Lambda 运行的代码或任意 Web 应用。Amazon API Gateway 负责管理所有任务，涉及接受和处理成千上万个并发 API 调用，包括流量管理、授权和访问控制、监控以及 API 版本管理。Amazon API Gateway 没有最低费用或启动成本，您只需为收到的 API 调用和传输出去的数据量付费。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Amazon S3 将数据作为对象存储在被称为“存储桶”的资源中。您可以在一个存储桶中尽可能多地存储对象，并写入、读取和删除您的存储桶中的对象。对象大小最多可为 5 TB。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;简单地来说，API Gateway 就是那个 API gateway，即所有 API 请求的入口。而 S3 就存储内容的部分——可以视作为云盘。&lt;/p&gt;

&lt;h2 id=&quot;基于-s3-的-serverless-crud&quot;&gt;基于 S3 的 Serverless CRUD&lt;/h2&gt;

&lt;p&gt;为了使用 S3，我们需要引入 aws-sdk 库来帮助我们更好的编写 AWS 应用。接着，让我们引入这个服务：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;serverless install --url https://github.com/tscanlin/serverless-s3-crud
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后，到目录中，安装依赖：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd serverless-s3-crud
npm install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;再执行部署：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;serverless deploy
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;执行的时候，发现了：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  Serverless Error ---------------------------------------

  An error occurred: MyBucket - form-response already exists.

  Get Support --------------------------------------------
     Docs:          docs.serverless.com
     Bugs:          github.com/serverless/serverless/issues
     Forums:        forum.serverless.com
     Chat:          gitter.im/serverless/serverless

  Your Environment Information -----------------------------
     OS:                     darwin
     Node Version:           6.11.0
     Serverless Version:     1.23.0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;啊哈，这个 MyBucket 已经存在了，这意味着，我们需要改一个新的名字。打开 &lt;code class=&quot;highlighter-rouge&quot;&gt;serverless.yml&lt;/code&gt; 文件，将其中的 16、22、72 行中的 from-response 改成你想要的名字，如 &lt;code class=&quot;highlighter-rouge&quot;&gt;phodal-serverless&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;以及** handlers 目录下的各个文件的 Bucket 名**。&lt;/p&gt;

&lt;p&gt;serverless.yml 代码中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;iamRoleStatements&lt;/code&gt; 用于设置 serverless 的权限，Action 代码其所能进行的操作，Resource 则是相应的资源：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  iamRoleStatements:
    - Effect: Allow
      Action:
        - s3:ListBucket
      Resource: &quot;arn:aws:s3:::phodal-serverless&quot;
    - Effect: Allow
      Action:
        - s3:PutObject
        - s3:GetObject
        - s3:DeleteObject
      Resource: &quot;arn:aws:s3:::phodal-serverless/*&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;下面的代码则定义了，我们的资源，所使用的存储桶（BucketName）的名字：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;resources:
  Resources:
    MyBucket:
      Type: AWS::S3::Bucket
      Properties:
        BucketName: phodal-serverless
        AccessControl: PublicReadWrite
        WebsiteConfiguration:
          IndexDocument: index.html
          ErrorDocument: error.html
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后再执行 &lt;code class=&quot;highlighter-rouge&quot;&gt;serverless deploy&lt;/code&gt;，就会返回我们想要的结果及 API 地址：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;api keys:
  None
endpoints:
  POST - https://xc1iprfbsg.execute-api.us-east-1.amazonaws.com/dev/form-response/{id}
  GET - https://xc1iprfbsg.execute-api.us-east-1.amazonaws.com/dev/form-response
  GET - https://xc1iprfbsg.execute-api.us-east-1.amazonaws.com/dev/form-response/readAll
  GET - https://xc1iprfbsg.execute-api.us-east-1.amazonaws.com/dev/form-response/{id}
  PUT - https://xc1iprfbsg.execute-api.us-east-1.amazonaws.com/dev/form-response/{id}
  DELETE - https://xc1iprfbsg.execute-api.us-east-1.amazonaws.com/dev/form-response/{id}
functions:
  create: serverless-crud-s3-dev-create
  list: serverless-crud-s3-dev-list
  readAll: serverless-crud-s3-dev-readAll
  readOne: serverless-crud-s3-dev-readOne
  update: serverless-crud-s3-dev-update
  delete: serverless-crud-s3-dev-delete
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面列出了所有端口的 API 地址，&lt;/p&gt;

&lt;h2 id=&quot;上传原理&quot;&gt;上传原理&lt;/h2&gt;

&lt;p&gt;那么，它是怎么进行操作的呢，先看看 &lt;code class=&quot;highlighter-rouge&quot;&gt;serverless.yml&lt;/code&gt; 文件中定义的 create 动作。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;functions:
  create:
    handler: handler.create
    events:
      - http:
          path: form-response/{id}
          method: post
          cors: true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;对应了 &lt;code class=&quot;highlighter-rouge&quot;&gt;handler.js&lt;/code&gt; 文件中的 create 方法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const Create = require('./handlers/create.js')
...

function makeResponse(error, result) {
  const statusCode = error &amp;amp;&amp;amp; error.statusCode || 200
  return {
    statusCode,
    headers: {
      &quot;Access-Control-Allow-Origin&quot; : &quot;*&quot;
    },
    body: JSON.stringify(result),
  }
}

exports.create = (event, context, callback) =&amp;gt; {
  Create(event, (error, result) =&amp;gt; {
    const response = makeResponse(error, result)
    context.succeed(response)
  })
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;对应的 create 操作，即是：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;'use strict'

const AWS = require('aws-sdk')
const S3 = new AWS.S3(require('../s3config.js')())

module.exports = (event, callback) =&amp;gt; {
  S3.upload({
    Bucket: 'phodal-serverless',
    Key: event.pathParameters.id,
    Body: event.body,
    // ACL: 'public-read-write' // TODO: Make this an option.
  }, (err, res) =&amp;gt; {
    console.log(err, res)
    callback(err, res)
  })
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们就是在这里上传数据到 S3 的。&lt;/p&gt;

&lt;h2 id=&quot;serverless-s3-crud-示例&quot;&gt;Serverless S3 CRUD 示例&lt;/h2&gt;

&lt;p&gt;一个简单的方式是使用 curl：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl -X POST https://xc1iprfbsg.execute-api.us-east-1.amazonaws.com/dev/form-response/1 --data '{ &quot;body&quot; : &quot;Learn Serverless&quot; }'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{
    &quot;ETag&quot;: &quot;\&quot;695827e7012d367b7e7a28a3fdf7ce06\&quot;&quot;,
    &quot;Location&quot;: &quot;http://s3.amazonaws.com/phodal-serverless/1&quot;,
    &quot;key&quot;: &quot;1&quot;,
    &quot;Key&quot;: &quot;1&quot;,
    &quot;Bucket&quot;: &quot;phodal-serverless&quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后同样的可以通过 curl 来获取：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl https://xc1iprfbsg.execute-api.us-east-1.amazonaws.com/dev/form-response
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;就是这么简单。&lt;/p&gt;

&lt;p&gt;如果只是测试用途，可以在执行完成后执行 serverless remove 来删除对应的服务，以减少开支。&lt;/p&gt;

&lt;h1 id=&quot;结合-dynamodb-数据库创建-restful-api&quot;&gt;结合 DynamoDB 数据库创建 RESTful API&lt;/h1&gt;

&lt;p&gt;原文链接：&lt;a href=&quot;https://www.phodal.com/blog/serverless-developement-gui-lambda-api-gateway-dynamodb-create-restful-services/&quot;&gt;Serverless 应用开发指南：Lambda + API Gateway + DynamoDB 制作 REST API&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本文将介绍如何用 AWS Lambda + API Gateway + DynamoDB 创建一个 RESTful API 的示例。文中的示例是一个 TODO API 的示例，支持 GET、POST、PUT、DELETE 请求，即常规的 CRUD。&lt;/p&gt;

&lt;p&gt;安装示例项目的命令如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;serverless install -u https://github.com/serverless/examples/tree/master/aws-node-rest-api-with-dynamodb -n aws-node-rest-api-with-dynamodb
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;serverless-dynamodb-示例配置&quot;&gt;Serverless DynamoDB 示例配置&lt;/h2&gt;

&lt;p&gt;先让我们来看看 &lt;code class=&quot;highlighter-rouge&quot;&gt;serverless.yml&lt;/code&gt; 中的几个重要部分。以下是项目及 dynamodb 的一些相应的配置：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;provider:
  name: aws
  runtime: nodejs4.3
  environment:
    DYNAMODB_TABLE: ${self:service}-${opt:stage, self:provider.stage}
  iamRoleStatements:
    - Effect: Allow
      Action:
        - dynamodb:Query
        - dynamodb:Scan
        - dynamodb:GetItem
        - dynamodb:PutItem
        - dynamodb:UpdateItem
        - dynamodb:DeleteItem
      Resource: &quot;arn:aws:dynamodb:${opt:region, self:provider.region}:*:table/${self:provider.environment.DYNAMODB_TABLE}&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;即我们配置了我们能用 dynamodb 所进行的操作。&lt;/p&gt;

&lt;p&gt;在 functions 字段里，仍然是对应事件的处理。唯一不同的是，这次多了一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;cors&lt;/code&gt; 为 ture 的键值，如其字面意思：允许跨域请求。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;functions:
  create:
    handler: todos/create.create
    events:
      - http:
          path: todos
          method: post
          cors: true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;相应的和之前的 s3 示例一样，也是对相应的资源进行配置，如表名，Scheme 等等。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;resources:
  Resources:
    TodosDynamoDbTable:
      Type: 'AWS::DynamoDB::Table'
      DeletionPolicy: Retain
      Properties:
        AttributeDefinitions:
          -
            AttributeName: id
            AttributeType: S
        KeySchema:
          -
            AttributeName: id
            KeyType: HASH
        ProvisionedThroughput:
          ReadCapacityUnits: 1
          WriteCapacityUnits: 1
        TableName: ${self:provider.environment.DYNAMODB_TABLE}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;serverless-dynamodb-示例代码&quot;&gt;Serverless DynamoDB 示例代码&lt;/h2&gt;

&lt;p&gt;接着，让我们来看看一下简单的 &lt;code class=&quot;highlighter-rouge&quot;&gt;get&lt;/code&gt; 操作的例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;'use strict';

const AWS = require('aws-sdk'); // eslint-disable-line import/no-extraneous-dependencies

const dynamoDb = new AWS.DynamoDB.DocumentClient();

module.exports.get = (event, context, callback) =&amp;gt; {
  const params = {
    TableName: process.env.DYNAMODB_TABLE,
    Key: {
      id: event.pathParameters.id,
    },
  };

  // fetch todo from the database
  dynamoDb.get(params, (error, result) =&amp;gt; {
    // handle potential errors
    if (error) {
      console.error(error);
      callback(null, {
        statusCode: error.statusCode || 501,
        headers: { 'Content-Type': 'text/plain' },
        body: 'Couldn\'t fetch the todo item.',
      });
      return;
    }

    // create a response
    const response = {
      statusCode: 200,
      body: JSON.stringify(result.Item),
    };
    callback(null, response);
  });
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在代码里，首先我们引入了 aws-sdk，然后创建了一个 DynamoDB 客户端。在 get 函数里，我们将从 &lt;code class=&quot;highlighter-rouge&quot;&gt;event&lt;/code&gt; 对象中获取到路径参数，并取出其中的 id。随后，到数据库中查找是否有相应的 id。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果有，就返回 200 及对应的内容。&lt;/li&gt;
  &lt;li&gt;如果没有，则返回一个 501 异常。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;除了 create.js 方法中，使用了 uuid 用来生成唯一的 ID。考虑到其它代码与我们正常的 CRUD 并没有多大不同，就不详细展开了。&lt;/p&gt;

&lt;h2 id=&quot;serverless-dynamodb-部署&quot;&gt;Serverless DynamoDB 部署&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;serverless deploy
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;生成的对应数据如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;......................................................................................................
Serverless: Stack update finished...
Service Information
service: serverless-rest-api-with-dynamodb
stage: dev
region: us-east-1
stack: serverless-rest-api-with-dynamodb-dev
api keys:
  None
endpoints:
  POST - https://dw5y1epmsj.execute-api.us-east-1.amazonaws.com/dev/todos
  GET - https://dw5y1epmsj.execute-api.us-east-1.amazonaws.com/dev/todos
  GET - https://dw5y1epmsj.execute-api.us-east-1.amazonaws.com/dev/todos/{id}
  PUT - https://dw5y1epmsj.execute-api.us-east-1.amazonaws.com/dev/todos/{id}
  DELETE - https://dw5y1epmsj.execute-api.us-east-1.amazonaws.com/dev/todos/{id}
functions:
  create: serverless-rest-api-with-dynamodb-dev-create
  list: serverless-rest-api-with-dynamodb-dev-list
  get: serverless-rest-api-with-dynamodb-dev-get
  update: serverless-rest-api-with-dynamodb-dev-update
  delete: serverless-rest-api-with-dynamodb-dev-delete
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;serverless-dynamodb-测试&quot;&gt;Serverless DynamoDB 测试&lt;/h2&gt;

&lt;p&gt;我们使用的测试脚本仍然和之前的一样，也相当的简单。以下是创建的命令：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl -X POST https://dw5y1epmsj.execute-api.us-east-1.amazonaws.com/dev/todos --data '{ &quot;text&quot;: &quot;Learn Serverless&quot; }'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;生成的数据如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{
 &quot;id&quot;: &quot;bc74f220-bcb6-11e7-ada2-5b0b42425b91&quot;,
 &quot;text&quot;: &quot;Learn Serverless&quot;,
 &quot;checked&quot;: false,
 &quot;createdAt&quot;: 1509287868994,
 &quot;updatedAt&quot;: 15092878689![94
}][1]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;让我们再创建一条：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; curl -X POST https://dw5y1epmsj.execute-api.us-east-1.amazonaws.com/dev/todos --data '{ &quot;text&quot;: &quot;update totdolists&quot; }'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这些都可以在数据库中，查看到对应的数据，如下所示：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/img/posts/2019-05-24-serverless-app-dev-guide/dynamodb-console-log.png&quot;&gt;&lt;img src=&quot;/assets/img/posts/2019-05-24-serverless-app-dev-guide/dynamodb-console-log.png&quot; alt=&quot;DynamoDB 示例&quot; title=&quot;查看原图&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;其它操作&quot;&gt;其它操作&lt;/h2&gt;

&lt;p&gt;然后查看所有的：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl https://dw5y1epmsj.execute-api.us-east-1.amazonaws.com/dev/todos
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;或者更新某一条：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl -X PUT https://dw5y1epmsj.execute-api.us-east-1.amazonaws.com/dev/todos/1 --data '{ &quot;text&quot;: &quot;Learn Serverless&quot;, &quot;checked&quot;: true }'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;删除某一条:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl -X DELETE https://dw5y1epmsj.execute-api.us-east-1.amazonaws.com/dev/todos/1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;对了，没事得删除。。。考虑到我之前的 500 刀的经历，记得：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;serverless remove
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;express-实现-serverless-的-react-服务端渲染&quot;&gt;Express 实现 Serverless 的 React 服务端渲染&lt;/h1&gt;

&lt;p&gt;原文链接：&lt;a href=&quot;https://www.phodal.com/blog/serverless-development-guide-express-react-build-server-side-rendering/&quot;&gt;Serverless 应用开发指南：Serverless + Express 的 React 服务端渲染&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;我们已经可以用 AWS Lambda 来动态返回 HTML 了。在阅读了一系列的文章后，也发现了 Express 可以在 Lambda 上运行。当我们可以运行 Express 的时候，也意味着，它可以进行服务端渲染，即我们可以做  React 的服务端渲染。&lt;/p&gt;

&lt;p&gt;于是，便有了这篇文章，也有了我创建的第一个 serverless 的项目：&lt;a href=&quot;https://github.com/phodal/serverless-react-server-side-render&quot;&gt;serverless-react-server-side-render&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;对于这个项目来说，主要分成了三个步骤：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在 AWS Lambda 上运行 Express&lt;/li&gt;
  &lt;li&gt;Express + React 进行服务端渲染&lt;/li&gt;
  &lt;li&gt;配置 Webpack 来打包 React&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;serverless--express&quot;&gt;Serverless + Express&lt;/h2&gt;

&lt;p&gt;要 AWS Lambda 上运行 Express，其实也是很简单的，按官方的 DEMO 来。&lt;/p&gt;

&lt;p&gt;最先我尝试的是 Serverless Frameworks 官方提供的 Express 应用的示例代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// index.js

const serverless = require('serverless-http');
const express = require('express')
const app = express()

app.get('/', function (req, res) {
      res.send('Hello World!')
})

module.exports.handler = serverless(app);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;但是这个示例有一个小问题，即我不能在本地运行我的 Express 应用。在探索的时候，我找到了 AWS Lab 提供的 &lt;code class=&quot;highlighter-rouge&quot;&gt;aws-serverless-express&lt;/code&gt; 库。这个库的用法如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// index.js

const express = require('express')
const app = express()

app.get('/', function (req, res) {
      res.send('Hello World!')
})

app.listen(8080);
module.exports = app;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;对应的，我们就可以抽象出调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;lambdal&lt;/code&gt; 函数。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const awsServerlessExpress = require('aws-serverless-express')
const app = require('./index')
const server = awsServerlessExpress.createServer(app)

exports.handler = (event, context) =&amp;gt; {
   console.log(&quot;EVENT: &quot; + JSON.stringify(event));
   awsServerlessExpress.proxy(server, event, context)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;那么，我们的 &lt;code class=&quot;highlighter-rouge&quot;&gt;serverless.yml&lt;/code&gt; 就很简单了：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;service: serverless-react-boilerplate

provider:
  name: aws
  runtime: nodejs6.10
  stage: dev
  region: us-east-1

functions:
  lambda:
    handler: lambda.handler
    events:
      - http: ANY /
      - http: 'ANY {proxy+}'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;记得在你的 &lt;code class=&quot;highlighter-rouge&quot;&gt;package.json&lt;/code&gt; 中添加以下的内容：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &quot;dependencies&quot;: {
    &quot;aws-serverless-express&quot;: &quot;^3.0.2&quot;,
    &quot;express&quot;: &quot;^4.16.2&quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后，就可以愉快地执行 &lt;code class=&quot;highlighter-rouge&quot;&gt;serverless deploy&lt;/code&gt; 了。&lt;/p&gt;

&lt;p&gt;下一步，就是引入 React。&lt;/p&gt;

&lt;h2 id=&quot;express--react-进行服务端渲染&quot;&gt;Express + React 进行服务端渲染&lt;/h2&gt;

&lt;p&gt;然后，我开始寻找一个合适的 Serverless 模板，比如：https://github.com/Roilan/react-server-boilerplate。&lt;/p&gt;

&lt;p&gt;引入 React 之后， 我们的 &lt;code class=&quot;highlighter-rouge&quot;&gt;index.js&lt;/code&gt; 文件如下所示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const express = require('express')
import React from 'react';
import { renderToString } from 'react-dom/server';
import App from './app';
import template from './template';

const app = express()

app.get('/', function (req, res) {
	const isMobile = true;
	const initialState = { isMobile };
	const appString = renderToString(&amp;lt;App {...initialState} /&amp;gt;);

	res.send(template({
	  body: appString,
	  title: 'Hello World from the server',
	  initialState: JSON.stringify(initialState)
	}));
})

server.listen(8080);
module.exports = app;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码本身是没有什么特别的，对应的 &lt;code class=&quot;highlighter-rouge&quot;&gt;webpack.config.js&lt;/code&gt; 也稍微做了一些变化，即要打包的代码指向了我们的 &lt;code class=&quot;highlighter-rouge&quot;&gt;lambda.js&lt;/code&gt; 文件。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;module.exports = [
  {
    entry: './src/lambda.js',
    output: {
      path: './dist',
      filename: 'lambda.js',
      libraryTarget: 'commonjs2',
      publicPath: '/'
    },
    target: 'node',
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;同样的，对于我们的 &lt;code class=&quot;highlighter-rouge&quot;&gt;serverless.yml&lt;/code&gt; 文件来，调用的路径也变了——使用打包后的 lambda 文件。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
functions:
  lambda:
    handler: dist/lambda.handler
    events:
      - http: ANY /
      - http: 'ANY {proxy+}'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其它代码没有太大的差异。&lt;/p&gt;

&lt;p&gt;随后，我们就可以进行我们的第二次部署了：&lt;code class=&quot;highlighter-rouge&quot;&gt;serverless deploy&lt;/code&gt;。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;..............
Serverless: Stack update finished...
Serverless: Invoke aws:info
Service Information
service: serverless-react-boilerplate
stage: dev
region: us-east-1
stack: serverless-react-boilerplate-dev
api keys:
  None
endpoints:
  ANY - https://qdt3kt80x3.execute-api.us-east-1.amazonaws.com/dev
  ANY - https://qdt3kt80x3.execute-api.us-east-1.amazonaws.com/dev/{proxy+}
functions:
  lambda: serverless-react-boilerplate-dev-lambda
Serverless: Invoke aws:deploy:finalize
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;最后访问 &lt;a href=&quot;https://qdt3kt80x3.execute-api.us-east-1.amazonaws.com/dev&quot;&gt;https://qdt3kt80x3.execute-api.us-east-1.amazonaws.com/dev&lt;/a&gt; 就可以读取到返回的 HTML，如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;html&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;script&amp;gt;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;window&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;__APP_INITIAL_STATE__&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;isMobile&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;title&amp;gt;&lt;/span&gt;Hello World from the server&lt;span class=&quot;nt&quot;&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;link&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;rel=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;stylesheet&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;href=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/assets/index.css&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;
  
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;root&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;data-reactroot=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;data-reactid=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;1&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;data-react-checksum=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;-526830126&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;h1&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;data-reactid=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;2&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;c&quot;&gt;&amp;lt;!-- react-text: 3 --&amp;gt;&lt;/span&gt;hello world &lt;span class=&quot;c&quot;&gt;&amp;lt;!-- /react-text --&amp;gt;&amp;lt;!-- react-text: 4 --&amp;gt;&lt;/span&gt;mobile&lt;span class=&quot;c&quot;&gt;&amp;lt;!-- /react-text --&amp;gt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;/h1&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
  
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;script &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/assets/bundle.js&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;结果看上去，有点不如我们的预期，显示的内容是『hello world mobile』。不过，至少代表了我们的代码是 work 的。&lt;/p&gt;

&lt;p&gt;从目前的情况来看，仍然有很大的改进空间，如 webpack 版本过低、React 使用的是 15.6.2。但是 it works。&lt;/p&gt;

&lt;p&gt;末了，记得使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;serverless remove&lt;/code&gt; 来省点钱。&lt;/p&gt;

&lt;h1 id=&quot;serverless-的微信公共平台后台&quot;&gt;Serverless 的微信公共平台后台&lt;/h1&gt;

&lt;p&gt;原文链接：&lt;a href=&quot;https://www.phodal.com/blog/serverless-development-guide-serverless-lambda-wechat-public-platform/&quot;&gt;Serverless 应用开发指南：基于 Serverless 与 Lambda 的微信公共平台&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Serverless 在事件驱动方面具有天然的优势，其中之一就是聊天机器人。可要做聊天机器人不是一件容易的事，微信和 QQ 都只能用 Hack 的方式进行。&lt;/p&gt;

&lt;p&gt;于是，便想到微信公众号是不是一个更好的选择。当用户输入一个关键词时，做出相应的回复。总体上来说，他们之间是差不多的。这个时候，就可以开始尝试一个在线上运行的 Serverless 服务。&lt;/p&gt;

&lt;p&gt;在这件事上，有这么几个步骤：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;创建 Serverless  服务&lt;/li&gt;
  &lt;li&gt;引入 node-wechat&lt;/li&gt;
  &lt;li&gt;配置 APP_ID 和 TOKEN 等&lt;/li&gt;
  &lt;li&gt;配置 Route 53 与 API Gateway&lt;/li&gt;
  &lt;li&gt;添加微信公众平号服务&lt;/li&gt;
  &lt;li&gt;部署&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;创建-serverless--服务&quot;&gt;创建 Serverless  服务&lt;/h2&gt;

&lt;p&gt;首先，让我们创建我们的服务：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;serverless create --template aws-nodejs --path serverless-wechat
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个步骤依旧是这么的简单。&lt;/p&gt;

&lt;h2 id=&quot;引入-node-wechat&quot;&gt;引入 node-wechat&lt;/h2&gt;

&lt;p&gt;然后我找到了 node-wechat 库，它使用 express 来做路由，示例如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const express = require('express');
const app = express();
var wechat = require('wechat');
var config = {
  token: 'token',
  appid: 'appid',
  encodingAESKey: 'encodinAESKey',
  checkSignature: true // 可选，默认为true。由于微信公众平台接口调试工具在明文模式下不发送签名，所以如要使用该测试工具，请将其设置为false
};

app.use(express.query());
app.use('/wechat', wechat(config, function (req, res, next) {
  // 微信输入信息都在req.weixin上
  var message = req.weixin;
  if (message.FromUserName === 'diaosi') {
    // 回复屌丝(普通回复)
    res.reply('hehe');
  }
}));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面便是我们的 &lt;code class=&quot;highlighter-rouge&quot;&gt;index.js&lt;/code&gt; 文件。&lt;/p&gt;

&lt;p&gt;然后就是使用类似于《&lt;a href=&quot;https://www.phodal.com/blog/serverless-development-guide-express-react-build-server-side-rendering/&quot;&gt;Serverless 应用开发指南：Serverless + Express 的 React 服务端渲染&lt;/a&gt;》中的方法，使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;aws-serverless-express&lt;/code&gt; 来做出一层代理：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const awsServerlessExpress = require('aws-serverless-express');
const app = require('./index');
const server = awsServerlessExpress.createServer(app);

exports.runserver = (event, context) =&amp;gt; {
   console.log(&quot;EVENT: &quot; + JSON.stringify(event));
   awsServerlessExpress.proxy(server, event, context)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;接下来就是进行相关的配置。&lt;/p&gt;

&lt;h2 id=&quot;配置-app_id-和-token-等&quot;&gt;配置 APP_ID 和 TOKEN 等&lt;/h2&gt;

&lt;p&gt;首先，修改我们的 &lt;code class=&quot;highlighter-rouge&quot;&gt;index.js&lt;/code&gt; 文件中的配置相关代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let config = {
  token: process.env.TOKEN,
  appid: process.env.APP_ID,
  encodingAESKey: process.env.AESKey,
  checkSignature: true
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;token、id、encodingAESKey 将从 &lt;code class=&quot;highlighter-rouge&quot;&gt;serverless.yml&lt;/code&gt; 文件中读取。我们的 &lt;code class=&quot;highlighter-rouge&quot;&gt;serverless.yml&lt;/code&gt; 文件将从另外的文件中读取：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
functions:
  runserver:
    handler: handler.runserver
    events:
      - http: ANY /
      - http: 'ANY {proxy+}'
    environment:
      TOKEN: ${file(./config.yml):TOKEN}
      APP_ID: ${file(./config.yml):APP_ID}
      AESKey: ${file(./config.yml):AESKey}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;即从 &lt;code class=&quot;highlighter-rouge&quot;&gt;config.yml&lt;/code&gt; 中读取：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TOKEN: TOKEN
APP_ID: APP_ID
AESKey: AESKey
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这是为了确保我们可以保护密钥的安全。&lt;/p&gt;

&lt;p&gt;一切准备就绪，执行：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;serverless deploy
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;就会生成对应的 API：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;stack: serverless-wechat-dev
api keys:
  None
endpoints:
  ANY - https://e8tct5f0v2.execute-api.us-east-1.amazonaws.com/dev
  ANY - https://e8tct5f0v2.execute-api.us-east-1.amazonaws.com/dev/{proxy+}
functions:
  runserver: serverless-wechat-dev-runserver
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;于是，我将这个地址填到了公众号后台，发现公号不支持 API Gateway。只能想办法使用自定义的域名，随后就需要使用 Route 53 来创建了。&lt;/p&gt;

&lt;h2 id=&quot;配置-route-53-与-api-gateway&quot;&gt;配置 Route 53 与 API Gateway&lt;/h2&gt;

&lt;p&gt;如之前在《&lt;a href=&quot;https://www.phodal.com/blog/serverless-development-guide-api-gateway-and-route53-custom-domain/&quot;&gt;Serverless 应用开发指南： API Gateway 与 Route53 自定义域名&lt;/a&gt;》中所说，按下面的步骤就可以配置 Route 53 了。&lt;/p&gt;

&lt;p&gt;在 Route 53 上注册有域名，如果没有的话，需要转到 Route 53。&lt;/p&gt;

&lt;p&gt;然后，才能为你的域名请求一个证书&lt;/p&gt;

&lt;p&gt;需要选择的区域是 &lt;code class=&quot;highlighter-rouge&quot;&gt;us-east-1&lt;/code&gt;，这个 region 才能与 API Gateway 一起工作。&lt;/p&gt;

&lt;p&gt;在这个过程中，需要验证域名的所有权。所以，你需要先找个地方注册域名邮箱，如我使用的是网易的域名邮箱。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ yarn add --dev serverless-domain-manager
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;或者&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ npm install serverless-domain-manager --save-dev
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;plugins:
  - serverless-domain-manager

custom:
  customDomain:
    domainName: wechat.wdsm.io
    basePath: ''
    stage: ${self:provider.stage}
    createRoute53Record: true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;serverless create_domain
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;日志：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Serverless: Domain was created, may take up to 40 mins to be initialized.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;AWS CLI 查看：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{
    &quot;items&quot;: [
        {
            &quot;certificateArn&quot;: &quot;arn:aws:acm:us-east-1:706605665335:certificate/278c252a-7aaf-41df-bcf1-adc279347557&quot;,
            &quot;distributionDomainName&quot;: &quot;d1pp7oijqquj95.cloudfront.net&quot;,
            &quot;certificateUploadDate&quot;: 1509592737,
            &quot;domainName&quot;: &quot;wechat.wdsm.io&quot;
        }
    ]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;现在，再执行 &lt;code class=&quot;highlighter-rouge&quot;&gt;serverless deploy&lt;/code&gt; 就可以完成整个步骤了。&lt;/p&gt;

&lt;h2 id=&quot;添加微信公众平号服务&quot;&gt;添加微信公众平号服务&lt;/h2&gt;

&lt;p&gt;然后，我们可以创建几个简单的服务，比如从 Google 搜索内容：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;google(keyword, function (err, res) {
  let result = R.map(R.compose(updateItemField, R.values, R.pick(['title', 'link'])))(res.links);
  response.reply('你想要在 Google 上搜索的内容有： ' + result);
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;又或者是，搜索我博客的相关内容：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;request.get('https://www.phodal.com/api/app/blog_detail/?search=' + keyword, {
  headers: {
    'User-Agent': 'google'
  }
}, function (error, res, body) {
  if (res.statusCode === 200) {
    let parsed = JSON.parse(body);
    const data = parsed;
    var result = R.map(R.compose(updatePhodalItemField, R.values, R.pick(['title', 'slug'])))(data);
    response.reply({
      content: '在『 phodal.com 』上有 x 个结果，前 10 个如下：' + result,
      type: 'text'
    });
  }
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;最后代码见：&lt;a href=&quot;https://github.com/phodal/mp/blob/master/index.js&quot;&gt;https://github.com/phodal/mp/blob/master/index.js&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;部署&quot;&gt;部署&lt;/h2&gt;

&lt;p&gt;最后，让我们愉快地执行 &lt;code class=&quot;highlighter-rouge&quot;&gt;serverless deploy&lt;/code&gt;，对应的日志如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;stack: serverless-wechat-dev
api keys:
  None
endpoints:
  ANY - https://e8tct5f0v2.execute-api.us-east-1.amazonaws.com/dev
  ANY - https://e8tct5f0v2.execute-api.us-east-1.amazonaws.com/dev/{proxy+}
functions:
  runserver: serverless-wechat-dev-runserver
Serverless Domain Manager Summary
Domain Name
  wechat.wdsm.io
Distribution Domain Name
  d1pp7oijqquj95.cloudfront.net
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;结果你想用这个服务，那么只需要：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;serverless install -u https://github.com/phodal/mp -mp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;执行：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yarn install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;再创建你的 &lt;code class=&quot;highlighter-rouge&quot;&gt;config.yml&lt;/code&gt; 文件：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cp config.yml.template config.yml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;最后，就可以愉快地部署了。&lt;/p&gt;

&lt;p&gt;如果你是为测试，你可以执行 &lt;code class=&quot;highlighter-rouge&quot;&gt;serverless remove&lt;/code&gt; 来删除服务。&lt;/p&gt;

&lt;p&gt;最后效果见我的微信公众号：phodal-weixin&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/img/posts/2019-05-24-serverless-app-dev-guide/phodal-wechat.jpg&quot;&gt;&lt;img src=&quot;/assets/img/posts/2019-05-24-serverless-app-dev-guide/phodal-wechat.jpg&quot; alt=&quot;微信&quot; title=&quot;查看原图&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;基于-kinesis-streams-的数据流分析&quot;&gt;基于 Kinesis Streams 的数据流分析&lt;/h1&gt;

&lt;p&gt;Serverless 适合用于事件驱动型应用，以及定时任务。今天，让我们来看看一个事件驱动的例子。&lt;/p&gt;

&lt;p&gt;在之前的那篇《&lt;a href=&quot;https://www.phodal.com/blog/serverless-development-guide-cron-scheduled-job/&quot;&gt;Serverless 应用开发指南：CRON 定时执行 Lambda 任务&lt;/a&gt;》中，我们介绍了如何调度的示例。&lt;/p&gt;

&lt;p&gt;最初我想的是通过 Lambda + DynamoDB 来自定义数据格式，后来发现使用 Kinesis Streams 是一种更简单的方案。&lt;/p&gt;

&lt;h2 id=&quot;amazon-kinesis-streams&quot;&gt;Amazon Kinesis Streams&lt;/h2&gt;

&lt;p&gt;今天，我们要学习的组件是 Amazon Kinesis Streams。引自官网的介绍：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;借助 Amazon Kinesis Streams，您可以构建用于处理或分析流数据的自定义应用程序，以满足特定需求。Kinesis Streams 每小时可从数十万种来源 (如网站点击流、财务交易、社交媒体源、IT 日志和定位追踪事件) 中持续捕获和存储数 TB 数据。借助 Kinesis Client Library (KCL)，您可以构建 Amazon Kinesis 应用程序，并能使用流数据为实时控制面板提供强力支持、生成警报、实施动态定价和广告等等。您还可以将数据从 Kinesis Streams 发送到其他 AWS 服务中，如 Amazon Simple Storage Service (Amazon S3)、Amazon Redshift、Amazon EMR 和 AWS Lambda。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;简单的来说，用于收集日志事件数据的功能，还可以用于实时数据分析。&lt;/p&gt;

&lt;h2 id=&quot;serverless--kinesis-streams&quot;&gt;Serverless + Kinesis Streams&lt;/h2&gt;

&lt;p&gt;最初我试用了 GitHub 上的&lt;a href=&quot;https://github.com/pmuens/serverless-kinesis-streams&quot;&gt;serverless-kinesis-streams&lt;/a&gt;，然后发现它并不会自动创建 Kinesis Streams 服务，于是便自己创建了一个：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;serverless install -u https://github.com/phodal/serverless-guide/tree/master/kinesis-streams -n kinesis-streams                                10:14:50
Serverless: Downloading and installing &quot;serverless-kinesis-streams&quot;...
central entry: serverless-kinesis-streams-master/
central entry: serverless-kinesis-streams-master/README.md
central entry: serverless-kinesis-streams-master/event.json
central entry: serverless-kinesis-streams-master/handler.js
central entry: serverless-kinesis-streams-master/package.json
central entry: serverless-kinesis-streams-master/serverless.yml
Serverless: Successfully installed &quot;serverless-kinesis-streams&quot; as &quot;kinesis-streams&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后执行：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yarn install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;就可以直接部署了：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Serverless: Packaging service...
Serverless: Excluding development dependencies...
Serverless: Uploading CloudFormation file to S3...
Serverless: Uploading artifacts...
Serverless: Uploading service .zip file to S3 (19.75 KB)...
Serverless: Validating template...
Serverless: Updating Stack...
Serverless: Checking Stack update progress...
..............................
Serverless: Stack update finished...
Service Information
service: kinesis-streams
stage: dev
region: us-east-1
stack: kinesis-streams-dev
api keys:
  None
endpoints:
  None
functions:
  dataReceiver: kinesis-streams-dev-dataReceiver
  logger: kinesis-streams-dev-logger
Serverless: Removing old service versions...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;完成后，就可以测试一下了。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ serverless invoke --function dataReceiver --path event.json                                                                

11:30:48
{
    &quot;message&quot;: &quot;Data successfully written to Kinesis stream \&quot;data-receiver\&quot;&quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后，通过相应的日志，我们就可以看到数据流向了：Kinesis stream&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ serverless logs --function logger                                                                                          

11:31:41
START RequestId: 3776bac6-612f-45dd-a8ac-156007f8e49b Version: $LATEST
2017-11-04 11:30:53.382 (+08:00)  3776bac6-612f-45dd-a8ac-156007f8e49b  The following data was written to the Kinesis stream &quot;data-receiver&quot;:
{
  &quot;kinesisSchemaVersion&quot;: &quot;1.0&quot;,
  &quot;partitionKey&quot;: &quot;8e35d6a0-c110-11e7-90ae-59fa1aa30da7&quot;,
  &quot;sequenceNumber&quot;: &quot;49578559262872379484471662829472308063624661238972153858&quot;,
  &quot;data&quot;: &quot;U29tZSBleGFtcGxlIGRhdGE=&quot;,
  &quot;approximateArrivalTimestamp&quot;: 1509766251.753
}
END RequestId: 3776bac6-612f-45dd-a8ac-156007f8e49b
REPORT RequestId: 3776bac6-612f-45dd-a8ac-156007f8e49b  Duration: 72.07 ms  Billed Duration: 100 ms   Memory Size: 128 MB Max Memory Used: 33 MB
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;但是光把数据流向 Kinesis stream ，并没有什么用，我们需要对数据进行处理。比如说，直接将数据存储到 S3，或者是 DynamoDB。&lt;/p&gt;

&lt;p&gt;So，请期待我们的下一篇文章。&lt;/p&gt;

&lt;h1 id=&quot;serverless-数据分析kinesis-firehose-持久化数据到-s3&quot;&gt;Serverless 数据分析，Kinesis Firehose 持久化数据到 S3&lt;/h1&gt;

&lt;p&gt;based on:&lt;a href=&quot;https://github.com/pmuens/serverless-kinesis-streams&quot;&gt;serverless-kinesis-streams&lt;/a&gt;, but auto create Kinesis streams&lt;/p&gt;

&lt;p&gt;在尝试了使用 Kinesis Stream 处理数据之后，我发现它并不能做什么。接着，便开始找寻其它方式，其中一个就是：Amazon Kinesis Firehose&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Amazon Kinesis Firehose 是将流数据加载到 AWS 的最简单方式。它可以捕捉、转换流数据并将其加载到 Amazon Kinesis Analytics、Amazon S3、Amazon Redshift 和 Amazon Elasticsearch Service，让您可以利用正在使用的现有商业智能工具和仪表板进行近乎实时的分析。这是一项完全托管的服务，可以自动扩展以匹配数据吞吐量，并且无需持续管理。它还可以在加载数据前对其进行批处理、压缩和加密，从而最大程度地减少目的地使用的存储量，同时提高安全性。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;serverless-kinesis-firehose-代码&quot;&gt;Serverless Kinesis Firehose 代码&lt;/h2&gt;

&lt;p&gt;总的来说，Kinesis Firehose 的 Lambda 代码与 Kinesis 是差不多的。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;module.exports.receiver = (event, context, callback) =&amp;gt; {
  const data = event.data;
  const firehose = new AWS.Firehose();

  const params = {
    Record: {
      Data: data
    },
    DeliveryStreamName: 'serverless-firehose'
  };

  return firehose.putRecord(params, (error, data) =&amp;gt; {
    ...
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;以下则是 Kinesis Stream 的代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;module.exports.dataReceiver = (event, context, callback) =&amp;gt; {
  const data = event.data;
  const kinesis = new AWS.Kinesis();
  const partitionKey = uuid.v1();

  const params = {
    Data: data,
    PartitionKey: partitionKey,
    StreamName: 'kinesis-streams-stream'
  };

  return kinesis.putRecord(params, (error, data) =&amp;gt; {
    ...
  });
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;两个 Lambda 函数之间，最大的区别就是在于 new 出来的对象不一样，并且这个对象的参数也是不一样的。&lt;/p&gt;

&lt;p&gt;但是他们的配置来说，可能相差甚远。并且，实际上将数据存到 S3 的工作，主要是由 &lt;code class=&quot;highlighter-rouge&quot;&gt;serverless.yml&lt;/code&gt; 文件来控制 的：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ServerlessKinesisFirehoseBucket:
  Type: AWS::S3::Bucket
  DeletionPolicy: Retain
  Properties:
    BucketName: serverless-firehose-bucket
ServerlessKinesisFirehose:
  Type: AWS::KinesisFirehose::DeliveryStream
  Properties:
    DeliveryStreamName: serverless-firehose
    S3DestinationConfiguration:
      BucketARN:
        Fn::Join:
        - ''
        - - 'arn:aws:s3:::'
          - Ref: ServerlessKinesisFirehoseBucket
      BufferingHints:
        IntervalInSeconds: &quot;60&quot;
        SizeInMBs: &quot;1&quot;
      CompressionFormat: &quot;UNCOMPRESSED&quot;
      Prefix: &quot;raw/&quot;
      RoleARN: { Fn::GetAtt: [ FirehoseToS3Role, Arn ] }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在配置文件中，我们定义了要交付的 Stream 的名字，以及对应用来存储数据的 S3 Bucket 名称。&lt;/p&gt;

&lt;h2 id=&quot;安装及测试&quot;&gt;安装及测试&lt;/h2&gt;

&lt;p&gt;好了，现在不妨直接试试相关的代码。&lt;/p&gt;

&lt;p&gt;1.安装我们的服务&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm install -u https://github.com/phodal/serverless-guide/tree/master/kinesis-streams -n kinesis-streams
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;2.然后：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;3.紧接着部署：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;serverless deploy
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;4.触发我们的函数：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;serverless invoke --function receiver --path event.json
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;便会在我们的 S3 中生成对应的数据文件：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/img/posts/2019-05-24-serverless-app-dev-guide/firehose-s3.png&quot;&gt;&lt;img src=&quot;/assets/img/posts/2019-05-24-serverless-app-dev-guide/firehose-s3.png&quot; alt=&quot;Firehose&quot; title=&quot;查看原图&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;由于这里的数据太少，就没有用 Kinesis Analytics 进行分析了。&lt;/p&gt;

&lt;h1 id=&quot;创建邮件发送-api&quot;&gt;创建邮件发送 API&lt;/h1&gt;

&lt;p&gt;当你有一个不成熟的 Idea 时，作为一个受精益思想影响的开发者，那么你可能会学习 Dropbox 创建一个 Landing Page 来验证你的想法。如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/img/posts/2019-05-24-serverless-app-dev-guide/launch-page.jpg&quot;&gt;&lt;img src=&quot;/assets/img/posts/2019-05-24-serverless-app-dev-guide/launch-page.jpg&quot; alt=&quot;Launch Page&quot; title=&quot;查看原图&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这个时候，你只需要大胆地公布出你的 Idea。等待用户的到来、在网页上提交他们的邮箱 blabla。然后在产品准备得差不多的时候，就可以大声地告诉全世界，你们可以来试用了。不过，这只里我们只讨论如何来发送邮件。&lt;/p&gt;

&lt;p&gt;对于诸如邮件发送、短信发送等服务的业务场景来说，采用 Serverless 特别合适——当然，如果你也使用 AWS 服务就更好了。我们只需要将相关的参数，发送到对应的接口即可。&lt;/p&gt;

&lt;p&gt;这次我们要用到的 AWS 服务是 SES（Simple Email Service）。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Amazon Simple Email Service (Amazon SES) 为基于云端的电子邮件发送服务，旨在帮助数字营销师和应用程序开发师发送营销、通知和业务电子邮件。对于使用电子邮件联系客户的所有规模的企业来说，它是一种可靠且经济实用的服务。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;说了这么多，还不如动手操作一下。&lt;/p&gt;

&lt;h2 id=&quot;serverless-email-发送&quot;&gt;Serverless Email 发送&lt;/h2&gt;

&lt;p&gt;笔者创建的服务最初是基于：&lt;a href=&quot;https://github.com/lakshmantgld/aws-ses-serverless-example.git&quot;&gt;AWS-SES-Serverless-Example&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;好了，下面让我们安装这个 Serverless 服务：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;serverless install -u https://github.com/phodal/serverless-guide/tree/master/ses -n ses
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后执行：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yarn install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;接着复制一份 &lt;code class=&quot;highlighter-rouge&quot;&gt;config.copy.json&lt;/code&gt; 为 &lt;code class=&quot;highlighter-rouge&quot;&gt;config.json&lt;/code&gt;，然后在其中配置上相关的内容：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{
  &quot;aws&quot;: {
    &quot;accessKeyId&quot;: &quot;&quot;,
    &quot;secretAccessKey&quot;: &quot;&quot;,
    &quot;region&quot;: &quot;&quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;就可以愉快地部署了：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ serverless deploy

...
Serverless: Stack update finished...
Serverless: Invoke aws:info
Service Information
service: aws-ses
stage: dev
region: us-east-1
stack: aws-ses-dev
api keys:
  None
endpoints:
  POST - https://474a4mg7a7.execute-api.us-east-1.amazonaws.com/dev/sendMail
functions:
  sendMail: aws-ses-dev-sendMail

Stack Outputs
SendMailLambdaFunctionQualifiedArn: arn:aws:lambda:us-east-1:706605665335:function:aws-ses-dev-sendMail:1
ServiceEndpoint: https://474a4mg7a7.execute-api.us-east-1.amazonaws.com/dev
ServerlessDeploymentBucketName: aws-ses-dev-serverlessdeploymentbucket-14jvptxerdtxi

Serverless: Invoke aws:deploy:finalize
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这次的代码也很简单，主要是通过 aws-sdk 中的 SES 来发送邮件：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import AWS from 'aws-sdk';
let ses = new AWS.SES();

module.exports.sendMail = (event, context, callback) =&amp;gt; {
  ...
  ses.sendEmail(emailParams, function (err, data) {
      if (err) {
          console.log(err, err.stack);
          callback(err);
      } else {
        console.log(&quot;SES successful&quot;);
        console.log(data);

        callback(null, response);
      }
  });
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码中便是直接调用相关的参数的。&lt;/p&gt;

&lt;p&gt;接下来就是测试时间了。&lt;/p&gt;

&lt;h2 id=&quot;serverless-email-发送测试&quot;&gt;Serverless Email 发送测试&lt;/h2&gt;

&lt;p&gt;我按照项目的参数配置：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{
    &quot;bccEmailAddresses&quot;: [],
    &quot;ccEmailAddresses&quot;: [],
    &quot;toEmailAddresses&quot;: [&quot;xxx@qq.com&quot;],
    &quot;bodyData&quot;: &quot;Hey test message buddy!! From AWS SES&quot;,
    &quot;bodyCharset&quot;: &quot;UTF-8&quot;,
    &quot;subjectdata&quot;: &quot;AWS SES&quot;,
    &quot;subjectCharset&quot;: &quot;UTF-8&quot;,
    &quot;sourceEmail&quot;: &quot;xxx@qq.com&quot;,
    &quot;replyToAddresses&quot;: [&quot;xxx@qq.com&quot;]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在 PostMan 上进行了测试：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/img/posts/2019-05-24-serverless-app-dev-guide/post-man-example.png&quot;&gt;&lt;img src=&quot;/assets/img/posts/2019-05-24-serverless-app-dev-guide/post-man-example.png&quot; alt=&quot;PostMan 示例&quot; title=&quot;查看原图&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;然后报错了：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{
    &quot;errorMessage&quot;: &quot;There were 3 validation errors:\n* MissingRequiredParameter: Missing required key 'Source' in params\n* MissingRequiredParameter: Missing required key 'Data' in params.Message.Body.Text\n* MissingRequiredParameter: Missing required key 'Data' in params.Message.Subject&quot;,
    &quot;errorType&quot;: &quot;MultipleValidationErrors&quot;,
    &quot;stackTrace&quot;: [
        &quot;* MissingRequiredParameter: Missing required key 'Source' in params&quot;,
        &quot;* MissingRequiredParameter: Missing required key 'Data' in params.Message.Body.Text&quot;,
        &quot;* MissingRequiredParameter: Missing required key 'Data' in params.Message.Subject&quot;,
        &quot;ParamValidator.validate (/var/runtime/node_modules/aws-sdk/lib/param_validator.js:40:28)&quot;,
        &quot;Request.VALIDATE_PARAMETERS (/var/runtime/node_modules/aws-sdk/lib/event_listeners.js:125:42)&quot;,
        &quot;Request.callListeners (/var/runtime/node_modules/aws-sdk/lib/sequential_executor.js:105:20)&quot;,
        &quot;callNextListener (/var/runtime/node_modules/aws-sdk/lib/sequential_executor.js:95:12)&quot;,
        &quot;/var/runtime/node_modules/aws-sdk/lib/event_listeners.js:85:9&quot;,
        &quot;finish (/var/runtime/node_modules/aws-sdk/lib/config.js:315:7)&quot;,
        &quot;/var/runtime/node_modules/aws-sdk/lib/config.js:333:9&quot;,
        &quot;Credentials.get (/var/runtime/node_modules/aws-sdk/lib/credentials.js:126:7)&quot;,
        &quot;getAsyncCredentials (/var/runtime/node_modules/aws-sdk/lib/config.js:327:24)&quot;,
        &quot;Config.getCredentials (/var/runtime/node_modules/aws-sdk/lib/config.js:347:9)&quot;
    ]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;后来，才发现 SES 上有一行解释。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;对于 Amazon SES 新用户 – 如果您尚未申请提高发送限制，则仍将处于沙箱环境中，且只能发送电子邮件至您之前验证过的地址。要验证新电子邮件地址或域，请参阅 Amazon SES 控制台的身份管理部分。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;于是便登录 SNS，新增了一个验证邮箱。&lt;/p&gt;

&lt;p&gt;试了 gmszone@qq.com 、网易邮箱都不行，最后用了 Google 的。&lt;/p&gt;

&lt;p&gt;最后，终于可以接收到邮件了。&lt;/p&gt;

&lt;h1 id=&quot;创建自己的-serverless-短链服务&quot;&gt;&lt;a href=&quot;https://www.phodal.com/blog/serverless-architecture-develoment-create-self-short-url-services/&quot;&gt;创建自己的 Serverless 短链服务&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;在想用 Serverless 可以做点什么简单的在线应用后，我想到了一个是在线短链生成服务。最后的结果见：&lt;a href=&quot;http://x.pho.im/&quot;&gt;http://x.pho.im/&lt;/a&gt;，一个非常简单的在线应用。&lt;/p&gt;

&lt;p&gt;这里的代码基于：&lt;a href=&quot;https://github.com/vannio/serverless-shrink&quot;&gt;https://github.com/vannio/serverless-shrink&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;因为上面的代码中，不能自动创建域名。然后，再针对数据库进行了一些优化。&lt;/p&gt;

&lt;h3 id=&quot;代码逻辑&quot;&gt;代码逻辑&lt;/h3&gt;

&lt;p&gt;这里的代码逻辑比如简单：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;创建短链时，使用生成一个四位的字符串&lt;/li&gt;
  &lt;li&gt;将原有的 URL 和生成的 URL 存储到 DynamoDB 中&lt;/li&gt;
  &lt;li&gt;在返回的 HTML 中，输出对应的 URL&lt;/li&gt;
  &lt;li&gt;重定向时，从 DynamoDB 读取对应的短链&lt;/li&gt;
  &lt;li&gt;如果短链存在，则执行 302 重定向；如果不存在，则返回一个 404。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;创建首页&quot;&gt;创建首页&lt;/h2&gt;

&lt;p&gt;首页只是一个简单的 HTML 表单：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const base_page = `&lt;span class=&quot;nt&quot;&gt;&amp;lt;html&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;h1&amp;gt;&lt;/span&gt;Hi!&lt;span class=&quot;nt&quot;&gt;&amp;lt;/h1&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;form&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;method=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;POST&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;action=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;label&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;for=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;uri&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;Link:&lt;span class=&quot;nt&quot;&gt;&amp;lt;/label&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;input&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;text&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;link&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;link&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;size=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;40&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;autofocus&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;br/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;br/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;input&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;submit&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Shorten it!&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/form&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;`

module.exports.handler = (event, context, callback) =&amp;gt; {
  console.log(JSON.stringify(event));

  callback(
    null,
    {
      statusCode: 200,
      body: base_page,
      headers: {'Content-Type': 'text/html'},
    }
  );
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;当我们提交的时候，就会触发对应的 POST 请求。&lt;/p&gt;

&lt;h2 id=&quot;生成短链&quot;&gt;生成短链&lt;/h2&gt;

&lt;p&gt;如上所述，对于个短链请求，我们要做这么几件事：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;解析出提交表单中的链接&lt;/li&gt;
  &lt;li&gt;根据 URL 生成对应的短链&lt;/li&gt;
  &lt;li&gt;将对应的 URL 和短链的对应关系存储到 DynamoDB 中&lt;/li&gt;
  &lt;li&gt;如果成功，则返回生成的短链；失败则，返回一个 400&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;事实上，在存储 URL 和短链的 map 之前，我们应该先判断一下数据中是否已经有相应的短链。不过，对于这种只针对于我一个用户的短链服务来说，这个步骤有点浪费钱——毕竟要去扫描一遍数据库。所以，我也不想去添加这样的扩展功能。&lt;/p&gt;

&lt;p&gt;接下来，让我们回到代码中去，代码的主要逻辑都是在 Promise 里，按顺序往下执行。&lt;/p&gt;

&lt;h3 id=&quot;解析出提交表单中的链接&quot;&gt;解析出提交表单中的链接&lt;/h3&gt;

&lt;p&gt;首先，我们通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;querystring&lt;/code&gt; 库来解决中表单中的链接。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const submitted = querystring.parse(event.body).link;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;根据-url-生成对应的短链&quot;&gt;根据 URL 生成对应的短链&lt;/h3&gt;

&lt;p&gt;接着，使用 Node.js 中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;crypto.randomBytes&lt;/code&gt; 方法来生成八位的伪随机码。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;crypto.randomBytes(8)
  .toString('base64')
  .replace(/[=+/]/g, '')
  .substring(0, 4)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;由于生成的伪随机码是 Buffer 类型，因此需要转换为字符串。同时，因为生成的短链中不应该有 “=+/”，它会导致生成的 URL 有异常。于是，我们便替换掉伪随机码中的这些特殊字体。最后，截取生成的字符串的前 4 位。&lt;/p&gt;

&lt;p&gt;现在，我们就可以将其存储到数据中了。&lt;/p&gt;

&lt;h3 id=&quot;存储到-dynamo-数据库中&quot;&gt;存储到 Dynamo 数据库中。&lt;/h3&gt;

&lt;p&gt;对应的存储逻辑如下所示，我们 new 了一个 DocumentClient 对象，然后直接存储到数据库中。&lt;code class=&quot;highlighter-rouge&quot;&gt;put&lt;/code&gt; 函数中的对象，即是对应的参数。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;return docClient.put({
  TableName: tableName,
  Item: {
    slug: slug,
    url: submitted
  },
  Expected: {
    url: {Exists: false}
  }
}).promise().then(() =&amp;gt; { return slug; });
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;最后，我们返回了 &lt;code class=&quot;highlighter-rouge&quot;&gt;slug&lt;/code&gt;，用于接下来的处理。&lt;/p&gt;

&lt;h3 id=&quot;返回短链给用户&quot;&gt;返回短链给用户&lt;/h3&gt;

&lt;p&gt;一切处理正常的话，我们将向用户返回最后的内容：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;return callback(
  null,
  {
    statusCode: 200,
    body: RenderPage(path.join(prefix, slug).replace(':/', '://'), prefix),
    headers: {'Content-Type': 'text/html'}
  }
);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中的 HTML 部分的渲染逻辑如下所示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function RenderPage (link, submitted) {
  return `
&lt;span class=&quot;nt&quot;&gt;&amp;lt;html&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;h3&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;a&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;href=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;${link}&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;${link}&lt;span class=&quot;nt&quot;&gt;&amp;lt;/a&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/h3&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;p&amp;gt;&lt;/span&gt;URL ${submitted} was shortened to:
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;a&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;href=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;${link}&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;${link}&lt;span class=&quot;nt&quot;&gt;&amp;lt;/a&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;`
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;是的，只是返回短链和原有的链接了。&lt;/p&gt;

&lt;p&gt;好了，现在我们已经拥有这个短链了。接下来，就是点击这个短链，看看背后会发生些什么？&lt;/p&gt;

&lt;h2 id=&quot;重定向短链&quot;&gt;重定向短链&lt;/h2&gt;

&lt;p&gt;首先，我们先在我们的 &lt;code class=&quot;highlighter-rouge&quot;&gt;serverless.yml&lt;/code&gt; 中，将短链的路径配置为参数：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;functions :
  ...
  redirect:
    handler: redirect/index.handler
    events:
      - http:
          path: /{slug}
          method: get
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后，从数据库中按短链的 slug 查找对应的 URL：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const slug = event.pathParameters.slug;

docClient.get({
  TableName: tableName,
  Key: {
    slug: slug
  }
}, (err, data) =&amp;gt; {

})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果存在对应的短链，则 302 重定向对原有的 URL：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const item = data.Item;

if (item &amp;amp;&amp;amp; item.url) {
  callback(
    null,
    {
      statusCode: 302,
      body: item.url,
      headers: {
        'Location': item.url,
        'Content-Type': 'text/plain'
      }
    }
  )
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果没有，则返回一个 404。&lt;/p&gt;

&lt;p&gt;我们的代码就是这么的简单，现在让我们来部署测试一下。&lt;/p&gt;

&lt;h2 id=&quot;部署及测试短链服务&quot;&gt;部署及测试短链服务&lt;/h2&gt;

&lt;p&gt;如果你还没有 clone 代码的话，执行下面的命令来安装：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;serverless install -u https://github.com/phodal/serverless-guide/tree/master/url-shorter -n url-shorter
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后执行 &lt;code class=&quot;highlighter-rouge&quot;&gt;yarn install&lt;/code&gt; 来安装对应的依赖。&lt;/p&gt;

&lt;p&gt;如果你在 Route53 上注册有相应的域名，修改一下 &lt;code class=&quot;highlighter-rouge&quot;&gt;serverless.yml&lt;/code&gt; 文件中的域名，我们就可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;serverless create_domain&lt;/code&gt; 来创建域名的路由。&lt;/p&gt;

&lt;p&gt;紧接着，执行 &lt;code class=&quot;highlighter-rouge&quot;&gt;serverless deploy&lt;/code&gt; 来部署。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;api keys:
  None
endpoints:
  GET - https://4rr5ndhaw3.execute-api.us-east-1.amazonaws.com/dev/
  POST - https://4rr5ndhaw3.execute-api.us-east-1.amazonaws.com/dev/
  GET - https://4rr5ndhaw3.execute-api.us-east-1.amazonaws.com/dev/{slug}
functions:
  main: url-shorter-dev-main
  create: url-shorter-dev-create
  redirect: url-shorter-dev-redirect
Serverless Domain Manager Summary
Domain Name
  x.pho.im
Distribution Domain Name
  d2s4y0p5nuw3k7.cloudfront.net
Serverless: Removing old service versions...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;一切准备就绪了。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;访问 &lt;a href=&quot;https://x.pho.im/&quot;&gt;https://x.pho.im/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;然后输入一个链接，如：&lt;a href=&quot;https://github.com/phodal/serverless-guide&quot;&gt;https://github.com/phodal/serverless-guide&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;复制生成的地址：&lt;a href=&quot;https://x.pho.im/rgQC&quot;&gt;https://x.pho.im/rgQC&lt;/a&gt;，并返回&lt;/li&gt;
  &lt;li&gt;看是否会重定向到我们的网站上。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Done!&lt;/p&gt;

&lt;h1 id=&quot;结合-auth0-的登录授权系统&quot;&gt;结合 Auth0 的登录、授权系统&lt;/h1&gt;

&lt;p&gt;在多次尝试了使用 Amazon Cognito 前端授权无果，我转而使用和其它教程类似的 Auth0 授权登录。虽然 Amazon 提供了一个用于 Cognito 授权的前端组件，但是它仍然不是很成熟。在浏览器端，好像用得不是很普遍，而 Auth0 则是一个更通用的方案。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Auth0 是一家“身份验证即服务”提供商，旨在为开发人员提供简单易用的身份管理服务。为了保持灵活性和可扩展性，Auth0 身份管理平台允许开发人员在身份验证和授权管道中增加自定义代码。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;最后的代码见：&lt;a href=&quot;https://github.com/phodal/serverless-guide/tree/master/auth0-frontend&quot;&gt;auth0-frontend&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;代码的执行逻辑如下所示：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;由前端使用 Auth0 的 lock.js 调出授权框，进行用户授权&lt;/li&gt;
  &lt;li&gt;用户可以选择使用第三方授权服务登录，如 Google、GitHub&lt;/li&gt;
  &lt;li&gt;用户登录完后，会获取一个 Auth0 的 Token，通过该 Token 去请求数据&lt;/li&gt;
  &lt;li&gt;后台接到数据后，先验证 Token 是否有效的，然后返回相应的结果&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因此，对于我们而言，我们需要做这么一些事：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;创建一个 Serverless 服务&lt;/li&gt;
  &lt;li&gt;创建一个验证 Token 的 Lambda 函数&lt;/li&gt;
  &lt;li&gt;注册 Auth0 账户&lt;/li&gt;
  &lt;li&gt;绑定 Auth0 的 GitHub 授权&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这里我们采用的是 Serverless Framework 的官方示例 Demo。稍有不同的是，代码中对静态文件和 S3 部分进行了一些优化——官方的 DEMO，无法直接部署到 S3 上。&lt;/p&gt;

&lt;h2 id=&quot;serverless-auth0-前端代码&quot;&gt;Serverless Auth0 前端代码&lt;/h2&gt;

&lt;p&gt;在这次的教程里，代码分为两部分：前端和后台。&lt;/p&gt;

&lt;p&gt;这里的前端代码，是一个纯前端的代码。&lt;/p&gt;

&lt;p&gt;先让我们看看授权部分：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const lock = new Auth0Lock(AUTH0_CLIENT_ID, AUTH0_DOMAIN);

...

lock.show((err, profile, token) =&amp;gt; {
    if (err) {
      console.error('Something went wrong: ', err);
    } else {
      localStorage.setItem('userToken', token);
      localStorage.setItem('profile', JSON.stringify(profile));
      ...
    }
  });
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;首先，我们创建了一个 Auth0Lock 对象，并在参数中转入了对应的 ID 和 Auth0 域名。然后使用 lock.show 方法将调出 Auth0 的登录页面，当用户登录成功的时候，就会从后台取到 token 和 profile，然后我们在上面的代码中保存用户的 token 和 profile 到 localstorage 中。&lt;/p&gt;

&lt;p&gt;然后在发送 fetch 请求的时候，我们会带上这个 Token：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const token = localStorage.getItem('userToken');
if (!token) {
  return false;
}
const getdata = fetch(PRIVATE_ENDPOINT, {
  headers: {
    Authorization: `Bearer ${token}`,
  },
  method: 'GET',
  cache: 'no-store',
});

getdata.then((response) =&amp;gt; {
  response.json().then((data) =&amp;gt; {
    console.log('Token:', data);
  });
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;主要的前端逻辑代码就是这么简单。&lt;/p&gt;

&lt;h2 id=&quot;serverless-auth0-后台代码&quot;&gt;Serverless Auth0 后台代码&lt;/h2&gt;

&lt;p&gt;首先，先让我们看一眼 serverless.yml 配置。&lt;/p&gt;

&lt;h3 id=&quot;serverlessyml-配置&quot;&gt;serverless.yml 配置&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;functions:
  auth:
    handler: handler.auth
    environment:
      AUTH0_ID: ${file(./config.yml):AUTH0_ID}
      AUTH0_SECRET: ${file(./config.yml):AUTH0_SECRET}

  publicEndpoint:
    handler: handler.publicEndpoint
    events:
      - http:
          path: api/public
          method: get
          integration: lambda
          cors: true
  privateEndpoint:
    handler: handler.privateEndpoint
    events:
      - http:
          path: api/private
          method: get
          integration: lambda
          authorizer: auth # See custom authorizer docs here: http://bit.ly/2gXw9pO
          cors:
            origins:
              - '*'
            headers:
              - Content-Type
              - X-Amz-Date
              - Authorization
              - X-Api-Key
              - X-Amz-Security-Token
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;配置中定义了三个 lambda 函数：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;auth 函数，用于对用户传过来的 Token 进行校验&lt;/li&gt;
  &lt;li&gt;publicEndpoint 函数，一个公开的 API 结点&lt;/li&gt;
  &lt;li&gt;privateEndpoint 函数，一个需授权才能访问的 API，即它将调用 auth 函数，根据授权结果来返回相应的内容。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;更详细的资料，可以访问官方的文档：&lt;a href=&quot;http://docs.aws.amazon.com/zh_cn/apigateway/latest/developerguide/use-custom-authorizer.html&quot;&gt;使用 API Gateway 自定义授权方&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;auth 函数的代码如下所示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const jwt = require('jsonwebtoken');
...
const jwt = require('jsonwebtoken');
  if (event.authorizationToken) {
    // remove &quot;bearer &quot; from token
    const token = event.authorizationToken.substring(7);
    const options = {
      audience: AUTH0_CLIENT_ID,
    };
    jwt.verify(token, AUTH0_CLIENT_SECRET, options, (err, decoded) =&amp;gt; {
      if (err) {
        cb('Unauthorized');
      } else {
        cb(null, generatePolicy(decoded.sub, 'Allow', event.methodArn));
      }
    });
  } else {
    cb('Unauthorized');
  }
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码中的主要函数是 &lt;code class=&quot;highlighter-rouge&quot;&gt;jwt.verify&lt;/code&gt;，它将根据 AUTH0 的 ID 和密钥来校验 token 是否是有效的。同时，还引用了一个名为 &lt;code class=&quot;highlighter-rouge&quot;&gt;generatePolicy&lt;/code&gt; 的方法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const generatePolicy = (principalId, effect, resource) =&amp;gt; {
  const authResponse = {};
  authResponse.principalId = principalId;
  if (effect &amp;amp;&amp;amp; resource) {
    const policyDocument = {};
    policyDocument.Version = '2012-10-17';
    policyDocument.Statement = [];
    const statementOne = {};
    statementOne.Action = 'execute-api:Invoke';
    statementOne.Effect = effect;
    statementOne.Resource = resource;
    policyDocument.Statement[0] = statementOne;
    authResponse.policyDocument = policyDocument;
  }
  return authResponse;
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个方法用于生成一个 IAM 的策略，这个策略的生成规则建议参考官方文档，以上的内容和 AWS 的官方 DEMO 是一致的。随后，再根据生成的是 ‘Allow’ 或者 ‘Deny’ 来判断，该用户是否拥有权限。如果用户拥有权限的，那么就会继续往下执行：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;module.exports.privateEndpoint = (event, context, cb) =&amp;gt; {
  cb(null, { message: 'Only logged in users can see this' });
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;说了这么多，还是让我们跑跑代码吧。&lt;/p&gt;

&lt;h2 id=&quot;配置及部署&quot;&gt;配置及部署&lt;/h2&gt;

&lt;p&gt;在这一个步骤里我们要做这么几件事：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;注册、获取 Auth0 的账号&lt;/li&gt;
  &lt;li&gt;部署 Lambda 函数，获取后台 API 地址&lt;/li&gt;
  &lt;li&gt;根据上一步生成的地址，修改前端代码中的地址&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因此在开始之前，需要先申请一个 Auth0 的账号，然后在 &lt;code class=&quot;highlighter-rouge&quot;&gt;config.yml&lt;/code&gt; 中，添加 auth0 的 id 和密钥。&lt;/p&gt;

&lt;p&gt;然后执行部署：&lt;/p&gt;

&lt;p&gt;···&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;........................................................................
Serverless: Stack update finished...
Service Information
service: auth0-frontend
stage: dev
region: us-east-1
stack: auth0-frontend-dev
api keys:
  None
endpoints:
  GET - https://fy0qtq1r8c.execute-api.us-east-1.amazonaws.com/dev/api/public
  GET - https://fy0qtq1r8c.execute-api.us-east-1.amazonaws.com/dev/api/private
functions:
  auth: auth0-frontend-dev-auth
  publicEndpoint: auth0-frontend-dev-publicEndpoint
  privateEndpoint: auth0-frontend-dev-privateEndpoint
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;将生成的 API Gateway 的地方放入到 &lt;strong&gt;client/dist/app.js&lt;/strong&gt; 文件中：&lt;/p&gt;

&lt;p&gt;再执行：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ serverless client deploy
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;以部署我们的静态文件。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Serverless: Deploying client to stage &quot;dev&quot; in region &quot;us-east-1&quot;...
Serverless: Creating bucket auth.wdsm.io...
Serverless: Configuring website bucket auth.wdsm.io...
Serverless: Configuring policy for bucket auth.wdsm.io...
Serverless: Configuring CORS policy for bucket auth.wdsm.io...
Serverless: Uploading file app.css to bucket auth.wdsm.io...
Serverless: If successful this should be deployed at: https://s3.amazonaws.com/auth.wdsm.io/app.css
Serverless: Uploading file app.js to bucket auth.wdsm.io...
Serverless: If successful this should be deployed at: https://s3.amazonaws.com/auth.wdsm.io/app.js
Serverless: Uploading file index.html to bucket auth.wdsm.io...
Serverless: If successful this should be deployed at: https://s3.amazonaws.com/auth.wdsm.io/index.html
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后打开 &lt;a href=&quot;https://s3.amazonaws.com/auth.wdsm.io/index.html&quot;&gt;https://s3.amazonaws.com/auth.wdsm.io/index.html&lt;/a&gt; 就可以尝试授权。&lt;/p&gt;

&lt;p&gt;不过，在那之间，我们需要填写对应平台的授权信息：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/img/posts/2019-05-24-serverless-app-dev-guide/auth0-github-example.png&quot;&gt;&lt;img src=&quot;/assets/img/posts/2019-05-24-serverless-app-dev-guide/auth0-github-example.png&quot; alt=&quot;Auth GitHub&quot; title=&quot;查看原图&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;接着，点击上面的 GitHub 『！』号，会提示我们填写对应的授权信息。&lt;/p&gt;

&lt;p&gt;打开我们的 GitHub ，申请一个新的 OAuth 应用，地址：&lt;a href=&quot;https://github.com/settings/applications/new&quot;&gt;https://github.com/settings/applications/new&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;详细的信息见：&lt;a href=&quot;https://auth0.com/docs/github-clientid&quot;&gt;https://auth0.com/docs/github-clientid&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;如我的配置是：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Homepage URL: https://phodal.auth0.com
Authorization callback URL  https://phodal.auth0.com/login/callback
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;完成后，把生成的 GitHub ID 和 Client Secret 填入。点击 Save，Auth0 就会自动帮我们测试。&lt;/p&gt;

&lt;p&gt;接着，再到我们的页面上尝试使用 GitHub 登录，还是报了个错：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.js:26 Something went wrong:  Error: error: invalid origin: https://s3.amazonaws.com
    at new LoginError (lock-9.0.min.js:9)
    at lock-9.0.min.js:9
    at onMessage (lock-9.0.min.js:10)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;漏掉了在 Auth0 的设置页的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Allowed Callback URL&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;Allowed Origins&lt;/code&gt; 上加上用于登录的地址，用于允许跨域请求了。在这里，我的地址是：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://s3.amazonaws.com/auth.wdsm.io/index.html
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;/assets/img/posts/2019-05-24-serverless-app-dev-guide/auth0-cors-configure-example.png&quot;&gt;&lt;img src=&quot;/assets/img/posts/2019-05-24-serverless-app-dev-guide/auth0-cors-configure-example.png&quot; alt=&quot;CORS 配置&quot; title=&quot;查看原图&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;然后，再测试一下登录：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/img/posts/2019-05-24-serverless-app-dev-guide/auth0-login-example.png&quot;&gt;&lt;img src=&quot;/assets/img/posts/2019-05-24-serverless-app-dev-guide/auth0-login-example.png&quot; alt=&quot;Auth0 测试登录&quot; title=&quot;查看原图&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;漂亮，我们登录成功了。&lt;/p&gt;

&lt;h3 id=&quot;清理&quot;&gt;清理&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;删除 Auth0 的应用&lt;/li&gt;
  &lt;li&gt;删除 GitHub 的应用&lt;/li&gt;
  &lt;li&gt;清空 Bucket：&lt;code class=&quot;highlighter-rouge&quot;&gt;serverless client remove&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;清空 Lambda：&lt;code class=&quot;highlighter-rouge&quot;&gt;serverless remove&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;结论&quot;&gt;结论&lt;/h2&gt;

&lt;p&gt;AWS 官方的 Congito 支持的第三方应用有限，在这个时候 Auth0 成了一个更好的选择。除了 GitHub，Auth0 还集成了微博、人人等等的国内的平台。&lt;/p&gt;

&lt;p&gt;当然授权，作为一个基础的服务，几乎是每个应用的重要功能，也是核心的功能。对于大数中大型公司来说，几乎不太可能采用这样的方案。&lt;/p&gt;

&lt;h1 id=&quot;在本地部署与调试&quot;&gt;在本地部署与调试&lt;/h1&gt;

&lt;p&gt;在这几周的 Serverless 应用开发里，我觉得最大的不便就是，缺少一个本地的调试环境。在这种时候，我们需要不断地部署我们的代码，不断地在我们的代码里写上几行 &lt;code class=&quot;highlighter-rouge&quot;&gt;console.log&lt;/code&gt;，然后在一切正常之后，再把这些 &lt;code class=&quot;highlighter-rouge&quot;&gt;console.log&lt;/code&gt; 删除。&lt;/p&gt;

&lt;p&gt;可要是，突然间又出现了一个 bug，我仿佛看到了我们又要重来一遍。&lt;/p&gt;

&lt;p&gt;就这样经历了几次之后，我便想尝试一些新的手段，比如 &lt;code class=&quot;highlighter-rouge&quot;&gt;serverless-offline&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;serverless-offline&quot;&gt;serverless-offline&lt;/h2&gt;

&lt;p&gt;serverless-offline 是一个 Serverless Framework 的插件，它可以在本地的机器上模拟 AWS Lamdba 和 API Gateway，以加快开发者的开发周期。为此，它启动一个处理请求生命周期的 HTTP 服务器，就像 APIG 一样，并调用你的处理程序。&lt;/p&gt;

&lt;p&gt;及包含以下的特性：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;仅支持 Node.js 下的 Lambda 函数&lt;/li&gt;
  &lt;li&gt;支持 Velocity 模板&lt;/li&gt;
  &lt;li&gt;延迟加载你的、需要缓存失效文件：而不需要重载工具，如Nodemon。&lt;/li&gt;
  &lt;li&gt;以及，集成，授权人，代理，超时，responseParameters，HTTPS，Babel 运行时环境，CORS 等…&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;那么，让我们看看如何做到这一点。&lt;/p&gt;

&lt;h2 id=&quot;本地搭建-serverless-offline-与-dynamodb-环境&quot;&gt;本地搭建 serverless-offline 与 DynamoDB 环境&lt;/h2&gt;

&lt;p&gt;这次我们将基于之前的文章《&lt;a href=&quot;https://www.phodal.com/blog/serverless-developement-gui-lambda-api-gateway-dynamodb-create-restful-services/&quot;&gt;Serverless 应用开发指南：Lambda + API Gateway + DynamoDB 制作 REST API
&lt;/a&gt;》中的 todolist，来开始我们的调试之旅。&lt;/p&gt;

&lt;p&gt;在之前的示例里，我们使用了 DynamoDB 来存储数据。在这篇文章里，我们也将介绍 &lt;code class=&quot;highlighter-rouge&quot;&gt;serverless-dynamodb-local&lt;/code&gt; 来在本地运行 DynamoDB。&lt;/p&gt;

&lt;p&gt;在那之前，如果你还没有之前的代码，请先安装服务到本地：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm install -u https://github.com/phodal/serverless-guide/tree/master/aws-node-rest-api-with-dynamodb -n dynamodb-offline
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后，在我们的项目里安装 &lt;code class=&quot;highlighter-rouge&quot;&gt;serverless-offline&lt;/code&gt; 插件：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yarn add --dev serverless-offline
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;并安装 &lt;code class=&quot;highlighter-rouge&quot;&gt;serverless-dynamodb-local&lt;/code&gt; 插件：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yarn add --dev serverless-dynamodb-local
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后，在 &lt;code class=&quot;highlighter-rouge&quot;&gt;serverless.yml&lt;/code&gt; 中添加相应的插件：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;plugins:
  - serverless-offline
  - serverless-dynamodb-local
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;紧接着，还需要进行相应的 dynamodb 配置：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;custom:
  dynamodb:
    start:
      port: 8000
      inMemory: true
      migrate: true
    migration:
      dir: offline/migrations
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中的 migration 对应的是本地的 Scheme，位于 &lt;code class=&quot;highlighter-rouge&quot;&gt;offline/migrations/todos.json&lt;/code&gt;，内容如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{
    &quot;Table&quot;: {
        &quot;TableName&quot;: &quot;serverless-rest-api-with-dynamodb-dev&quot;,
        &quot;KeySchema&quot;: [
            {
                &quot;AttributeName&quot;: &quot;id&quot;,
                &quot;KeyType&quot;: &quot;HASH&quot;
            }
        ],
        &quot;AttributeDefinitions&quot;: [
            {
                &quot;AttributeName&quot;: &quot;id&quot;,
                &quot;AttributeType&quot;: &quot;S&quot;
            }
        ],
        &quot;ProvisionedThroughput&quot;: {
            &quot;ReadCapacityUnits&quot;: 1,
            &quot;WriteCapacityUnits&quot;: 1
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后，执行：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;serverless dynamodb install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;以安装 DynamnoDB 的本地版本。&lt;/p&gt;

&lt;p&gt;一切准备妥当了，我们可以进行测试了。&lt;/p&gt;

&lt;h2 id=&quot;本地测试-serverless-offline-与-dynamodb&quot;&gt;本地测试 serverless-offline 与 DynamoDB&lt;/h2&gt;

&lt;p&gt;接着，让我们用下面的命令，来运行起本地的环境：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ serverless offline start

Dynamodb Local Started, Visit: http://localhost:8000/shell
Serverless: DynamoDB - created table serverless-rest-api-with-dynamodb-dev
Serverless: Starting Offline: dev/us-east-1.

Serverless: Routes for create:
Serverless: POST /todos

Serverless: Routes for list:
Serverless: GET /todos

Serverless: Routes for get:
Serverless: GET /todos/{id}

Serverless: Routes for update:
Serverless: PUT /todos/{id}

Serverless: Routes for delete:
Serverless: DELETE /todos/{id}

Serverless: Offline listening on http://localhost:3000
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;启动的时候，发现直接报错了：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  message: 'Missing region in config',
  code: 'ConfigError',
  time: 2017-11-07T01:18:45.365Z }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;对比了官方的示例代码后，发现没有对本地调用的 DynamoDB 进行处理：&lt;/p&gt;

&lt;p&gt;让我们，新增一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;todos/dynamodb.js&lt;/code&gt; 文件：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;'use strict';

const AWS = require('aws-sdk'); // eslint-disable-line import/no-extraneous-dependencies

let options = {};

// connect to local DB if running offline
if (process.env.IS_OFFLINE) {
  options = {
    region: 'localhost',
    endpoint: 'http://localhost:8000',
  };
}

const client = new AWS.DynamoDB.DocumentClient(options);

module.exports = client;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;当我们在本地运行的时候，将使用本地的 DynamoDB，当在服务端运行的时候，则会调用真正的 DynamoDB。&lt;/p&gt;

&lt;p&gt;再去修改 &lt;code class=&quot;highlighter-rouge&quot;&gt;create.js&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;delete.js&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;get.js&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;list.js&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;update.js&lt;/code&gt; 中的：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const dynamoDb = new AWS.DynamoDB.DocumentClient();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;改为&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const dynamoDb = require('./dynamodb');
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;确认一切无误后，我们就可以使用 postman 测试：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/img/posts/2019-05-24-serverless-app-dev-guide/postman-offline-db.png&quot;&gt;&lt;img src=&quot;/assets/img/posts/2019-05-24-serverless-app-dev-guide/postman-offline-db.png&quot; alt=&quot;PostMan 测试 Serverless Offline&quot; title=&quot;查看原图&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;或者 curl：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl -X POST -H &quot;Content-Type:application/json&quot; http://localhost:3000/todos --data '{ &quot;text&quot;: &quot;Learn Serverless&quot; }'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;接着打开本地的 todos 地址：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http://localhost:3000/todos
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;就会返回类似于在线上生成的数据结果。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[{&quot;checked&quot;:false,&quot;createdAt&quot;:1510018445663,&quot;id&quot;:&quot;be15f600-c35b-11e7-8089-a5ea63a20ab5&quot;,&quot;text&quot;:&quot;Learn Serverless&quot;,&quot;updatedAt&quot;:1510018445663}]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Awesome！&lt;/p&gt;

&lt;p&gt;既然，已经有了可以在本地运行 DynamoDB，那么我们是不是可以写上几个测试呢？&lt;/p&gt;

&lt;h1 id=&quot;如何编写-serverless-应用的测试&quot;&gt;如何编写 Serverless 应用的测试&lt;/h1&gt;

&lt;p&gt;如 Serverless Framework 官方所说&lt;/p&gt;

&lt;p&gt;虽然 Serverless 架构在服务业务逻辑方面引入了很多简单性，但是它的一些特性给测试带来了挑战。他们是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Serverless 架构是独立的分布式服务的集成，它们必须被独立地和一起地测试。&lt;/li&gt;
  &lt;li&gt;Serverless 架构依赖于互联网、云服务，这些服务很难在本地模拟。&lt;/li&gt;
  &lt;li&gt;Serverless 架构可以具有事件驱动的异步工作流程，这些工作流程很难完全仿真。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因此官方建议：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;编写您的业务逻辑，使其与 FaaS 提供商（例如，AWS Lambda）分开，以保持提供者独立性，可重用性和更易于测试。&lt;/li&gt;
  &lt;li&gt;当您的业务逻辑与FaaS提供商分开编写时，您可以编写传统的单元测试以确保其正常工作。&lt;/li&gt;
  &lt;li&gt;编写集成测试以验证与其他服务的集成是否正常工作。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;serverless-应用的测试&quot;&gt;Serverless 应用的测试&lt;/h2&gt;

&lt;p&gt;在传统的测试金字塔里，我们会写更多的单元测试，并尽可能地尽少集成测试。同样的，在 Serverless 架构应用里，我们会写同样数量的单元测试，只是会写更多地集成测试，用于测试与服务间的集成。而这些测试，往往更加依赖于网络，并且这些测试越需要我们隔离架构层级。&lt;/p&gt;

&lt;p&gt;因而，这种情况下，我们需要在测试上花费更多的精力。&lt;/p&gt;

&lt;p&gt;对于单元测试来说，在之前的 &lt;a href=&quot;https://www.phodal.com/blog/serverless-development-guide-express-react-build-server-side-rendering/&quot;&gt;Express 示例&lt;/a&gt;里，我们做了一个不错的 Demo。我们隔离了 Express 与 Lambda 函数之间的代码，只需要再加上一个本地的 Express 环境，那么我们就可以直接在本地运行了。而借助于上一篇中提供的 &lt;a href=&quot;https://www.phodal.com/blog/serverless-architecture-development-serverless-offline-localhost-debug-test/&quot;&gt;serverless-offline&lt;/a&gt;，我们则可以隔离本地数据库。&lt;/p&gt;

&lt;p&gt;随后，我们需要将 Serverless 应用部署测试环境。然后运行我们的测试脚本，自动地打开浏览器，进行操作。然后验证数据库中的数据是否是正确的，而一些都依赖于网络来执行。这就意味着，我们仿佛在不断地对接第三方系统，看上去就像一场场的恶梦。好在，我们也可以在 AWS 上运行测试，至少会让网络问题变得好一些。&lt;/p&gt;

&lt;h2 id=&quot;步骤&quot;&gt;步骤&lt;/h2&gt;

&lt;p&gt;在这里，我们要用 serverless-mocha-plugin 插件，这是一个基于 Mocha 框架、用于为 Serverless Framework 的添加测试的插件。&lt;/p&gt;

&lt;p&gt;它的 Setup 过程非常简单，先添加插件：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yarn add --dev serverless-mocha-plugin
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;随后，添加到 &lt;code class=&quot;highlighter-rouge&quot;&gt;serverless.yml&lt;/code&gt; 文件中：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;plugins:
  - serverless-mocha-plugin
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;接着，我们就可以创建测试了。&lt;/p&gt;

&lt;h3 id=&quot;创建测试&quot;&gt;创建测试&lt;/h3&gt;

&lt;p&gt;除了运行测试，它还提供创建测试的命令。只需要运行命令&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sls create test -f functionName
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如，在这里我们是这样的：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sls create test -f hello

Serverless: serverless-mocha-plugin: created test/hello.js
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其文件的内容如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;'use strict';

// tests for hello
// Generated by serverless-mocha-plugin

const mochaPlugin = require('serverless-mocha-plugin');
const expect = mochaPlugin.chai.expect;
let wrapped = mochaPlugin.getWrapper('hello', '/handler.js', 'hello');

describe('hello', () =&amp;gt; {
  before((done) =&amp;gt; {
    done();
  });

  it('implement tests here', () =&amp;gt; {
    return wrapped.run({}).then((response) =&amp;gt; {
      expect(response).to.not.be.empty;
    });
  });
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果你写过 Mocha 测试的话，那么你应该能看懂上面的代码。&lt;/p&gt;

&lt;h3 id=&quot;运行测试&quot;&gt;运行测试&lt;/h3&gt;

&lt;p&gt;现在，我们就可以运行测试了，命令以以下的格式运行：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sls invoke test [--stage stage] [--region region] [-f function1] [-f function2] [...]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们也可以直接运行所有的测试：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sls invoke test


  hello
    ✓ implement tests here


  1 passing (7ms)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;更准确的测试&quot;&gt;更准确的测试&lt;/h3&gt;

&lt;p&gt;让我们再让测试有针对性一点。在 &lt;code class=&quot;highlighter-rouge&quot;&gt;handler.js&lt;/code&gt; 中，我们返回的 body 是一个字符串：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const response = {
  statusCode: 200,
  body: JSON.stringify({
    message: 'Go Serverless v1.0! Your function executed successfully!',
    input: event,
  }),
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;那么，我们就应该去测试一下相应的字符串：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;it('implement tests here', () =&amp;gt; {
  return wrapped.run({}).then((response) =&amp;gt; {
    let body = JSON.parse(response.body);
    expect(body.message).equal('Go Serverless v1.0! Your function executed successfully!');
  });
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;结论-1&quot;&gt;结论&lt;/h2&gt;

&lt;p&gt;总的来说，对于普通的单元测试来说，和一般的测试差不多。对于数据库操作什么相关的函数来说，这就是一件复杂的事。&lt;/p&gt;

&lt;h1 id=&quot;多个语言运行环境&quot;&gt;多个语言运行环境&lt;/h1&gt;

&lt;p&gt;Serverless 与微服务在一点上很吸引人，你可以采用不同的语言来运行你的代码，不同的服务之间可以使用不同的语言。除了，在不同的 Serverless 服务里，采用不同的语言来开发。我们也可以在一个 Serverless 服务里，使用不同的语言来开发服务。&lt;/p&gt;

&lt;h2 id=&quot;serverless-多个语言运行环境&quot;&gt;Serverless 多个语言运行环境&lt;/h2&gt;

&lt;p&gt;这次我们要创建的 Serverless 服务，其实现步骤相当的简单：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;使用 serverless 命令行工具，创建一个 node.js 模板&lt;/li&gt;
  &lt;li&gt;在上一步的基础上添加一个 python 的服务。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;于是，先让我们创建一个 hello, world 模板：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;serverless create --template aws-nodejs --path multiple
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后，让我们创建一个 py-handler.py 的函数，代码如下所示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import json
import datetime


def endpoint(event, context):
    current_time = datetime.datetime.now().time()
    body = {
        &quot;message&quot;: &quot;Hello, the current time is &quot; + str(current_time)
    }

    response = {
        &quot;statusCode&quot;: 200,
        &quot;body&quot;: json.dumps(body)
    }

    return response
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个函数做了一件事，便是：获取当前的时间，然后导出并返回 json。&lt;/p&gt;

&lt;p&gt;对应的，我们的 &lt;code class=&quot;highlighter-rouge&quot;&gt;serverless.yml&lt;/code&gt; 文件也只是设置了不同的 runtime：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;functions:
  pythonDemo:
    runtime: python2.7
    events:
      - http:
          method: get
          path: python
    handler: py-handler.endpoint
  jsDemo:
    runtime: nodejs6.10
    events:
      - http:
          method: get
          path: js
    handler: js-handler.hello
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在 Python 函数部分，我们使用了 python2.7 来执行相应的代码。而在 JavaScript 部分则是 Node.js 6.10。&lt;/p&gt;

&lt;h2 id=&quot;部署及测试&quot;&gt;部署及测试&lt;/h2&gt;

&lt;p&gt;如果你还没有下载代码，那么先安装服务：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm install -u https://github.com/phodal/serverless-guide/tree/master/multiple -n multiple
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后就愉快地部署吧：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ serverless deploy

Serverless: Packaging service...
Serverless: Excluding development dependencies...
Serverless: Uploading CloudFormation file to S3...
Serverless: Uploading artifacts...
Serverless: Uploading service .zip file to S3 (640 B)...
Serverless: Validating template...
Serverless: Updating Stack...
Serverless: Checking Stack update progress...
....................
Serverless: Stack update finished...
Service Information
service: multiple
stage: dev
region: us-east-1
stack: multiple-dev
api keys:
  None
endpoints:
  GET - https://ulgoy525y4.execute-api.us-east-1.amazonaws.com/dev/python
  GET - https://ulgoy525y4.execute-api.us-east-1.amazonaws.com/dev/js
functions:
  pythonDemo: multiple-dev-pythonDemo
  jsDemo: multiple-dev-jsDemo
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;针对于 js 和 python 分别有两个对应的 HTTP 结点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;https://ulgoy525y4.execute-api.us-east-1.amazonaws.com/dev/python&lt;/li&gt;
  &lt;li&gt;https://ulgoy525y4.execute-api.us-east-1.amazonaws.com/dev/js&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;访问对应的接口，就会返回对应的值，如下是 JS 返回的结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{&quot;message&quot;:&quot;Go Serverless v1.0! Your function executed successfully!&quot;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如下是 Python 函数返回的结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{&quot;message&quot;: &quot;Hello, the current time is 14:17:24.453136&quot;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;当我们可以在一个服务里，写上不同的语言，就意味着：我们可以轻松地写上几十行的服务，然后轻松地部署。&lt;/p&gt;

&lt;p&gt;对了，测试完了，记得执行 &lt;code class=&quot;highlighter-rouge&quot;&gt;serverless remove&lt;/code&gt;。&lt;/p&gt;

&lt;h1 id=&quot;serverless-开发物联网应用&quot;&gt;Serverless 开发物联网应用&lt;/h1&gt;

&lt;p&gt;原文链接：&lt;a href=&quot;https://www.phodal.com/blog/serverless-guide-development-aws-iot-serverless-example/&quot;&gt;Serverless 开发指南：AWS IoT 服务开发&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在我开发一个完整的 Serverless 应用之前，我决定尝试一下不同的 Serverless 服务。这次我打算结合一下 AWS IoT，作为我对云服务与物联网结合的探索。&lt;/p&gt;

&lt;h2 id=&quot;serverless-框架安装服务&quot;&gt;Serverless 框架安装服务&lt;/h2&gt;

&lt;p&gt;依旧的，我还将继续使用 Serverless 框架，而不是自己写 lambda 来实现。&lt;/p&gt;

&lt;p&gt;因此，首先，让我们使用官方的服务 demo，执行以下的命令，就可以在本地复制远程的 demo 到本地。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;serverless install -u https://github.com/serverless/examples/tree/master/aws-node-iot-event -n aws-iot-example
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其相当于将远程的 https://github.com/serverless/examples/tree/master/aws-node-iot-event 复制到本地的 &lt;code class=&quot;highlighter-rouge&quot;&gt;aws-iot-example&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这次我们的 &lt;code class=&quot;highlighter-rouge&quot;&gt;handler.js&lt;/code&gt; 只是打了个日志，其它什么也没做。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;'use strict';

module.exports.log = (event, context, callback) =&amp;gt; {
  console.log(event);
  callback(null, {});
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;重点还在于 &lt;code class=&quot;highlighter-rouge&quot;&gt;serverless.yml&lt;/code&gt; 文件中的配置：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;service: aws-node-iot-event

frameworkVersion: &quot;&amp;gt;=1.5.0 &amp;lt;2.0.0&quot;

provider:
  name: aws
  runtime: nodejs4.3

functions:
  log:
    handler: handler.log
    events:
      - iot:
          sql: &quot;SELECT * FROM 'mybutton'&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在这个 &lt;code class=&quot;highlighter-rouge&quot;&gt;CloudFormation&lt;/code&gt; 配置文件中，我们设置了运行配置 nodejs4.3，以及对应的 &lt;code class=&quot;highlighter-rouge&quot;&gt;handler.log&lt;/code&gt; 函数 。在 &lt;code class=&quot;highlighter-rouge&quot;&gt;events&lt;/code&gt; 里，写了一个 sql 语句来选择 &lt;code class=&quot;highlighter-rouge&quot;&gt;mybutton&lt;/code&gt; 的相关内容，即查看 mybutton 相关主题的日志。&lt;/p&gt;

&lt;h2 id=&quot;部署-aws-iot-serverless-服务&quot;&gt;部署 AWS IoT Serverless 服务&lt;/h2&gt;

&lt;p&gt;依旧的我们只需要执行 &lt;code class=&quot;highlighter-rouge&quot;&gt;serverless deploy&lt;/code&gt; 即可：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.................
Serverless: Stack update finished...
Service Information
service: aws-iot-example
stage: dev
region: us-east-1
stack: aws-iot-example-dev
api keys:
  None
endpoints:
  None
functions:
  log: aws-iot-example-dev-log
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;完成部署后， 我们就可以在 AWS Lambda 后台看到我们的相关函数：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/img/posts/2019-05-24-serverless-app-dev-guide/server-side-example.png&quot;&gt;&lt;img src=&quot;/assets/img/posts/2019-05-24-serverless-app-dev-guide/server-side-example.png&quot; alt=&quot;Serverless 控制台&quot; title=&quot;查看原图&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;然后打开 AWS IoT 控制台，进入『测试』，即 MQTT 客户端页面：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/img/posts/2019-05-24-serverless-app-dev-guide/aws-iot-mqtt-test.png&quot;&gt;&lt;img src=&quot;/assets/img/posts/2019-05-24-serverless-app-dev-guide/aws-iot-mqtt-test.png&quot; alt=&quot;AWS IoT MQTT 测试页面&quot; title=&quot;查看原图&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;接着在发布主题里，填入 &lt;code class=&quot;highlighter-rouge&quot;&gt;mybutton&lt;/code&gt;，然后输入以下的内容：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{
  &quot;message&quot;: &quot;My first IoT event&quot;,
  &quot;value&quot;: 2
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/img/posts/2019-05-24-serverless-app-dev-guide/aws-iot-mqtt-test.png&quot;&gt;&lt;img src=&quot;/assets/img/posts/2019-05-24-serverless-app-dev-guide/aws-iot-mqtt-test.png&quot; alt=&quot;AWS IoT 发布主题&quot; title=&quot;查看原图&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;查看日志&quot;&gt;查看日志&lt;/h2&gt;

&lt;p&gt;然后执行以下的命令，我们就可以查看到对应的日志：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ serverless logs --function log
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;内容如下所示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;START RequestId: 76ad40d4-bc84-11e7-885a-6182fb121f8c Version: $LATEST
2017-10-29 16:37:57.481 (+08:00)  76ad40d4-bc84-11e7-885a-6182fb121f8c  { message: 'My first IoT event', value: 2 }
END RequestId: 76ad40d4-bc84-11e7-885a-6182fb121f8c
REPORT RequestId: 76ad40d4-bc84-11e7-885a-6182fb121f8c  Duration: 68.80 ms  Billed Duration: 100 ms   Memory Size: 1024 MB  Max Memory Used: 22 MB
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果只是测试用途，可以在执行完成后执行 &lt;code class=&quot;highlighter-rouge&quot;&gt;serverless remove&lt;/code&gt; 来删除对应的服务，以减少开支。&lt;/p&gt;

&lt;h1 id=&quot;使用-warmup-插件保活避免应用冷启动&quot;&gt;使用 warmup 插件保活，避免应用冷启动&lt;/h1&gt;

&lt;p&gt;我们采用的 Serverless 底层的技术是 Lambda 计算。Lambda 计算是在调用时才运行，我们的程序不是时刻在后台运行的，当我们的 HTTP API 请求到了 API Gateway 的时候，才会开始调用我们的 Lambda 函数。这个时候，我们的应用程序才正式开发运行。从启动到运行的这段时间，就是 Lambda 函数的冷启动时间。&lt;/p&gt;

&lt;p&gt;据今年初 &lt;a href=&quot;https://blog.newrelic.com/2017/01/11/aws-lambda-cold-start-optimization/&quot;&gt;New Relic&lt;/a&gt; 的统计数据表明，Lambda 函数的冷启动时间，在 50ms~200ms 之间——幸运的是，大多部分都是在 50ms 内。&lt;/p&gt;

&lt;p&gt;除了，我们之前提到的使用&lt;a href=&quot;https://www.phodal.com/blog/serverless-development-guide-cron-scheduled-job/&quot;&gt;CRON 定时执行 Lambda 任务&lt;/a&gt;。我们还就可以试 serverless-plugin-warmup 插件。&lt;/p&gt;

&lt;h2 id=&quot;使用-serverless-plugin-warmup-保持唤醒&quot;&gt;使用 serverless-plugin-warmup 保持唤醒&lt;/h2&gt;

&lt;p&gt;首先，让我们添加 &lt;code class=&quot;highlighter-rouge&quot;&gt;serverless-plugin-warmup&lt;/code&gt; 插件：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm install serverless-plugin-warmup --save-dev
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后，将插件添加到 &lt;code class=&quot;highlighter-rouge&quot;&gt;serverless.yml&lt;/code&gt; 中：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;plugins:
  - serverless-plugin-warmup
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;接着添加对应的 &lt;code class=&quot;highlighter-rouge&quot;&gt;warmup&lt;/code&gt; 属性：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;functions:
  hello:
    warmup: true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;也可以设置成只在生产环境运行：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;functions:
  hello:
    warmup:
      - production
      - staging
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;添加对应的 role 和权限&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
provider:
  name: aws
  runtime: nodejs6.10
  iamRoleStatements:
    - Effect: 'Allow'
      Action:
        - 'lambda:InvokeFunction'
      Resource:
      - Fn::Join:
        - ':'
        - - arn:aws:lambda
          - Ref: AWS::Region
          - Ref: AWS::AccountId
          - function:${self:service}-${opt:stage, self:provider.stage}-*
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;接着，在我们的响应里添加一个处理函数：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  /** Immediate response for WarmUP plugin */
  if (event.source === 'serverless-plugin-warmup') {
    console.log('WarmUP - Lambda is warm!')
    return callback(null, 'Lambda is warm!')
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;步骤上可能有些麻烦，现在也差不多了。&lt;/p&gt;

&lt;h2 id=&quot;部署及测试-1&quot;&gt;部署及测试&lt;/h2&gt;

&lt;p&gt;下面就可以部署了：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ serverless deploy

..............................
Serverless: Stack update finished...
Service Information
service: warmup
stage: dev
region: us-east-1
stack: warmup-dev
api keys:
  None
endpoints:
  None
functions:
  hello: warmup-dev-hello
  warmUpPlugin: warmup-dev-warmUpPlugin
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;等个十几分钟，就可以看到日志：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;START RequestId: 94e89a8f-c820-11e7-bc6a-d3e2ee9afad9 Version: $LATEST
2017-11-13 11:13:12.382 (+08:00)  94e89a8f-c820-11e7-bc6a-d3e2ee9afad9  WarmUP - Lambda is warm!
END RequestId: 94e89a8f-c820-11e7-bc6a-d3e2ee9afad9
REPORT RequestId: 94e89a8f-c820-11e7-bc6a-d3e2ee9afad9  Duration: 3.14 ms Billed Duration: 100 ms   Memory Size: 1024 MB  Max Memory Used: 20 MB

START RequestId: 468dbf48-c821-11e7-9753-29196147d2a5 Version: $LATEST
2017-11-13 11:18:10.224 (+08:00)  468dbf48-c821-11e7-9753-29196147d2a5  WarmUP - Lambda is warm!
END RequestId: 468dbf48-c821-11e7-9753-29196147d2a5
REPORT RequestId: 468dbf48-c821-11e7-9753-29196147d2a5  Duration: 0.80 ms Billed Duration: 100 ms   Memory Size: 1024 MB  Max Memory Used: 20 MB
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个时候，我们的应用程序一直在运行，因此我们需要考虑的一个问题是：费用。该插件在官方上，帮我们算了一下钱：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;WarmUP: runs 8640 times per month = $0.18
10 warm lambdas: each invoked 8640 times per month = $14.4
Total = $14.58&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;一个唤醒函数，一个月才 0.18 刀，想想觉得还是可以的。&lt;/p&gt;

&lt;p&gt;当然，它还可以自定义参数：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;custom:
  warmup:
    cleanFolder: false,
    memorySize: 256
    name: 'make-them-pop'
    schedule: 'cron(0/5 8-17 ? * MON-FRI *)' // Run WarmUP every 5 minutes Mon-Fri between 8:00am and 5:55pm (UTC)
    timeout: 20
    prewarm: true // Run WarmUp immediately after a deployment
    folderName: '_warmup' // Name of the folder created for the generated warmup lambda
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;结论-2&quot;&gt;结论&lt;/h2&gt;

&lt;p&gt;有了这个插件，我们就可以在用户活跃的时间里，如白天，让 Lambda 函数保活。在用户不活跃的时间里，我们就可以连这点钱也省下。&lt;/p&gt;

&lt;h1 id=&quot;定时执行任务&quot;&gt;定时执行任务&lt;/h1&gt;

&lt;p&gt;原文链接：&lt;a href=&quot;https://www.phodal.com/blog/serverless-development-guide-cron-scheduled-job/&quot;&gt;Serverless 应用开发指南：CRON 定时执行 Lambda 任务&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在上一篇文章《&lt;a href=&quot;https://www.phodal.com/blog/serverless-development-guide-create-github-hooks/&quot;&gt;Serverless 应用开发指南：基于 Serverless 的 GitHub Webhook&lt;/a&gt;》里，我们介绍了如何用 Webhook 来触发定时的 Lambda 函数。这种方式与我们平时的 CI（持续集成）服务器相似，而CI（持续集成）服务器除了会监听 PUSH 事件。还会执行一些定时的任务，比如说每日构建出二进制包，用于 RELEASE。&lt;/p&gt;

&lt;p&gt;因此，在这篇文章里，我将简单地介绍一下：如何定时触发 Lambda 任务。&lt;/p&gt;

&lt;h2 id=&quot;serverless-定时任务&quot;&gt;Serverless 定时任务&lt;/h2&gt;

&lt;p&gt;幸运的是，带着我的想法，我在官网上看到了一个相关的事例。&lt;/p&gt;

&lt;p&gt;于是，让我们安装一下这个服务到本地：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ serverless install -u https://github.com/serverless/examples/tree/master/aws-node-scheduled-cron -n scheduled-cron
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;rate-表达式&quot;&gt;rate 表达式&lt;/h3&gt;

&lt;p&gt;主要的定时代码写在 &lt;code class=&quot;highlighter-rouge&quot;&gt;serverless.yml&lt;/code&gt; 文件中，如下所示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;functions:
  cron:
    handler: handler.run
    events:
      # Invoke Lambda function every minute
      - schedule: rate(1 minute)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;AWS 支持两种类型的定时任务 &lt;code class=&quot;highlighter-rouge&quot;&gt;rate&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;cron&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;Rate 表达式在创建计划事件规则时启动，然后按照其定义的计划运行。Rate 表达式有两个必需字段。这些字段用空格分隔。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rate(value unit)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;相应的值表示如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;value，正数（ &amp;gt;0 的数）。&lt;/li&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;unit，时间单位。其有效值：minute&lt;/td&gt;
          &lt;td&gt;minutes&lt;/td&gt;
          &lt;td&gt;hour&lt;/td&gt;
          &lt;td&gt;hours&lt;/td&gt;
          &lt;td&gt;day&lt;/td&gt;
          &lt;td&gt;days&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因此，上面的代码 &lt;code class=&quot;highlighter-rouge&quot;&gt;rate(1 minute)&lt;/code&gt; 表示的是每一分钟执行一次。&lt;/p&gt;

&lt;h3 id=&quot;cron-表达式&quot;&gt;cron 表达式&lt;/h3&gt;

&lt;p&gt;下面的代码，则使用的是 cron 表达式&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  secondCron:
    handler: handler.run
    events:
      # Invoke Lambda function every 2nd minute from Mon-Fri
      - schedule: cron(0/2 * ? * MON-FRI *)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;cron 表达式的格式稍微复杂一些。但是它与 Linux 上的 cron 是不太一样的：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cron(&amp;lt;分钟&amp;gt; &amp;lt;小时&amp;gt; &amp;lt;日期&amp;gt; &amp;lt;月份&amp;gt; &amp;lt;星期&amp;gt; &amp;lt;年代&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;对应于下表：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;字段&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;值&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;通配符&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;分钟&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0-59&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;, - * /&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;小时&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0-23&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;, - * /&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;日期&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1-31&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;, - * ? / L W&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;月&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1-12 or JAN-DEC&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;, - * /&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;星期几&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1-7 or SUN-SAT&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;, - * ? / L #&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;年代&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1970-2199&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;, - * /&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;更详细的信息，可以阅读官方的文档：&lt;a href=&quot;http://docs.aws.amazon.com/zh_cn/AmazonCloudWatch/latest/events/ScheduledEvents.html&quot;&gt;规则的计划表达式&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;于是，上面的表达式，每星期一到星期五（MON-FRI），每 2 分钟运行一次。&lt;/p&gt;

&lt;h2 id=&quot;部署-1&quot;&gt;部署&lt;/h2&gt;

&lt;p&gt;接下来，让我们部署代码试试：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ serverless deploy
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;相应的部署过程日志如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...............
Serverless: Stack update finished...
Service Information
service: scheduled-cron
stage: dev
region: us-east-1
stack: scheduled-cron-dev
api keys:
  None
endpoints:
  None
functions:
  cron: scheduled-cron-dev-cron
  secondCron: scheduled-cron-dev-secondCron
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后，让我们看看日志：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ serverless logs -f  cron -t
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;对应的日志如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;2017-11-01 16:41:14.112 (+08:00)  6b33ad33-bee0-11e7-9439-23daa7bb59a8  Your cron function &quot;scheduled-cron-dev-cron&quot; ran at Wed Nov 01 2017 08:41:14 GMT+0000 (UTC)
END RequestId: 6b33ad33-bee0-11e7-9439-23daa7bb59a8
REPORT RequestId: 6b33ad33-bee0-11e7-9439-23daa7bb59a8  Duration: 0.86 ms Billed Duration: 100 ms   Memory Size: 1024 MB  Max Memory Used: 20 MB

START RequestId: 8ea1a80f-bee0-11e7-a0c9-331175998dc2 Version: $LATEST
2017-11-01 16:42:13.724 (+08:00)  8ea1a80f-bee0-11e7-a0c9-331175998dc2  Your cron function &quot;scheduled-cron-dev-cron&quot; ran at Wed Nov 01 2017 08:42:13 GMT+0000 (UTC)
END RequestId: 8ea1a80f-bee0-11e7-a0c9-331175998dc2
REPORT RequestId: 8ea1a80f-bee0-11e7-a0c9-331175998dc2  Duration: 4.08 ms Billed Duration: 100 ms   Memory Size: 1024 MB  Max Memory Used: 20 MB
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这表明我们的程序，正在以每分钟的状态运行着。&lt;/p&gt;

&lt;p&gt;当我们想做一个 Serverless 的爬虫定期执行某个任务，这样做可以帮我们节省大量的成本。&lt;/p&gt;

&lt;p&gt;末了，记得执行：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ serverless remove
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;使用-simulate-插件在本地运行-lambda&quot;&gt;使用 Simulate 插件在本地运行 Lambda&lt;/h1&gt;

&lt;p&gt;Serverless 应用的一个不方便之处：缺少一个本地的调试环境。在之前的那篇《&lt;a href=&quot;https://www.phodal.com/blog/serverless-architecture-development-serverless-offline-localhost-debug-test/&quot;&gt;Serverless 架构应用开发：使用 serverless-offline 在本地部署与调试&lt;/a&gt;》中， 我们提到了使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;serverless-offline&lt;/code&gt; 插件来在本地部署和调试。在本文中，我们将介绍 &lt;code class=&quot;highlighter-rouge&quot;&gt;serverless-plugin-simulate&lt;/code&gt; 插件来解决相似的问题。&lt;/p&gt;

&lt;h2 id=&quot;serverless-plugin-simulate-插件&quot;&gt;serverless-plugin-simulate 插件&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;serverless-plugin-simulate&lt;/code&gt; 是一个的概念证明，用来尝试使用 docker 镜像复制 Amazon API Gateway 来运行lambda。&lt;/p&gt;

&lt;p&gt;它可以支持以下的功能：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;由 docker-lambda 支持的 λ 运行时环境。&lt;/li&gt;
  &lt;li&gt;CORS&lt;/li&gt;
  &lt;li&gt;授权
    &lt;ul&gt;
      &lt;li&gt;自定义授权者（支持）&lt;/li&gt;
      &lt;li&gt;Coginito 授权（暂不支持）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Lambda集成
    &lt;ul&gt;
      &lt;li&gt;Velocity 模板（支持）。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Lambda代理集成（支持的）。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;那么，让我们来试试使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;serverless-plugin-simulate&lt;/code&gt; 插件来模拟 Lambda 环境。&lt;/p&gt;

&lt;h2 id=&quot;安装-serverless-plugin-simulate-及环境&quot;&gt;安装 serverless-plugin-simulate 及环境&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;注意&lt;/code&gt;：由于这里需要使用 Docker，建议读者先行安装  Docker。&lt;/p&gt;

&lt;p&gt;然后，让我们来创建 Serverless 应用：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;serverless create --template aws-nodejs --path simulate-lambda
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;接着，就可以安装 serverless-plugin-simulate 插件了&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yarn add --dev serverless-plugin-simulate
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后，添加到 &lt;code class=&quot;highlighter-rouge&quot;&gt;serverless.yml&lt;/code&gt; 中：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;plugins:
  - serverless-plugin-simulate


custom:
  simulate:
    services: docker-compose.yml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面的配置中依赖于 &lt;code class=&quot;highlighter-rouge&quot;&gt;docker-compose.yml&lt;/code&gt; 文件，创建、然后输入：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;version: '2'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;保存，并退出。&lt;/p&gt;

&lt;p&gt;紧接着，运行：&lt;code class=&quot;highlighter-rouge&quot;&gt;docker pull lambci/lambda&lt;/code&gt;。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ docker pull lambci/lambda

Using default tag: latest
latest: Pulling from lambci/lambda
5aed7bd8313c: Pull complete
d60049111ce7: Pull complete
7791f7ad5cf2: Pull complete
Digest: sha256:4d511dfc1a264ccc69081ceb00116dd0bea380080ad1e89c2f48752f6c4670df
Status: Downloaded newer image for lambci/lambda:latest
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;它将从服务端下载 lambci 的 lambda 镜像。&lt;/p&gt;

&lt;h2 id=&quot;运行及测试&quot;&gt;运行及测试&lt;/h2&gt;

&lt;p&gt;然后运行 simlaute&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sls simulate apigateway -p 5000

Serverless: Starting mock services.
Serverless:
Serverless: [GET /undefined] =&amp;gt; λ:hello
Serverless: Invoke URL: http://localhost:5000
Serverless: HTTP Event Not Found: Try checking your serverless.yml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;发现少了一个入口，于是在 &lt;code class=&quot;highlighter-rouge&quot;&gt;serverless.yml&lt;/code&gt; 中添加了路径&lt;/p&gt;

&lt;p&gt;于是：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
functions:
  hello:
    handler: handler.hello
    events:
      - http:
          method: get
          path: hello
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;接着再次运行，然后访问：&lt;a href=&quot;http://localhost:5000/hello&quot;&gt;http://localhost:5000/hello&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ npm start

&amp;gt; simulate@1.0.0 start /Users/fdhuang/learing/serverless-guide/simulate
&amp;gt; sls simulate apigateway -p 5000

Serverless: Starting mock services.
Serverless:
Serverless: [GET /hello] =&amp;gt; λ:hello
Serverless: Invoke URL: http://localhost:5000
Serverless: Creating event
Serverless: Invoking hello
Serverless: Invoking function handler.hello
START RequestId: 18b5b89b-7118-1344-7f1e-a3b49c5c26d4 Version: $LATEST
END RequestId: 18b5b89b-7118-1344-7f1e-a3b49c5c26d4
REPORT RequestId: 18b5b89b-7118-1344-7f1e-a3b49c5c26d4	Duration: 6.27 ms	Billed Duration: 100 ms	Memory Size: 1024 MB	Max Memory Used: 28 MB

{&quot;statusCode&quot;:200,&quot;body&quot;:&quot;{\&quot;message\&quot;:\&quot;Go Serverless v1.0! Your function executed successfully!\&quot;,\&quot;input\&quot;:{\&quot;path\&quot;:\&quot;/hello\&quot;,\&quot;headers\&quot;:{\&quot;host\&quot;:\&quot;localhost:5000\&quot;,\&quot;connection\&quot;:\&quot;keep-alive\&quot;,\&quot;cache-control\&quot;:\&quot;max-age=0\&quot;,\&quot;user-agent\&quot;:\&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.100 Safari/537.36\&quot;,\&quot;upgrade-insecure-requests\&quot;:\&quot;1\&quot;,\&quot;accept\&quot;:\&quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\&quot;,\&quot;dnt\&quot;:\&quot;1\&quot;,\&quot;accept-encoding\&quot;:\&quot;gzip, deflate, br\&quot;,\&quot;accept-language\&quot;:\&quot;zh-CN,zh;q=0.8,en-GB;q=0.6,en;q=0.4,it;q=0.2,zh-TW;q=0.2,ja;q=0.2\&quot;,\&quot;cookie\&quot;:\&quot;mezzanine-rating=\\\&quot;\\\\054blog.blogpost.20\\\\054blog.blogpost.13\\\\054blog.blogpost.5\\\\054blog.blogpost.19\\\\054blog.blogpost.21\\\\054blog.blogpost.9\\\&quot;; csrftoken=A9i99HpofF4q19ehVQY4D8w0cRwddlnSwbz4DUQV0yqax3cufTN8Np5gzldqkotH; _ga=GA1.1.427084651.1503497781\&quot;,\&quot;if-none-match\&quot;:\&quot;W/\\\&quot;6a9-Sps0n/Pmo7hiZsErZVJqVbiAPPk\\\&quot;\&quot;},\&quot;pathParameters\&quot;:{},\&quot;requestContext\&quot;:{\&quot;accountId\&quot;:\&quot;localContext_accountId\&quot;,\&quot;resourceId\&quot;:\&quot;localContext_resourceId\&quot;,\&quot;stage\&quot;:\&quot;dev\&quot;,\&quot;requestId\&quot;:\&quot;localContext_requestId_30305881537279267\&quot;,\&quot;identity\&quot;:{\&quot;cognitoIdentityPoolId\&quot;:\&quot;localContext_cognitoIdentityPoolId\&quot;,\&quot;accountId\&quot;:\&quot;localContext_accountId\&quot;,\&quot;cognitoIdentityId\&quot;:\&quot;localContext_cognitoIdentityId\&quot;,\&quot;caller\&quot;:\&quot;localContext_caller\&quot;,\&quot;apiKey\&quot;:\&quot;localContext_apiKey\&quot;,\&quot;sourceIp\&quot;:\&quot;::ffff:127.0.0.1\&quot;,\&quot;cognitoAuthenticationType\&quot;:\&quot;localContext_cognitoAuthenticationType\&quot;,\&quot;cognitoAuthenticationProvider\&quot;:\&quot;localContext_cognitoAuthenticationProvider\&quot;,\&quot;userArn\&quot;:\&quot;localContext_userArn\&quot;,\&quot;userAgent\&quot;:\&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.100 Safari/537.36\&quot;,\&quot;user\&quot;:\&quot;localContext_user\&quot;}},\&quot;resource\&quot;:\&quot;localContext_resource\&quot;,\&quot;httpMethod\&quot;:\&quot;GET\&quot;,\&quot;queryStringParameters\&quot;:{},\&quot;body\&quot;:\&quot;{}\&quot;,\&quot;stageVariables\&quot;:{}}}&quot;}
Serverless: Mapping response
GET /hello 200 1518.527 ms - 1802
Serverless: HTTP Event Not Found: Try checking your serverless.yml
GET /favicon.ico 403 1.084 ms - 23
HTTP Event Not Found: Try checking your serverless.yml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;就可以得到类似于生产环境的 Lambda 函数的结果。&lt;/p&gt;

&lt;h1 id=&quot;使用-graphql-实现更好的-api&quot;&gt;使用 GraphQL 实现更好的 API&lt;/h1&gt;

&lt;p&gt;AWS Lambda 上可以运行不同的语言，提供不同语言的运行环境。这也就意味着，它不仅可以&lt;a href=&quot;https://www.phodal.com/blog/serverless-developement-gui-lambda-api-gateway-dynamodb-create-restful-services/&quot;&gt;跑 Express 来提供一个 RESTful API&lt;/a&gt;，它也可以运行各式各样的 Node.js 库，比如说 GraphQL。&lt;/p&gt;

&lt;p&gt;GraphQL是一种API查询语言，是一个对自定义类型系统执行查询的服务端运行环境。我们可以编写一个使用 GraphQL 编写一个查询：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{
  me {
    name
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;以此来，获取我们想到的 JSON 结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{
  &quot;me&quot;: {
    &quot;name&quot;: &quot;Luke Skywalker&quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;它看上更像是一层 BFF 层，在前端和后台之间，提供一个更适合于前端使用的接口。&lt;/p&gt;

&lt;h2 id=&quot;graphql-hello-world&quot;&gt;GraphQL hello, world&lt;/h2&gt;

&lt;p&gt;现在，让我们愉快地开始我们的学习之旅吧。&lt;/p&gt;

&lt;p&gt;首先，让我们创建我们的应用：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;serverless create --template aws-nodejs --path graphql
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后添加 &lt;code class=&quot;highlighter-rouge&quot;&gt;graphql&lt;/code&gt; 库：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yarn add graphql
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;接着，根据 GraqhQL.js 在 GitHub 的示例，编写我们的 &lt;code class=&quot;highlighter-rouge&quot;&gt;handler.js&lt;/code&gt;：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/* handler.js */
const {
  graphql,
  GraphQLSchema,
  GraphQLObjectType,
  GraphQLString,
  GraphQLNonNull
} = require('graphql')

const schema = new GraphQLSchema({
  query: new GraphQLObjectType({
    name: 'RootQueryType',
    fields: {
      hello: {
        type: GraphQLString,
        resolve() {
          return 'world';
        }
      }
    }
  }),
})

module.exports.query = (event, context, callback) =&amp;gt; {
  console.log(event.queryStringParameters, event.queryStringParameters.query)
  return graphql(schema, event.queryStringParameters.query)
  .then(
    result =&amp;gt; callback(null, {statusCode: 200, body: JSON.stringify(result)}),
    err =&amp;gt; callback(err)
  )
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码分为了两部分，第一部分是创建了一个 GraphQL 的 Schema；第二部分则是对应的查询代码。在查询部分，我们取出 Lambda 事件中的 queryStringParameters，然后其中的查询代码。接着，由 graphql 执行对应的查询。&lt;/p&gt;

&lt;p&gt;然后，配置一下我们的 &lt;code class=&quot;highlighter-rouge&quot;&gt;serverless.yml&lt;/code&gt;：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
functions:
  query:
    handler: handler.query
    events:
      - http:
          path: query
          method: get
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;并部署代码到服务器上:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;service: graphql
stage: dev
region: us-east-1
stack: graphql-dev
api keys:
  None
endpoints:
  GET - https://5ol2v4lnx3.execute-api.us-east-1.amazonaws.com/dev/query
functions:
  query: graphql-dev-query
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;现在让我们发起一次查询：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ curl -G https://5ol2v4lnx3.execute-api.us-east-1.amazonaws.com/dev/query --data-urlencode 'query={ hello }'


{&quot;data&quot;:{&quot;hello&quot;:&quot;world&quot;}}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;显然，我们的 hello, world 是成功的。&lt;/p&gt;

&lt;h2 id=&quot;更复杂的示例&quot;&gt;更复杂的示例&lt;/h2&gt;

&lt;p&gt;接着，让我们看一个更复杂的示例。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;一个 GraphQL 查询可以包含一个或者多个操作（operation），类似于一个RESTful API。操作（operation）可以使两种类型：查询（Query）或者修改（mutation）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这意味着，我们还能使用 GraphQL 对相应的数据进行操作。在这里，我们可以直接使用官方的 DEMO，先安装它：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;serverless install -u https://github.com/serverless/examples/tree/master/aws-node-graphql-api-with-dynamodb -n graphql-dynamodb
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后，部署：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ serverless deploy

...
stack: graphql-dynamodb-dev
api keys:
  None
endpoints:
  GET - https://jzlqq3fgfd.execute-api.us-east-1.amazonaws.com/dev/query
functions:
  query: graphql-dynamodb-dev-query
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;接着编写一个查询的请求：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ curl -G 'https://jzlqq3fgfd.execute-api.us-east-1.amazonaws.com/dev/query' --data-urlencode 'query={greeting(firstName: &quot;world&quot;)}'

{&quot;data&quot;:{&quot;greeting&quot;:&quot;Hello, world.&quot;}}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;尝试使用 mutation 来修改内容：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ curl -G 'https://jzlqq3fgfd.execute-api.us-east-1.amazonaws.com/dev/query' --data-urlencode 'query=mutation {changeNickname(firstName: &quot;world&quot;, nickname: &quot;phodal&quot;)}'

{&quot;data&quot;:{&quot;changeNickname&quot;:&quot;phodal&quot;}}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;再次查询看相应的内容是否有修改：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ curl -G 'https://jzlqq3fgfd.execute-api.us-east-1.amazonaws.com/dev/query' --data-urlencode 'query={greeting(firstName: &quot;world&quot;)}'

{&quot;data&quot;:{&quot;greeting&quot;:&quot;Hello, phodal.&quot;}}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后，让我们来看看对应的修改逻辑。&lt;/p&gt;

&lt;h3 id=&quot;graphql-修改-dymanodb-的值&quot;&gt;GraphQL 修改 DymanoDB 的值&lt;/h3&gt;

&lt;p&gt;先看看新的 schema：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const schema = new GraphQLSchema({
  query: new GraphQLObjectType({
    ...
    }),
  mutation: new GraphQLObjectType({
    name: 'RootMutationType', // an arbitrary name
    fields: {
      changeNickname: {
        args: {
          firstName: { name: 'firstName', type: new GraphQLNonNull(GraphQLString) },
          nickname: { name: 'nickname', type: new GraphQLNonNull(GraphQLString) },
        },
        type: GraphQLString,
        resolve: (parent, args) =&amp;gt; changeNickname(args.firstName, args.nickname),
      },
    },
  })
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在新的 schema 中定义了一个 mutation，在这个 mutation 对象里，我们通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;resolve&lt;/code&gt; 来调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;changeNickname&lt;/code&gt; 方法来处理数据库：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const changeNickname = (firstName, nickname) =&amp;gt; promisify(callback =&amp;gt;
  dynamoDb.update({
    TableName: process.env.DYNAMODB_TABLE,
    Key: { firstName },
    UpdateExpression: 'SET nickname = :nickname',
    ExpressionAttributeValues: {
      ':nickname': nickname,
    },
  }, callback))
  .then(() =&amp;gt; nickname);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们从通过原有的 name 作为 Key 查找，然后替换其中的 nickname 的值。&lt;/p&gt;

&lt;p&gt;有了这个 DEMO，就意味着，未来我们可以轻松地在我们所有的 RESTful API 前加上这一层，来提供一个 BFF 层。&lt;/p&gt;

&lt;h1 id=&quot;serverless-应用示例前端错误日志及事件收集系统&quot;&gt;Serverless 应用示例：前端错误日志及事件收集系统&lt;/h1&gt;

&lt;p&gt;最近在交接项目，也因此有了一些时间。之前想过做一个前端的错误日志系统，便想着直接用 Serverlss 做了好了。&lt;/p&gt;

&lt;p&gt;开始之前先让我简单地介绍一下：&lt;a href=&quot;https://github.com/phodal/molog&quot;&gt;https://github.com/phodal/molog&lt;/a&gt;，以便于了解我们的需求及功能。&lt;/p&gt;

&lt;h2 id=&quot;molog-使用&quot;&gt;Molog 使用&lt;/h2&gt;

&lt;p&gt;先让我们看看最后要怎么用，在网页上引入：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;script data-component=&quot;homepage&quot; data-env=&quot;dev&quot; src=&quot;//static.pho.im/molog.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;顾名思义，其中的 component 针对的不是不同组件的名字，而 env 便是具体的环境。&lt;/p&gt;

&lt;p&gt;前端的代码是基于 sherlog.js，因此在事件上也是差不多的：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Molog.push({field: 'xxx', action:' '}, function() { })
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;serverless-错误收集系统架构设计&quot;&gt;Serverless 错误收集系统架构设计&lt;/h2&gt;

&lt;p&gt;在之前的文章中，我们讨论过错误日志收集是一个很好的 Serverless 应用使用场景。&lt;/p&gt;

&lt;h3 id=&quot;架构设计&quot;&gt;架构设计&lt;/h3&gt;

&lt;p&gt;事实上，这样的系统很简单：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/img/posts/2019-05-24-serverless-app-dev-guide/molog-architecture.png&quot;&gt;&lt;img src=&quot;/assets/img/posts/2019-05-24-serverless-app-dev-guide/molog-architecture.png&quot; alt=&quot;系统架构图&quot; title=&quot;查看原图&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;1.&lt;strong&gt;前端通过 window.onerror 来捕获错误日志&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;window.onerror = function(message, source, lineno, colno, error) {
 ... 
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;然后将错误日志发给 AWS Lambda 来处理&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;AWS Lambda 将数据存储到 AWS DynamoDB 数据库里&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;当用户打开后台时，从 AWS DynamoDB 获取相应的数据&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;前端的静态文件，通过 S3 + Cloudfront 作为 CDN 来分发前端资源&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;molog-系统实现&quot;&gt;Molog 系统实现&lt;/h2&gt;

&lt;h3 id=&quot;1-存储日志和事件&quot;&gt;1. 存储日志和事件&lt;/h3&gt;

&lt;p&gt;要在 AWS 上实际这样的系统，就便得很简单了。我们只需要存储一下这些数据即可，相关的存储逻辑如下所示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  const params = {
    TableName: process.env.DYNAMODB_TABLE,
    Item: {
      id: uuid.v1(),
      data: JSON.stringify(event.queryStringParameters),
      env: env,
      component: component,
      createdAt: timestamp
    },
  };
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里的 &lt;code class=&quot;highlighter-rouge&quot;&gt;env&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;component&lt;/code&gt; 是在 script 标签中遍历解析出来的：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;env: function() {
  var s = doc.getElementsByTagName('script')
    , env;
  for( var i = 0, l = s.length; i &amp;lt; l; i++) {
    if (s[i].src.indexOf('molog') &amp;gt; -1) {
      env = s[i].getAttribute('data-env');
      break;
    }
  }
  this.env = env || '';
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后，再将这个 URL 放置到 POST 的 URL 中，即 &lt;code class=&quot;highlighter-rouge&quot;&gt;serverless.yml&lt;/code&gt; 的配置文件中：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
functions:
  create:
    handler: create/index.handler
    events:
      - http:
          path: /{component}/{env}/
          method: get
          cors: true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;从 URL 中获取这些相关的参数&lt;/p&gt;

&lt;h3 id=&quot;2-读取日志&quot;&gt;2. 读取日志&lt;/h3&gt;

&lt;p&gt;有了上面的基础，有读取日志也很简单，首先配置好 URL：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  list:
    handler: list/index.list
    events:
      - http:
          path: /{component}/{env}/logs
          method: get
          cors: true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后从数据库中获取这些结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  const params = {
    TableName: process.env.DYNAMODB_TABLE,
    FilterExpression: 'env = :env and component = :component',
    ExpressionAttributeValues: {
      ':env': env,
      ':component': component,
    }
  };
  dynamoDb.scan(params, (error, result) =&amp;gt; {

    const response = {
      statusCode: 200,
      headers: {
        &quot;Access-Control-Allow-Origin&quot; : &quot;*&quot; // Required for CORS support to work
      },
      body: JSON.stringify(result.Items),
    };
    callback(null, response);
  });
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这样就可以得到相关的日志了。&lt;/p&gt;

&lt;h2 id=&quot;问题&quot;&gt;问题&lt;/h2&gt;

&lt;p&gt;就这么简单，发现由于  CloudFront 在国内有点水土不服，并且提供压缩的功能，导致加载速度有点慢。&lt;/p&gt;

&lt;h1 id=&quot;serverless-应用示例二维码生成&quot;&gt;Serverless 应用示例：二维码生成&lt;/h1&gt;

&lt;p&gt;昨天看到了一篇关于二维码使用的文章，其设计初衷是使用二维码卡片来帮助小朋友控制智能音箱。即在 Raspberry Pi 上使用摄像头来识别二维码，二维码卡片上是一些简单的操作，如播放音乐、暂停等等，卡片的另外一面则是相应的解释。这是一个有趣的二维码在物联网应用的场景。&lt;/p&gt;

&lt;p&gt;于是乎，我便想尝试一下直接在云端生成二维码图片，并保存。当然了，对于二维码来说，直接在浏览器上生成显然是更加简单友好的。&lt;/p&gt;

&lt;h2 id=&quot;总览&quot;&gt;总览&lt;/h2&gt;

&lt;p&gt;在这个项目里，我们的主要流程是：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;从 URL 中获取要生成的二维码字符串&lt;/li&gt;
  &lt;li&gt;将生成的二维码图片上传到 AWS S3&lt;/li&gt;
  &lt;li&gt;重定向 URL 到生成的 AWS S3 上&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;对，就是这么简单，实现起来也很简单。&lt;/p&gt;

&lt;h2 id=&quot;生成应用&quot;&gt;生成应用&lt;/h2&gt;

&lt;p&gt;照例我们需要先安装有 &lt;code class=&quot;highlighter-rouge&quot;&gt;serverless&lt;/code&gt;，如果没有的话，请使用：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm install -g serverless
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后来创建我们的应用：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;serverless create --template aws-nodejs --path qrcode
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;愉快地进行我们的 init commmit。&lt;/p&gt;

&lt;h2 id=&quot;配置资源&quot;&gt;配置资源&lt;/h2&gt;

&lt;p&gt;在这个项目里，我们所需要的 AWS 资源有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;AWS S3 用于存储图片&lt;/li&gt;
  &lt;li&gt;Route 53 用于分配路由&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;那么，接下来就是打开 &lt;code class=&quot;highlighter-rouge&quot;&gt;serverless.yml&lt;/code&gt; 文件进行配置。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;resources:
  Resources:
    PackageStorage:
      Type: AWS::S3::Bucket
      Properties:
        AccessControl: PublicRead
        BucketName: ${self:custom.qrcodeBucket}
        LifecycleConfiguration:
          Rules:
            - ExpirationInDays: 1
              Status: Enabled
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;以及配置，相应的权限：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;provider:
  name: aws
  runtime: nodejs6.10
  iamRoleStatements:
    - Effect: &quot;Allow&quot;
      Action:
        - &quot;s3:ListBucket&quot;
        - &quot;s3:PutObject&quot;
        - &quot;s3:PutObjectAcl&quot;
      Resource:
        - &quot;arn:aws:s3:::${self:custom.qrcodeBucket}&quot;
        - &quot;arn:aws:s3:::${self:custom.qrcodeBucket}/*&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;还有 Route 53 中的域名：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;plugins:
  - serverless-domain-manager

custom:
  # change this, so it's unique for your setup
  qrcodeBucket: ${self:service}.${self:provider.stage,opt:stage}
  stageVariables:
    bucketName: ${self:custom.qrcodeBucket}
  customDomain:
    domainName: qrcode.pho.im
    basePath: ''
    stage: ${self:provider.stage}
    createRoute53Record: true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;接下来，就可以愉快地写代码了。&lt;/p&gt;

&lt;h2 id=&quot;生成二维码&quot;&gt;生成二维码&lt;/h2&gt;

&lt;p&gt;为了生成二维码，我找到了项目：&lt;a href=&quot;https://github.com/soldair/node-qrcode&quot;&gt;node-qrcode&lt;/a&gt;，然后安装之：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yarn add qrcode
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;试了试 DEMO：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;QRCode.toFile('path/to/filename.png', 'Some text', {
  color: {
    dark: '#00F',  // Blue dots
    light: '#0000' // Transparent background
  }
}, function (err) {
  if (err) throw err
  console.log('done')
})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;不对，这样好像有问题：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  QRCode.toDataURL(string, {
    errorCorrectionLevel: 'H'
  }, function (err, url) {

  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在尝试了多次之后，我手动将 base64 转成了 png：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;new Buffer(url.replace(/^data:image\/\w+;base64,/, &quot;&quot;), 'base64')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;随后，就可以上传图片了 AWS S3 上。&lt;/p&gt;

&lt;h2 id=&quot;上传-aws-s3&quot;&gt;上传 AWS S3&lt;/h2&gt;

&lt;p&gt;只需要配置好相应的权限和 Key、Bucket，然后使用 ContentEncoding 为 base64：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const params = {
  Bucket: process.env.bucketName,
  Key: key,
  ACL: 'public-read',
  Body: new Buffer(url.replace(/^data:image\/\w+;base64,/, &quot;&quot;), 'base64'),
  ContentEncoding: 'base64',
  ContentType: 'image/png'
};

s3.putObject(params, function (err, data) {
  if (err) {
    return callback(new Error(`Failed to put s3 object: ${err}`));
  }

  const response = {
    statusCode: 302,
    headers: {
      location: `https://s3.amazonaws.com/${process.env.bucketName}/${key}`
    }
  };

  return callback(null, response);
})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;将 ACL 配置为 public-read，就可以在外网访问了。&lt;/p&gt;

&lt;h2 id=&quot;优化二维码&quot;&gt;优化二维码&lt;/h2&gt;

&lt;p&gt;在多次测试之后，我决定优化一下上传的参数：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  QRCode.toDataURL(string, {
    errorCorrectionLevel: 'H',
    width: 512,
    margin: 2,
    color: {
      light: '#fdfdfd',
      dark: '#384452'
    }
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;部署及测试-2&quot;&gt;部署及测试&lt;/h2&gt;

&lt;p&gt;好了，现在我们就可以部署，执行相应的部署命令：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sls deploy

Serverless: Packaging service...
Serverless: Excluding development dependencies...
Serverless: Uploading CloudFormation file to S3...
Serverless: Uploading artifacts...
Serverless: Uploading service .zip file to S3 (699.08 KB)...
Serverless: Validating template...
Serverless: Updating Stack...
Serverless: Checking Stack update progress...
..............
Serverless: Stack update finished...
Service Information
service: qrcode
stage: dev
region: us-east-1
stack: qrcode-dev
api keys:
  None
endpoints:
  GET - https://swsaner181.execute-api.us-east-1.amazonaws.com/dev/
functions:
  create: qrcode-dev-create
Serverless Domain Manager Summary
Domain Name
  qrcode.pho.im
Distribution Domain Name
  d1vpwj4ctk345u.cloudfront.net
Serverless: Removing old service versions...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后在网页上测试，我们创建的服务地址是：https://qrcode.pho.im/?q={string}&lt;/p&gt;

&lt;p&gt;使用这个 URL 进行测试：https://qrcode.pho.im/?q=http://weixin.qq.com/r/mnVYQHrEVicprT4j9yCI&lt;/p&gt;

&lt;p&gt;加上使用的短链服务就是：&lt;a href=&quot;https://x.pho.im/Z5t7&quot;&gt;https://x.pho.im/Z5t7&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;serverless-应用示例serverless-密码管理器&quot;&gt;Serverless 应用示例：Serverless 密码管理器&lt;/h1&gt;

&lt;p&gt;最近的几年里，每个人在密码上都遇到越来越多的挑战，即需要一个复杂的密码，又需要能记得住它们——两者几乎不可兼得。于是乎，我们开始使用上各式各样的密码管理器，并为之付上了费。又或者是一些开源的、不能同步的密码管理工具——毕竟服务器是要钱的。&lt;/p&gt;

&lt;p&gt;然而作为一个程序员，我觉得嘛，他/她们写的代码都不可靠——&lt;strong&gt;愈是通用的软件，愈加危险。&lt;/strong&gt;一旦一个地方出现问题，那么其它地方都会有问题。比如说，你的 Master Password 泄露了，那么相应的所有的密码也就相当于泄露了。以致于我又重新设计了自己的密码管理体系，写了一个自己的密码管理器。&lt;/p&gt;

&lt;h2 id=&quot;取个密码&quot;&gt;取个密码&lt;/h2&gt;

&lt;p&gt;取一个变量很纠结，取一个密码很头痛——更何况，我们要取一堆密码。于是，最好的方式就是写一个规则，来生成不同密码。从安全的角度来看，密码自然是又长又复杂的为好。可又复杂又长的代码，我们这些非机器的人是记不住的。&lt;/p&gt;

&lt;p&gt;根据我的现有模式，我有这么几种模式来管理密码。&lt;/p&gt;

&lt;h3 id=&quot;特定平台--固定密码&quot;&gt;特定平台 + 固定密码&lt;/h3&gt;

&lt;p&gt;11 年前我使用一个固定的、统一的密码，直到一系列的明文密码泄露事件，我在不同的平台采用了不同的密码。在经历了一系列的忘记密码之后，我开始采用平台限定的密码，即不同的平台，密码是半动态的。如下就是一个简单的，对应于不同平台的代码体系，如：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;京东：&lt;code class=&quot;highlighter-rouge&quot;&gt;jd-1qaz2wsx&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;淘宝：&lt;code class=&quot;highlighter-rouge&quot;&gt;tb-1qaz2wsx&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;而这样的密码本身也是不安全的，如果有人知道密码规则的话。那么，这无异于一场灾难。于是，我在设计出规则到现在，仅会&lt;strong&gt;在一些重要的网站上&lt;/strong&gt;，采用这种规则。&lt;/p&gt;

&lt;h3 id=&quot;密码表--特定平台--固定密码&quot;&gt;密码表 + 特定平台 + 固定密码&lt;/h3&gt;

&lt;p&gt;应对于上一种方式，如果我们拥有一个密码表，来稍微变换一下形式，诸如：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;京东：&lt;code class=&quot;highlighter-rouge&quot;&gt;tb-1qaz2wsx&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;淘宝：&lt;code class=&quot;highlighter-rouge&quot;&gt;jd-1qaz2wsx&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;那么，我们的密码就显得更加可靠。&lt;/p&gt;

&lt;h3 id=&quot;随机密码--固定密码&quot;&gt;随机密码 + 固定密码&lt;/h3&gt;

&lt;p&gt;如我们所知道的那样，只要是有规律的代码，都存在被破解的风险。所以在两年前，我写了一个简单的脚本来生成密码：&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;random&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;choice&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hexdigits&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;punctuation&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;time&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;base_time&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;12&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;base_string&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;choice&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hexdigits&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;base_punctuation&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;choice&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;punctuation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;base_string&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;base_punctuation&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;base_time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;从时间戳取四个数字，从 16 进制数中取出 6 位，再从特殊字符中取出两位，以此来构成我的密码的主要部分。而剩下的部分则是固定密码，固定的部分存在脑子里——万一密码都看到了，那么问题也不到。&lt;/p&gt;

&lt;p&gt;唯一需要担心的是，键盘上的值可能被记住了。即，有人监听你的输入，又或者是记住了剪贴板上的值——从这个角度上来看，输入法也是一个危险的存在。为此，我们还需要更高级的工具。&lt;/p&gt;

&lt;h3 id=&quot;密码管理器&quot;&gt;密码管理器&lt;/h3&gt;

&lt;p&gt;使用密码管理器，毫无疑问是目前为止最为通用的一种方式，诸如 1Password 和 LastPass 都是相对比较成熟的方案。它们可以运行在各种平台上，相互之间同步代码，并帮你自动填充密码。&lt;/p&gt;

&lt;p&gt;然而，这些工具都是按年付费的，部分还是私有软件。&lt;/p&gt;

&lt;h3 id=&quot;开启-mfa&quot;&gt;开启 MFA&lt;/h3&gt;

&lt;p&gt;但是不管怎样，密码的方式仍然是相当的不可靠——一旦泄露了就悲剧了。为此，如果你所用的平台，可以开启 MFA，就开启 MFA 吧。即 Multi-Factor Authentication (MFA) 是一种简单有效的最佳安全实践方法，它能够在用户名和密码之外再额外增加一层安全保护。&lt;/p&gt;

&lt;h2 id=&quot;serverless-架构下的密码管理器mopass&quot;&gt;Serverless 架构下的密码管理器：MoPass&lt;/h2&gt;

&lt;p&gt;要是我使用的是密码管理器的话，就没有本文的这么多事了。所以，我正在写自己的秘密管理器。&lt;/p&gt;

&lt;p&gt;在编写我的第三本书的时候，同时编写了我的 markdown 编辑器：Phodit。Phodit 的成功实施，让我在定制个人工具上，有了更坚定的信心和丰富的经验，所以我开始编写我的密码管理器——基于 Serverless 架构的密码管理器。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/img/posts/2019-05-24-serverless-app-dev-guide/mopass-c4-context.jpg&quot;&gt;&lt;img src=&quot;/assets/img/posts/2019-05-24-serverless-app-dev-guide/mopass-c4-context.jpg&quot; alt=&quot;MoPass C4 Context&quot; title=&quot;查看原图&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;系统的组件和关系相对都比较简单：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/img/posts/2019-05-24-serverless-app-dev-guide/mopass-c4-container.jpg&quot;&gt;&lt;img src=&quot;/assets/img/posts/2019-05-24-serverless-app-dev-guide/mopass-c4-container.jpg&quot; alt=&quot;MoPass C4 Container&quot; title=&quot;查看原图&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;大抵就是对于密码的加解密和 CRUD，只是客户端有所不同罢了。&lt;/p&gt;

&lt;p&gt;由于设计的初衷是：&lt;strong&gt;针对于个人的轻量级密码管理器&lt;/strong&gt;，所以在最初设计的时候，是根据 Master Password + MD5 来生成后台的授权 Token。当用户数量变多的时候，Master Password 便会出现重复，导致密码重复的问题——由于使用了 Key + Master Password 来对密码进行加密和解密，虽然 Master Password 相同，但是也无法解密别人的密码。&lt;/p&gt;

&lt;h3 id=&quot;在终端中使用-cli&quot;&gt;在终端中使用 CLI&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;一个不习惯用命令行的程序员，不是一个高效的程序员。&lt;/strong&gt;——Phodal&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;一个密码管理器，最好是直接输个命令就能获取了，而不是打开某个软件、输入密码、找到对应的条目，再复制密码。对于 MoPass 来说，获取密码，只需要这么一步：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;➜  mopass git:(master) mopass --get GitHub
? master password ******
200: Copied to clipboard!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;而后，我们就可以直接粘贴我们的密码——为了查看所有的条目，只需要 &lt;code class=&quot;highlighter-rouge&quot;&gt;mopass --list&lt;/code&gt;。从这等意义上来说，这个工具更适合于程序员使用。而为了使用更加方便，我还是写了一个 Chrome 上的插件——毕竟，输入密码的场景，主要是在网页上，而不是终端里——我可不习惯用 w3m 来浏览网页。&lt;/p&gt;

&lt;h3 id=&quot;通过-chrome-插件中使用&quot;&gt;通过 Chrome 插件中使用&lt;/h3&gt;

&lt;p&gt;Chrome 插件，只需要输入密码即可——不过，为了安全考虑，不在浏览器上存储密码，而是每次从服务器上获取。这个问题，可以在我稍有余力的时候，再去看看怎么优化——毕竟 CLI 更快。&lt;/p&gt;

&lt;h2 id=&quot;结论-3&quot;&gt;结论&lt;/h2&gt;

&lt;p&gt;最后，请不到你的密码贴在笔记本上。&lt;/p&gt;

&lt;p&gt;GitHub: https://github.com/phodal/mopass&lt;/p&gt;

&lt;h1 id=&quot;serverless-框架-openwhisk-开发指南&quot;&gt;Serverless 框架 OpenWhisk 开发指南&lt;/h1&gt;

&lt;p&gt;在尝试了使用 AWS 开发 Serverless 应用之后，我便想尝试使用 OpenWhisk 框架来搭建自己的 Serverless 服务。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Apache OpenWhisk（http://openwhisk.org/）是一个由IBM和Adobe驱动的开源项目，它是一个健壮的FaaS平台，可以部署在云或数据中心内。相比其他serverless项目，OpenWhisk是一个健壮的、可扩展的平台，支持数千并发触发器和调用。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;openwhisk-简介&quot;&gt;OpenWhisk 简介&lt;/h2&gt;

&lt;p&gt;其系统架构如下所示：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/img/posts/2019-05-24-serverless-app-dev-guide/OpenWhisk_flow_of_processing.png&quot;&gt;&lt;img src=&quot;/assets/img/posts/2019-05-24-serverless-app-dev-guide/OpenWhisk_flow_of_processing.png&quot; alt=&quot;OpenWhisk 流处理流程&quot; title=&quot;查看原图&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;对应的组件的功能如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Nginx 暴露HTTP（S）端点给客户端。&lt;/li&gt;
  &lt;li&gt;Controller 充当系统的守门员、系统的协调者，它将决定请求最终采取的路径。&lt;/li&gt;
  &lt;li&gt;CouchDB 护和管理系统的状态。&lt;/li&gt;
  &lt;li&gt;Consul 作为系统每个组件可访问的单一数据源。 同时，consul还提供服务发现功能，使控制器发现调用操作的实体。&lt;/li&gt;
  &lt;li&gt;Apache Kafka 用于构建实时数据管道和流应用程序。&lt;/li&gt;
  &lt;li&gt;Invoker 使用 Scala实现，它是处理执行过程的最后阶段。&lt;/li&gt;
  &lt;li&gt;Docker， 几乎所有的 OpenWhisk 组件都打包和部署为容器。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;macos-搭建-openwhisk-环境&quot;&gt;macOS 搭建 OpenWhisk 环境&lt;/h2&gt;

&lt;p&gt;官网的指引很简单，但是中间还是遇到一些环境问题。&lt;/p&gt;

&lt;p&gt;首先 clone 代码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git clone --depth=1 https://github.com/apache/incubator-openwhisk.git openwhisk
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后于是虚拟机的目录：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd openwhisk/tools/vagrant
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;接着执行 hello 命令&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$./hello

./hello: line 8: vagrant: command not found
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;便提示 vagrant 没有安装。Vagrant 只是一个虚拟机管理和配置工具，为了安装 vagrant，还需要先安装 virtualbox 虚拟机：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;brew cask install virtualbox
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后安装 vagrant，顺便也 可以安装 vagrant-manager&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ brew cask install vagrant vagrant-manager

==&amp;gt; Satisfying dependencies
==&amp;gt; Downloading https://releases.hashicorp.com/vagrant/2.0.1/vagrant_2.0.1_x86_64.dmg
######################################################################## 100.0%
==&amp;gt; Verifying checksum for Cask vagrant
==&amp;gt; Installing Cask vagrant
==&amp;gt; Running installer for vagrant; your password may be necessary.
==&amp;gt; Package installers may write to any location; options such as --appdir are ignored.
Password:
==&amp;gt; installer: Package name is Vagrant
==&amp;gt; installer: Installing at base path /
==&amp;gt; installer: The install was successful.
🍺  vagrant was successfully installed!
==&amp;gt; Satisfying dependencies
==&amp;gt; Downloading https://github.com/lanayotech/vagrant-manager/releases/download/2.6.0/vagrant-manager-2.6.0.dmg
######################################################################## 100.0%
==&amp;gt; Verifying checksum for Cask vagrant-manager
==&amp;gt; Installing Cask vagrant-manager
==&amp;gt; Moving App 'Vagrant Manager.app' to '/Applications/Vagrant Manager.app'.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;再次执行：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ ./hello
Bringing machine 'default' up with 'virtualbox' provider...
==&amp;gt; default: Box 'ubuntu/trusty64' could not be found. Attempting to find and install...
    default: Box Provider: virtualbox
    default: Box Version: &amp;gt;= 0
==&amp;gt; default: Loading metadata for box 'ubuntu/trusty64'
    default: URL: https://vagrantcloud.com/ubuntu/trusty64
==&amp;gt; default: Adding box 'ubuntu/trusty64' (v20171205.0.1) for provider: virtualbox
    default: Downloading: https://vagrantcloud.com/ubuntu/boxes/trusty64/versions/20171205.0.1/providers/virtualbox.box
    default: Progress: 11% (Rate: 2806k/s, Estimated time remaining: 0:04:16)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后挑个网速好的时间，比如早上（经过测试晚上的下载速度比较慢），等它下载完。下载完后，便自动开始在虚拟机里搭建 OpenWhisk 环境，如安装 Docker、Git 等等的操作。&lt;/p&gt;

&lt;p&gt;最麻烦的是等待 Docker 安装拉各种镜像。OpenWhisk系统由许多组件构建而成：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/img/posts/2019-05-24-serverless-app-dev-guide/openwhisk-components.png&quot;&gt;&lt;img src=&quot;/assets/img/posts/2019-05-24-serverless-app-dev-guide/openwhisk-components.png&quot; alt=&quot;OpenWhisk 组件&quot; title=&quot;查看原图&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;直至：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    default: +++ cat /home/vagrant/openwhisk/ansible/files/auth.guest
    default: ++ wsk property set --apihost 192.168.33.13 --namespace guest --auth 23bc46b1-71f6-4ed5-8c54-816aa4f8c502:123zO3xZCLrMN6v2BKK1dXYFpXlPkccOFqm12CdAsMgRU4VrNZ9lyGVCGuMDGIwP
    default: ok: whisk auth set. Run 'wsk property get --auth' to see the new value.
    default: ok: whisk API host set to 192.168.33.13
    default: ok: whisk namespace set to guest
    default: ++ wsk action invoke /whisk.system/utils/echo -p message hello --result
    default: {
    default:     &quot;message&quot;: &quot;hello&quot;
    default: }
    default: +++ date
    default: ++ echo 'Mon Dec 11 12:09:23 UTC 2017: build-deploy-end'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们就顺利地运行了我们的 hello world。&lt;/p&gt;

&lt;p&gt;你也可以 ssh 到机器上：&lt;code class=&quot;highlighter-rouge&quot;&gt;vagrant ssh&lt;/code&gt;，然后运行 &lt;code class=&quot;highlighter-rouge&quot;&gt;wsk&lt;/code&gt; 命令试试:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vagrant&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vagrant&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ubuntu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;trusty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:~/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;openwhisk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wsk&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;____&lt;/span&gt;      &lt;span class=&quot;n&quot;&gt;___&lt;/span&gt;                   &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt;
       &lt;span class=&quot;p&quot;&gt;/\&lt;/span&gt;   &lt;span class=&quot;p&quot;&gt;\&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;\&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;___&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;|&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;___&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;/\&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;\&lt;/span&gt;   &lt;span class=&quot;p&quot;&gt;\&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'_ \ / _ \ '&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;\|&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;|&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'_ \| / __| |/ /
 /  \____ \  /  | |_| | |_) |  __/ | | | |/\| | | | | \__ \   &amp;lt;
 \   \  /  \/    \___/| .__/ \___|_| |_|__/\__|_| |_|_|___/_|\_\
  \___\/ tm           |_|

Usage:
  wsk [command]

Available Commands:
  action      work with actions
  activation  work with activations
  api         work with APIs
  help        Help about any command
  list        list entities in the current namespace
  namespace   work with namespaces
  package     work with packages
  property    work with whisk properties
  rule        work with rules
  sdk         work with the sdk
  trigger     work with triggers
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;serverless-框架-openwhisk-开发指南使用-serverless-framework-开发-openwhisk-应用&quot;&gt;Serverless 框架 OpenWhisk 开发指南：使用 Serverless Framework 开发 OpenWhisk 应用&lt;/h2&gt;

&lt;h3 id=&quot;serverless-openwhisk&quot;&gt;Serverless OpenWhisk&lt;/h3&gt;

&lt;p&gt;在上一篇文章《&lt;a href=&quot;https://www.phodal.com/blog/serverless-framework-openwhisk-nodejs-hello-world/&quot;&gt;Serverless 框架 OpenWhisk 开发指南：使用 Node.js 编写 hello, world&lt;/a&gt; 里，我们介绍了怎么连接客户端与 OpenWhisk 服务器。在这里，我假设读者已经有相关经验了。&lt;/p&gt;

&lt;p&gt;首先，我们需要先安装对应的 Node.js 模块：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ npm install --global serverless serverless-openwhisk
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后使用模板创建：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;serverless create --template openwhisk-nodejs --path my_service
cd my_service
npm install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;因为我们是在本地运行的服务，我们需要修改我们的 &lt;code class=&quot;highlighter-rouge&quot;&gt;serverless.yml&lt;/code&gt; 文件，添加 &lt;code class=&quot;highlighter-rouge&quot;&gt;ignore_certs&lt;/code&gt; 参数以忽略证书：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;provider:
  name: openwhisk
  ignore_certs: true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后，就可以继续愉快地使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;sls deploy&lt;/code&gt; 部署了：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Serverless: Packaging service...
Serverless: Excluding development dependencies...
Serverless: Compiling Functions...
Serverless: Compiling API Gateway definitions...
Serverless: Compiling Rules...
Serverless: Compiling Triggers &amp;amp; Feeds...
Serverless: Deploying Functions...
Serverless: Deployment successful!

Service Information
platform:	http://192.168.33.13:10001
namespace:	guest
service:	my_service

actions:
my_service-dev-hello    hello    node_version

triggers:
**no triggers deployed**

rules:
**no rules deployed**

endpoints (api-gw):
**failed to fetch routes**
endpoints (web actions):
**no web actions deployed**
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;测试服务&quot;&gt;测试服务&lt;/h3&gt;

&lt;p&gt;现在，我们就可以测试我们的 OpenWhisk 函数了：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ serverless invoke --function hello
{
    &quot;payload&quot;: &quot;Hello, World!&quot;
}
$ serverless invoke --function hello --data '{&quot;name&quot;: &quot;OpenWhisk&quot;}'
{
    &quot;payload&quot;: &quot;Hello, OpenWhisk!&quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;serverless-框架-openwhisk-开发指南使用-nodejs-编写-hello-world&quot;&gt;Serverless 框架 OpenWhisk 开发指南：使用 Node.js 编写 hello, world&lt;/h2&gt;

&lt;p&gt;我们将介绍：如何将上一节搭建的 OpenWhisk 服务作为服务器，并使用自己的 macOS 作为客户端。然后，在这之上运行我们的 Serverless 应用&lt;/p&gt;

&lt;h2 id=&quot;配置-openwhisk-客户端&quot;&gt;配置 OpenWhisk 客户端&lt;/h2&gt;

&lt;h3 id=&quot;获取-cli&quot;&gt;获取 CLI&lt;/h3&gt;

&lt;p&gt;首先，我们需要在我们的电脑上安装 OpenWhisk 的 CLI，可以直接从 Bluemix 上下载二进制的包：&lt;a href=&quot;https://openwhisk.ng.bluemix.net/cli/go/download/&quot;&gt;https://openwhisk.ng.bluemix.net/cli/go/download/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;然后将命令加到环境变量中：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ chmod +x ./wsk

$ sudo mv wsk /usr/local/bin
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;为客户端获取密钥&quot;&gt;为客户端获取密钥&lt;/h3&gt;

&lt;p&gt;接着，我们需要到我们的 vagrant 虚拟机，为客户端分配一下密钥。使用下面的命令登录：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;vagrant ssh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后，获取密钥：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ wsk property get --auth

whisk auth		23bc46b1-71f6-4ed5-8c54-816aa4f8c502:123zO3xZCLrMN6v2BKK1dXYFpXlPkccOFqm12CdAsMgRU4VrNZ9lyGVCGuMDGIwP
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;在客户端设置&quot;&gt;在客户端设置&lt;/h3&gt;

&lt;p&gt;先看一下命令：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;wsk property set --apihost http://192.168.33.13:10001 --namespace guest --auth 23bc46b1-71f6-4ed5-8c54-816aa4f8c502:123zO3xZCLrMN6v2BKK1dXYFpXlPkccOFqm12CdAsMgRU4VrNZ9lyGVCGuMDGIwP
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;正常情况下 apihost 应该是 &lt;strong&gt;192.168.33.13&lt;/strong&gt;，并且没有 10001 端口。但是好像我的配置有问题，2333。&lt;/p&gt;

&lt;p&gt;可以先试试使用能不能列出系统的包：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ wsk package list /whisk.system

packages
/whisk.system/github                                                   shared
/whisk.system/combinators                                              shared
/whisk.system/slack                                                    shared
/whisk.system/watson-textToSpeech                                      shared
/whisk.system/utils                                                    shared
/whisk.system/watson-speechToText                                      shared
/whisk.system/websocket                                                shared
/whisk.system/weather                                                  shared
/whisk.system/samples                                                  shared
/whisk.system/watson-translator                                        shared
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;接着，就可以进入下一步了。使用 Node.js 创建一个 hello, world。&lt;/p&gt;

&lt;h3 id=&quot;openwhisk-nodejs-hello-world&quot;&gt;OpenWhisk Node.js Hello, world&lt;/h3&gt;

&lt;p&gt;1.创建我们的 hello.js&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function main() {
   return {payload: 'Hello world'};
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;2.创建操作&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ wsk action create hello hello.js

ok: created action hello
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;3.触发事件&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ wsk action invoke hello

ok: invoked /guest/hello with id a3ea5f68844248e9aa5f68844288e98d
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;4.查看返回结果&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;wsk activation result a3ea5f68844248e9aa5f68844288e98d
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;就这么简单。&lt;/p&gt;

&lt;h3 id=&quot;openwhisk-nodejs-传递参数&quot;&gt;OpenWhisk Node.js 传递参数&lt;/h3&gt;

&lt;p&gt;接下来，让我们看一个参数的例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function main(params) {
  return {
    payload:  'Hello, ' + params.name
  };
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后更新我们的操作：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ wsk action update hello hello.js

ok: updated action hello
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;接着，就可以触发我们的操作：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$  wsk action invoke --result hello --param name Phodal

{
    &quot;payload&quot;: &quot;Hello, Phodal&quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;当然，它可以探索的地方仍然有很多。&lt;/p&gt;
&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:full_stack&quot;&gt;
      &lt;p&gt;选自《全栈应用开发：精益实践》的『隔离与运行环境』一节 &lt;a href=&quot;#fnref:full_stack&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:aws_serverless&quot;&gt;
      &lt;p&gt;https://aws.amazon.com/cn/blogs/china/iaas-faas-serverless/ &lt;a href=&quot;#fnref:aws_serverless&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:wiki_event_driver&quot;&gt;
      &lt;p&gt;https://zh.wikipedia.org/wiki/%E4%BA%8B%E4%BB%B6%E9%A9%85%E5%8B%95%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88 &lt;a href=&quot;#fnref:wiki_event_driver&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
        <pubDate>Fri, 24 May 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/05/24/serverless-app-dev-guide/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/05/24/serverless-app-dev-guide/</guid>
        
        <category>微服务</category>
        
        <category>转载</category>
        
        
      </item>
    
      <item>
        <title>WebP 图片转换</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;WebP&lt;/code&gt;是Google推出的一种同时提供了有损压缩与无损压缩（可逆压缩）的图片文件格式。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;根据Google的测试，无损压缩后的WebP比PNG文件少了26％的体积，有损压缩后的&lt;code class=&quot;highlighter-rouge&quot;&gt;WebP&lt;/code&gt;图片相比于等效质量指标的JPEG图片减少了25％~34%的体积。&lt;/p&gt;

&lt;h3 id=&quot;安装&quot;&gt;安装&lt;/h3&gt;

&lt;p&gt;以&lt;code class=&quot;highlighter-rouge&quot;&gt;Ubuntu16.04&lt;/code&gt;为例：&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;apt-get update
&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;apt-get &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;webp 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其他Linux版本或操作系统，查看&lt;a href=&quot;https://developers.google.com/speed/webp/docs/precompiled&quot;&gt;官方文档&lt;/a&gt;，或者&lt;a href=&quot;https://github.com/webmproject/libwebp&quot;&gt;Github文档&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;使用&quot;&gt;使用&lt;/h3&gt;

&lt;h5 id=&quot;cwebp-编码&quot;&gt;cwebp 编码&lt;/h5&gt;

&lt;p&gt;将其他格式的图片转换为&lt;code class=&quot;highlighter-rouge&quot;&gt;WebP&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;我们实际场景来说明，这里将一张&lt;code class=&quot;highlighter-rouge&quot;&gt;aa.jpg&lt;/code&gt;图片转换为质量85、宽高为300乘200的&lt;code class=&quot;highlighter-rouge&quot;&gt;WebP&lt;/code&gt;格式，并起名为&lt;code class=&quot;highlighter-rouge&quot;&gt;bb&lt;/code&gt;：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/img/posts/2019-05-21-webp/aa.jpg&quot;&gt;&lt;img src=&quot;/assets/img/posts/2019-05-21-webp/aa.jpg&quot; alt=&quot;aa.jpg&quot; title=&quot;查看原图&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;执行命令：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cwebp -q 85 -resize 300 200  aa.jpg -o bb.webp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;参数说明：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cwebp -q [质量] -resize [宽] [高]  [原图片] -o [输出文件]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;输出结果：&lt;/p&gt;

&lt;p&gt;bb.webp&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/img/posts/2019-05-21-webp/bb.webp&quot;&gt;&lt;img src=&quot;/assets/img/posts/2019-05-21-webp/bb.webp&quot; alt=&quot;bb.webp&quot; title=&quot;查看原图&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;参看所有可选项及说明：&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; cwebp &lt;span class=&quot;nt&quot;&gt;-longhelp&lt;/span&gt;

Usage:
 cwebp &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-preset&lt;/span&gt; &amp;lt;...&amp;gt;] &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;options] in_file &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; out_file]

If input size &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;an image is not specified, it is
assumed to be a PNG, JPEG, TIFF or WebP file.

Options:
  &lt;span class=&quot;nt&quot;&gt;-h&lt;/span&gt; / &lt;span class=&quot;nt&quot;&gt;-help&lt;/span&gt; ............. short &lt;span class=&quot;nb&quot;&gt;help&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;-H&lt;/span&gt; / &lt;span class=&quot;nt&quot;&gt;-longhelp&lt;/span&gt; ......... long &lt;span class=&quot;nb&quot;&gt;help&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;-q&lt;/span&gt; &amp;lt;float&amp;gt; ............. quality &lt;span class=&quot;nb&quot;&gt;factor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;0:small..100:big&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, &lt;span class=&quot;nv&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;75
  &lt;span class=&quot;nt&quot;&gt;-alpha_q&lt;/span&gt; &amp;lt;int&amp;gt; ......... transparency-compression quality &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;0..100&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;,
                           &lt;span class=&quot;nv&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;100
  &lt;span class=&quot;nt&quot;&gt;-preset&lt;/span&gt; &amp;lt;string&amp;gt; ....... preset setting, one of:
                            default, photo, picture,
                            drawing, icon, text
     &lt;span class=&quot;nt&quot;&gt;-preset&lt;/span&gt; must come first, as it overwrites other parameters
  &lt;span class=&quot;nt&quot;&gt;-z&lt;/span&gt; &amp;lt;int&amp;gt; ............... activates lossless preset with given
                           level &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;0:fast, ..., 9:slowest]

  &lt;span class=&quot;nt&quot;&gt;-m&lt;/span&gt; &amp;lt;int&amp;gt; ............... compression method &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;fast, &lt;span class=&quot;nv&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;slowest&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, &lt;span class=&quot;nv&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;4
  &lt;span class=&quot;nt&quot;&gt;-segments&lt;/span&gt; &amp;lt;int&amp;gt; ........ number of segments to use &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;1..4&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, &lt;span class=&quot;nv&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;4
  &lt;span class=&quot;nt&quot;&gt;-size&lt;/span&gt; &amp;lt;int&amp;gt; ............ target size &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;bytes&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;-psnr&lt;/span&gt; &amp;lt;float&amp;gt; .......... target PSNR &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;dB. typically: 42&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

  &lt;span class=&quot;nt&quot;&gt;-s&lt;/span&gt; &amp;lt;int&amp;gt; &amp;lt;int&amp;gt; ......... input size &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;width x height&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;YUV
  &lt;span class=&quot;nt&quot;&gt;-sns&lt;/span&gt; &amp;lt;int&amp;gt; ............. spatial noise shaping &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;0:off, 100:max&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, &lt;span class=&quot;nv&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;50
  &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; &amp;lt;int&amp;gt; ............... filter strength &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;off..100&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, &lt;span class=&quot;nv&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;60
  &lt;span class=&quot;nt&quot;&gt;-sharpness&lt;/span&gt; &amp;lt;int&amp;gt; ....... filter sharpness &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;0:most .. 7:least sharp&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, &lt;span class=&quot;nv&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0
  &lt;span class=&quot;nt&quot;&gt;-strong&lt;/span&gt; ................ use strong filter instead of simple &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;default&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;-nostrong&lt;/span&gt; .............. use simple filter instead of strong
  &lt;span class=&quot;nt&quot;&gt;-sharp_yuv&lt;/span&gt; ............. use sharper &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;and slower&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; RGB-&amp;gt;YUV conversion
  &lt;span class=&quot;nt&quot;&gt;-partition_limit&lt;/span&gt; &amp;lt;int&amp;gt; &lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt; limit quality to fit the 512k limit on
                           the first partition &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;no degradation ... &lt;span class=&quot;nv&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;full&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;-pass&lt;/span&gt; &amp;lt;int&amp;gt; ............ analysis pass number &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;1..10&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;-crop&lt;/span&gt; &amp;lt;x&amp;gt; &amp;lt;y&amp;gt; &amp;lt;w&amp;gt; &amp;lt;h&amp;gt; .. crop picture with the given rectangle
  &lt;span class=&quot;nt&quot;&gt;-resize&lt;/span&gt; &amp;lt;w&amp;gt; &amp;lt;h&amp;gt; ........ resize picture &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;after any cropping&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;-mt&lt;/span&gt; .................... use multi-threading &lt;span class=&quot;k&quot;&gt;if &lt;/span&gt;available
  &lt;span class=&quot;nt&quot;&gt;-low_memory&lt;/span&gt; ............ reduce memory usage &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;slower encoding&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;-map&lt;/span&gt; &amp;lt;int&amp;gt; ............. print map of extra info
  &lt;span class=&quot;nt&quot;&gt;-print_psnr&lt;/span&gt; ............ prints averaged PSNR distortion
  &lt;span class=&quot;nt&quot;&gt;-print_ssim&lt;/span&gt; ............ prints averaged SSIM distortion
  &lt;span class=&quot;nt&quot;&gt;-print_lsim&lt;/span&gt; ............ prints local-similarity distortion
  &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; &amp;lt;file.pgm&amp;gt; .......... dump the compressed output &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;PGM file&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;-alpha_method&lt;/span&gt; &amp;lt;int&amp;gt; .... transparency-compression method &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;0..1&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, &lt;span class=&quot;nv&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;1
  &lt;span class=&quot;nt&quot;&gt;-alpha_filter&lt;/span&gt; &amp;lt;string&amp;gt; &lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt; predictive filtering &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;alpha plane,
                           one of: none, fast &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;default&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; or best
  &lt;span class=&quot;nt&quot;&gt;-exact&lt;/span&gt; ................. preserve RGB values &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;transparent area, &lt;span class=&quot;nv&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;off
  &lt;span class=&quot;nt&quot;&gt;-blend_alpha&lt;/span&gt; &amp;lt;hex&amp;gt; ..... blend colors against background color
                           expressed as RGB values written &lt;span class=&quot;k&quot;&gt;in
                           &lt;/span&gt;hexadecimal, e.g. 0xc0e0d0 &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;red&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0xc0
                           &lt;span class=&quot;nv&quot;&gt;green&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0xe0 and &lt;span class=&quot;nv&quot;&gt;blue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0xd0
  &lt;span class=&quot;nt&quot;&gt;-noalpha&lt;/span&gt; ............... discard any transparency information
  &lt;span class=&quot;nt&quot;&gt;-lossless&lt;/span&gt; .............. encode image losslessly, &lt;span class=&quot;nv&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;off
  &lt;span class=&quot;nt&quot;&gt;-near_lossless&lt;/span&gt; &amp;lt;int&amp;gt; ... use near-lossless image
                           preprocessing &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;0..100&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;off&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, &lt;span class=&quot;nv&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;100
  &lt;span class=&quot;nt&quot;&gt;-hint&lt;/span&gt; &amp;lt;string&amp;gt; ......... specify image characteristics hint,
                           one of: photo, picture or graph

  &lt;span class=&quot;nt&quot;&gt;-metadata&lt;/span&gt; &amp;lt;string&amp;gt; ..... comma separated list of metadata to
                           copy from the input to the output &lt;span class=&quot;k&quot;&gt;if &lt;/span&gt;present.
                           Valid values: all, none &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;default&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, exif, icc, xmp

  &lt;span class=&quot;nt&quot;&gt;-short&lt;/span&gt; ................. condense printed message
  &lt;span class=&quot;nt&quot;&gt;-quiet&lt;/span&gt; ................. don&lt;span class=&quot;s1&quot;&gt;'t print anything
  -version ............... print version number and exit
  -noasm ................. disable all assembly optimizations
  -v ..................... verbose, e.g. print encoding/decoding times
  -progress .............. report encoding progress

Experimental Options:
  -jpeg_like ............. roughly match expected JPEG size
  -af .................... auto-adjust filter strength
  -pre &amp;lt;int&amp;gt; ............. pre-processing filter
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;dwebp-解码&quot;&gt;dwebp 解码&lt;/h5&gt;

&lt;p&gt;将&lt;code class=&quot;highlighter-rouge&quot;&gt;WebP&lt;/code&gt;格式的图片转换为其他格式&lt;/p&gt;

&lt;p&gt;我们还是以上一步生成的&lt;code class=&quot;highlighter-rouge&quot;&gt;bb.webp&lt;/code&gt;来演示，这次将它转换为&lt;code class=&quot;highlighter-rouge&quot;&gt;PNG&lt;/code&gt;格式，并起名&lt;code class=&quot;highlighter-rouge&quot;&gt;cc&lt;/code&gt;：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dwebp bb.webp -o cc.png
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;参数说明：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dwebp [原图片] -o [输出文件]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;输出结果：&lt;/p&gt;

&lt;p&gt;cc.png&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/img/posts/2019-05-21-webp/cc.png&quot;&gt;&lt;img src=&quot;/assets/img/posts/2019-05-21-webp/cc.png&quot; alt=&quot;cc.png&quot; title=&quot;查看原图&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;参看所有可选项及说明：&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; dwebp &lt;span class=&quot;nt&quot;&gt;-h&lt;/span&gt;

Usage: dwebp in_file &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;options] &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; out_file]

Decodes the WebP image file to PNG format &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;Default]
Use following options to convert into alternate image formats:
  &lt;span class=&quot;nt&quot;&gt;-pam&lt;/span&gt; ......... save the raw RGBA samples as a color PAM
  &lt;span class=&quot;nt&quot;&gt;-ppm&lt;/span&gt; ......... save the raw RGB samples as a color PPM
  &lt;span class=&quot;nt&quot;&gt;-bmp&lt;/span&gt; ......... save as uncompressed BMP format
  &lt;span class=&quot;nt&quot;&gt;-tiff&lt;/span&gt; ........ save as uncompressed TIFF format
  &lt;span class=&quot;nt&quot;&gt;-pgm&lt;/span&gt; ......... save the raw YUV samples as a grayscale PGM
                 file with IMC4 layout
  &lt;span class=&quot;nt&quot;&gt;-yuv&lt;/span&gt; ......... save the raw YUV samples &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;flat layout

 Other options are:
  &lt;span class=&quot;nt&quot;&gt;-version&lt;/span&gt; ..... print version number and &lt;span class=&quot;nb&quot;&gt;exit&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;-nofancy&lt;/span&gt; ..... don&lt;span class=&quot;s1&quot;&gt;'t use the fancy YUV420 upscaler
  -nofilter .... disable in-loop filtering
  -nodither .... disable dithering
  -dither &amp;lt;d&amp;gt; .. dithering strength (in 0..100)
  -alpha_dither  use alpha-plane dithering if needed
  -mt .......... use multi-threading
  -crop &amp;lt;x&amp;gt; &amp;lt;y&amp;gt; &amp;lt;w&amp;gt; &amp;lt;h&amp;gt; ... crop output with the given rectangle
  -resize &amp;lt;w&amp;gt; &amp;lt;h&amp;gt; ......... scale the output (*after* any cropping)
  -flip ........ flip the output vertically
  -alpha ....... only save the alpha plane
  -incremental . use incremental decoding (useful for tests)
  -h ........... this help message
  -v ........... verbose (e.g. print encoding/decoding times)
  -quiet ....... quiet mode, don'&lt;/span&gt;t print anything
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;vwebp-浏览&quot;&gt;vwebp 浏览&lt;/h5&gt;

&lt;p&gt;弹出一个&lt;code class=&quot;highlighter-rouge&quot;&gt;GUI&lt;/code&gt;窗口显示&lt;code class=&quot;highlighter-rouge&quot;&gt;WebP&lt;/code&gt;图片&lt;/p&gt;

&lt;p&gt;我们来浏览下&lt;code class=&quot;highlighter-rouge&quot;&gt;bb.webp&lt;/code&gt;图片&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;vwebp bb.webp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;输出：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/img/posts/2019-05-21-webp/vwebp.png&quot;&gt;&lt;img src=&quot;/assets/img/posts/2019-05-21-webp/vwebp.png&quot; alt=&quot;vwebp.png&quot; title=&quot;查看原图&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;参看所有可选项及说明：&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; vwebp &lt;span class=&quot;nt&quot;&gt;-h&lt;/span&gt;

Usage: vwebp in_file &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;options]

Decodes the WebP image file and visualize it using OpenGL
Options are:
  &lt;span class=&quot;nt&quot;&gt;-version&lt;/span&gt; ..... print version number and &lt;span class=&quot;nb&quot;&gt;exit&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;-noicc&lt;/span&gt; ....... don&lt;span class=&quot;s1&quot;&gt;'t use the icc profile if present
  -nofancy ..... don'&lt;/span&gt;t use the fancy YUV420 upscaler
  &lt;span class=&quot;nt&quot;&gt;-nofilter&lt;/span&gt; .... disable &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-loop&lt;/span&gt; filtering
  &lt;span class=&quot;nt&quot;&gt;-dither&lt;/span&gt; &amp;lt;int&amp;gt;  dithering strength &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;0..100&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, &lt;span class=&quot;nv&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;50
  &lt;span class=&quot;nt&quot;&gt;-noalphadither&lt;/span&gt; disable alpha plane dithering
  &lt;span class=&quot;nt&quot;&gt;-usebgcolor&lt;/span&gt; .. display background color
  &lt;span class=&quot;nt&quot;&gt;-mt&lt;/span&gt; .......... use multi-threading
  &lt;span class=&quot;nt&quot;&gt;-info&lt;/span&gt; ........ print info
  &lt;span class=&quot;nt&quot;&gt;-h&lt;/span&gt; ........... this &lt;span class=&quot;nb&quot;&gt;help &lt;/span&gt;message

Keyboard shortcuts:
  &lt;span class=&quot;s1&quot;&gt;'c'&lt;/span&gt; ................ toggle use of color profile
  &lt;span class=&quot;s1&quot;&gt;'b'&lt;/span&gt; ................ toggle background color display
  &lt;span class=&quot;s1&quot;&gt;'i'&lt;/span&gt; ................ overlay file information
  &lt;span class=&quot;s1&quot;&gt;'d'&lt;/span&gt; ................ disable blending &amp;amp; disposal &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;debug&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;s1&quot;&gt;'q'&lt;/span&gt; / &lt;span class=&quot;s1&quot;&gt;'Q'&lt;/span&gt; / ESC .... quit
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;img2webp-动画&quot;&gt;img2webp 动画&lt;/h5&gt;

&lt;p&gt;将一组图片（&lt;code class=&quot;highlighter-rouge&quot;&gt;JPG&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;PNG&lt;/code&gt;…）转为&lt;code class=&quot;highlighter-rouge&quot;&gt;WebP&lt;/code&gt;动画&lt;/p&gt;

&lt;p&gt;这里准备了3张同样规格的图片(&lt;code class=&quot;highlighter-rouge&quot;&gt;a.jpg&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;b.png&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;c.jpg&lt;/code&gt;)。&lt;/p&gt;

&lt;p&gt;a.jpg&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/img/posts/2019-05-21-webp/a.jpg&quot;&gt;&lt;img src=&quot;/assets/img/posts/2019-05-21-webp/a.jpg&quot; alt=&quot;a.jpg&quot; title=&quot;查看原图&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;b.png&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/img/posts/2019-05-21-webp/b.png&quot;&gt;&lt;img src=&quot;/assets/img/posts/2019-05-21-webp/b.png&quot; alt=&quot;b.png&quot; title=&quot;查看原图&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;c.jpg&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/img/posts/2019-05-21-webp/c.jpg&quot;&gt;&lt;img src=&quot;/assets/img/posts/2019-05-21-webp/c.jpg&quot; alt=&quot;c.jpg&quot; title=&quot;查看原图&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;执行命令：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;img2webp  -loop 0 -lossy -d 1000 a.jpg -d 1500 b.png -d 2000 c.jpg -o out.webp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;参数说明：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;img2webp  -loop [循环次数] -d [间隔时间] [原文件1] -d [间隔时间] [原文件2] -d [间隔时间] [原文件3] -o [目标文件]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;输出结果：&lt;/p&gt;

&lt;p&gt;out.webp&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/img/posts/2019-05-21-webp/out.webp&quot;&gt;&lt;img src=&quot;/assets/img/posts/2019-05-21-webp/out.webp&quot; alt=&quot;out.webp&quot; title=&quot;查看原图&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;参看所有可选项及说明：&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; img2webp &lt;span class=&quot;nt&quot;&gt;-h&lt;/span&gt;

Usage:

  img2webp &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;file-level options] &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;image files...] &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;per-frame options...]

File-level options &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;only used at the start of compression&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;:
 &lt;span class=&quot;nt&quot;&gt;-min_size&lt;/span&gt; ............ minimize size
 &lt;span class=&quot;nt&quot;&gt;-loop&lt;/span&gt; &amp;lt;int&amp;gt; .......... loop count &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;default: 0, &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; infinite loop&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
 &lt;span class=&quot;nt&quot;&gt;-kmax&lt;/span&gt; &amp;lt;int&amp;gt; .......... maximum number of frame between key-frames
                        &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;only keyframes&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
 &lt;span class=&quot;nt&quot;&gt;-kmin&lt;/span&gt; &amp;lt;int&amp;gt; .......... minimum number of frame between key-frames
                        &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;disable key-frames altogether&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
 &lt;span class=&quot;nt&quot;&gt;-mixed&lt;/span&gt; ............... use mixed lossy/lossless automatic mode
 &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt; ................... verbose mode
 &lt;span class=&quot;nt&quot;&gt;-h&lt;/span&gt; ................... this &lt;span class=&quot;nb&quot;&gt;help&lt;/span&gt;
 &lt;span class=&quot;nt&quot;&gt;-version&lt;/span&gt; ............. print version number and &lt;span class=&quot;nb&quot;&gt;exit

&lt;/span&gt;Per-frame options &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;only used &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;subsequent images input&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;:
 &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; &amp;lt;int&amp;gt; ............. frame duration &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;ms &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;default: 100&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
 &lt;span class=&quot;nt&quot;&gt;-lossless&lt;/span&gt;  ........... use lossless mode &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;default&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
 &lt;span class=&quot;nt&quot;&gt;-lossy&lt;/span&gt; ... ........... use lossy mode
 &lt;span class=&quot;nt&quot;&gt;-q&lt;/span&gt; &amp;lt;float&amp;gt; ........... quality
 &lt;span class=&quot;nt&quot;&gt;-m&lt;/span&gt; &amp;lt;int&amp;gt; ............. method to use
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;gif2webp-gif转换&quot;&gt;gif2webp GIF转换&lt;/h5&gt;

&lt;p&gt;将&lt;code class=&quot;highlighter-rouge&quot;&gt;GIF&lt;/code&gt;格式图片转换为&lt;code class=&quot;highlighter-rouge&quot;&gt;WebP&lt;/code&gt;格式&lt;/p&gt;

&lt;p&gt;这里准备了一张&lt;code class=&quot;highlighter-rouge&quot;&gt;giphy.gif&lt;/code&gt;，我们来将它转换为&lt;code class=&quot;highlighter-rouge&quot;&gt;WebP&lt;/code&gt;看看效果&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/img/posts/2019-05-21-webp/giphy.gif&quot;&gt;&lt;img src=&quot;/assets/img/posts/2019-05-21-webp/giphy.gif&quot; alt=&quot;giphy.gif&quot; title=&quot;查看原图&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;执行命令：&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gif2webp giphy.gif &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; giphy.webp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;输出结果：&lt;/p&gt;

&lt;p&gt;giphy.webp&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/img/posts/2019-05-21-webp/giphy.webp&quot;&gt;&lt;img src=&quot;/assets/img/posts/2019-05-21-webp/giphy.webp&quot; alt=&quot;giphy.webp&quot; title=&quot;查看原图&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;参看所有可选项及说明：&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; gif2webp &lt;span class=&quot;nt&quot;&gt;-h&lt;/span&gt;

Usage:
 gif2webp &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;options] gif_file &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; webp_file
Options:
  &lt;span class=&quot;nt&quot;&gt;-h&lt;/span&gt; / &lt;span class=&quot;nt&quot;&gt;-help&lt;/span&gt; ............. this &lt;span class=&quot;nb&quot;&gt;help&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;-lossy&lt;/span&gt; ................. encode image using lossy compression
  &lt;span class=&quot;nt&quot;&gt;-mixed&lt;/span&gt; ................. &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;each frame &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;the image, pick lossy
                           or lossless compression heuristically
  &lt;span class=&quot;nt&quot;&gt;-q&lt;/span&gt; &amp;lt;float&amp;gt; ............. quality &lt;span class=&quot;nb&quot;&gt;factor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;0:small..100:big&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;-m&lt;/span&gt; &amp;lt;int&amp;gt; ............... compression method &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;fast, &lt;span class=&quot;nv&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;slowest&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;-min_size&lt;/span&gt; .............. minimize output size &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;default:off&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                           lossless compression by default&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; can be
                           combined with &lt;span class=&quot;nt&quot;&gt;-q&lt;/span&gt;, &lt;span class=&quot;nt&quot;&gt;-m&lt;/span&gt;, &lt;span class=&quot;nt&quot;&gt;-lossy&lt;/span&gt; or &lt;span class=&quot;nt&quot;&gt;-mixed&lt;/span&gt;
                           options
  &lt;span class=&quot;nt&quot;&gt;-kmin&lt;/span&gt; &amp;lt;int&amp;gt; ............ min distance between key frames
  &lt;span class=&quot;nt&quot;&gt;-kmax&lt;/span&gt; &amp;lt;int&amp;gt; ............ max distance between key frames
  &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; &amp;lt;int&amp;gt; ............... filter strength &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;off..100&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;-metadata&lt;/span&gt; &amp;lt;string&amp;gt; ..... comma separated list of metadata to
                           copy from the input to the output &lt;span class=&quot;k&quot;&gt;if &lt;/span&gt;present
                           Valid values: all, none, icc, xmp &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;default&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;-loop_compatibility&lt;/span&gt; .... use compatibility mode &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;Chrome
                           version prior to M62 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;inclusive&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;-mt&lt;/span&gt; .................... use multi-threading &lt;span class=&quot;k&quot;&gt;if &lt;/span&gt;available

  &lt;span class=&quot;nt&quot;&gt;-version&lt;/span&gt; ............... print version number and &lt;span class=&quot;nb&quot;&gt;exit&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt; ..................... verbose
  &lt;span class=&quot;nt&quot;&gt;-quiet&lt;/span&gt; ................. don&lt;span class=&quot;s1&quot;&gt;'t print anything
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Tue, 21 May 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/05/21/webp/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/05/21/webp/</guid>
        
        <category>工具</category>
        
        
      </item>
    
  </channel>
</rss>
