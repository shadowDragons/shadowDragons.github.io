<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ben Blog</title>
    <description>一个小白的成长学习历程</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Fri, 12 Oct 2018 22:38:30 +0800</pubDate>
    <lastBuildDate>Fri, 12 Oct 2018 22:38:30 +0800</lastBuildDate>
    <generator>Jekyll v3.8.4</generator>
    
      <item>
        <title>【构建高性能web站点】浏览器缓存</title>
        <description>&lt;p&gt;我们可以通过http头信息来实现浏览器缓存。&lt;/p&gt;

&lt;h3 id=&quot;last-modified&quot;&gt;Last-Modified&lt;/h3&gt;

&lt;p&gt;这种信息需要后台来判定是否过期。流程如下：&lt;/p&gt;

&lt;script src=&quot;/assets/js/mermaid.js&quot;&gt;&lt;/script&gt;
&lt;div class=&quot;mermaid&quot;&gt;
sequenceDiagram;
    participant 客户端
    participant 服务端
    客户端-&amp;gt;服务端: 请求静态文件
    服务端-&amp;gt;客户端: 返回头信息 Last-Modified: {最后修改时间} GMT
    Note left of 客户端: 确认文件是否过期
    客户端-&amp;gt;服务端: 返回头信息If-Modified-Since: {上一步获取的最后修改时间} GMT 
    Note right of 服务端: 获取客户端的头信息，根据设定的过期时间判断
    服务端-&amp;gt;客户端: 返回静态文件是否过期
&lt;/div&gt;

&lt;p&gt;缺点：需要请求服务器，确认是否过期&lt;/p&gt;

&lt;h3 id=&quot;etag&quot;&gt;ETag&lt;/h3&gt;

&lt;p&gt;同样需要后台来判定是否过期。流程如下：&lt;/p&gt;

&lt;script src=&quot;/assets/js/mermaid.js&quot;&gt;&lt;/script&gt;
&lt;div class=&quot;mermaid&quot;&gt;
sequenceDiagram;
    participant 客户端
    participant 服务端
    客户端-&amp;gt;服务端: 请求静态文件
    服务端-&amp;gt;客户端: 返回头信息 ETag: {根据文件内容计算出来的值} 
    Note left of 客户端: 确认文件是否过期
    客户端-&amp;gt;服务端: 返回头信息If-None-Match: {上一步获取的ETag值}
    Note right of 服务端: 获取客户端的头信息，计算目前文件内容的ETag值做对比
    服务端-&amp;gt;客户端: 返回静态文件是否过期
&lt;/div&gt;

&lt;p&gt;缺点：需要请求服务器，确认是否过期&lt;/p&gt;

&lt;h3 id=&quot;expires&quot;&gt;Expires&lt;/h3&gt;

&lt;p&gt;这种方式可以彻底消灭服务器请求，流程如下：&lt;/p&gt;

&lt;script src=&quot;/assets/js/mermaid.js&quot;&gt;&lt;/script&gt;
&lt;div class=&quot;mermaid&quot;&gt;
sequenceDiagram;
    participant 客户端
    participant 服务端
    客户端-&amp;gt;服务端: 请求静态文件
    服务端-&amp;gt;客户端: 返回头信息 Expires: {过期时间} GMT
    loop 判断过期
        客户端-&amp;gt;客户端: 根据Expires过期时间判断
    end
&lt;/div&gt;

&lt;p&gt;缺点：依赖本地时间、无法实时更新静态文件内容。&lt;/p&gt;

&lt;h3 id=&quot;cache-control&quot;&gt;Cache-control&lt;/h3&gt;

&lt;p&gt;HTTP1.1 的Cache-control可以弥补Expires依赖本地时间的不足。格式如下：&lt;/p&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Cache-control: max-age=&lt;span class=&quot;nt&quot;&gt;&amp;lt;second&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;max-age&lt;/code&gt;指定了缓存过期的相对时间，单位秒，并且是相对于本地时间。浏览器根据本地当前时间是否大于max-age+上次访问时间&lt;/p&gt;

&lt;p&gt;流程如下：&lt;/p&gt;

&lt;script src=&quot;/assets/js/mermaid.js&quot;&gt;&lt;/script&gt;
&lt;div class=&quot;mermaid&quot;&gt;
sequenceDiagram;
    participant 客户端
    participant 服务端
    客户端-&amp;gt;服务端: 请求静态文件
    服务端-&amp;gt;客户端: 返回头信息 Expires: {过期时间} GMT、Cache-control: max-age={有效时长}
    loop 判断过期
        客户端-&amp;gt;客户端: 优先判断max-age
    end
&lt;/div&gt;
</description>
        <pubDate>Thu, 11 Oct 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/10/11/bhpws-brower-cache/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/10/11/bhpws-brower-cache/</guid>
        
        <category>web</category>
        
        
      </item>
    
      <item>
        <title>系统调用跟踪 - strace、dtruss</title>
        <description>&lt;h3 id=&quot;linux工具strace&quot;&gt;linux工具strace&lt;/h3&gt;

&lt;h5 id=&quot;语法&quot;&gt;语法&lt;/h5&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;strace [-dffhiqrtttTvVxx] [-a column] [-e expr] ... [-o file]

              [-p pid] ... [-s strsize] [-u username] [-E var&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;val] ...

              [command [arg ...]]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;或者&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;strace &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-e&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;expr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; ... &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-O&lt;/span&gt; overhead] &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-S&lt;/span&gt; sortby] &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-E&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;val] ...

              &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;command&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;arg ...]]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;参数说明&quot;&gt;参数说明&lt;/h5&gt;

&lt;p&gt;-c 统计每一系统调用的所执行的时间,次数和出错的次数等.&lt;/p&gt;

&lt;p&gt;-d 输出strace关于标准错误的调试信息.&lt;/p&gt;

&lt;p&gt;-f 跟踪由fork调用所产生的子进程.&lt;/p&gt;

&lt;p&gt;-ff 如果提供-o filename,则所有进程的跟踪结果输出到相应的filename.pid中,pid是各进程的进程号.&lt;/p&gt;

&lt;p&gt;-F 尝试跟踪vfork调用.在-f时,vfork不被跟踪.&lt;/p&gt;

&lt;p&gt;-h 输出简要的帮助信息.&lt;/p&gt;

&lt;p&gt;-i 输出系统调用的入口指针.&lt;/p&gt;

&lt;p&gt;-q 禁止输出关于脱离的消息.&lt;/p&gt;

&lt;p&gt;-r 打印出相对时间关于每一个系统调用.&lt;/p&gt;

&lt;p&gt;-t 在输出中的每一行前加上时间信息.&lt;/p&gt;

&lt;p&gt;-tt 在输出中的每一行前加上时间信息,微秒级.&lt;/p&gt;

&lt;p&gt;-ttt 微秒级输出,以秒了表示时间.&lt;/p&gt;

&lt;p&gt;-T 显示每一调用所耗的时间.&lt;/p&gt;

&lt;p&gt;-v 输出所有的系统调用.一些调用关于环境变量,状态,输入输出等调用由于使用频繁,默认不输出.&lt;/p&gt;

&lt;p&gt;-V 输出strace的版本信息.&lt;/p&gt;

&lt;p&gt;-x 以十六进制形式输出非标准字符串.&lt;/p&gt;

&lt;p&gt;-xx 所有字符串以十六进制形式输出.&lt;/p&gt;

&lt;p&gt;-a column 设置返回值的输出位置.默认 为40.&lt;/p&gt;

&lt;p&gt;-e expr 指定一个表达式,用来控制如何跟踪.格式如下:&lt;/p&gt;

&lt;p&gt;[qualifier=][!]value1[,value2]…&lt;/p&gt;

&lt;p&gt;qualifier只能是 trace,abbrev,verbose,raw,signal,read,write其中之一.value是用来限定的符号或数字.默认的 qualifier是 trace.感叹号是否定符号.例如-eopen等价于 -e trace=open,表示只跟踪open调用.而-etrace!=open表示跟踪除了open以外的其它调用.有两个特殊的符号 all 和 none. 注意有些shell使用!来执行历史记录里的命令,所以要使用\.&lt;/p&gt;

&lt;p&gt;-e trace=set 只跟踪指定的系统调用.例如:-e trace=open,close,rean,write表示只跟踪这四个系统调用.默认的为set=all.&lt;/p&gt;

&lt;p&gt;-e trace=file 只跟踪有关文件操作的系统调用.&lt;/p&gt;

&lt;p&gt;-e trace=process 只跟踪有关进程控制的系统调用.&lt;/p&gt;

&lt;p&gt;-e trace=network 跟踪与网络有关的所有系统调用.&lt;/p&gt;

&lt;p&gt;-e strace=signal 跟踪所有与系统信号有关的系统调用.&lt;/p&gt;

&lt;p&gt;-e trace=ipc 跟踪所有与进程通讯有关的系统调用.&lt;/p&gt;

&lt;p&gt;-e abbrev=set 设定strace输出的系统调用的结果集.-v 等与 abbrev=none.默认为abbrev=all.&lt;/p&gt;

&lt;p&gt;-e raw=set 将指定的系统调用的参数以十六进制显示.&lt;/p&gt;

&lt;p&gt;-e signal=set 指定跟踪的系统信号.默认为all.如 signal=!SIGIO(或者signal=!io),表示不跟踪SIGIO信号.&lt;/p&gt;

&lt;p&gt;-e read=set 输出从指定文件中读出的数据.例如-e read=3,5&lt;/p&gt;

&lt;p&gt;-e write=set 输出写入到指定文件中的数据.&lt;/p&gt;

&lt;p&gt;-o filename 将strace的输出写入文件filename&lt;/p&gt;

&lt;p&gt;-p pid 跟踪指定的进程pid.&lt;/p&gt;

&lt;p&gt;-s strsize 指定输出的字符串的最大长度.默认为32.文件名一直全部输出.&lt;/p&gt;

&lt;p&gt;-u username 以username 的UID和GID执行被跟踪的命令.&lt;/p&gt;

&lt;h5 id=&quot;例子&quot;&gt;例子&lt;/h5&gt;

&lt;p&gt;&lt;a href=&quot;https://huoding.com/2013/10/06/288&quot;&gt;通过Strace定位故障原因&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;mac工具dtruss&quot;&gt;mac工具dtruss&lt;/h3&gt;

&lt;h5 id=&quot;语法-1&quot;&gt;语法&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dtruss [-acdefholLs] [-t syscall] { -p PID | -n name | command | -W name }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;参数说明-1&quot;&gt;参数说明&lt;/h5&gt;

&lt;p&gt;-a 输出全部&lt;/p&gt;

&lt;p&gt;-b bufsize&lt;br /&gt;
dynamic variable buffer size. Increase this if you notice
dynamic variable drop errors. The default is “4m” for 4
megabytes per CPU.&lt;/p&gt;

&lt;p&gt;-c 输出系统调用数&lt;/p&gt;

&lt;p&gt;-d 输出时间消耗&lt;/p&gt;

&lt;p&gt;-e 输出剩余多少时间&lt;/p&gt;

&lt;p&gt;-f 监视fork出来的进程调用&lt;/p&gt;

&lt;p&gt;-l force printing of pid/lwpid per line&lt;/p&gt;

&lt;p&gt;-L don’t print pid/lwpid per line&lt;/p&gt;

&lt;p&gt;-n name 跟踪名为name的进程&lt;/p&gt;

&lt;p&gt;-o 输出花在cpu上的时间&lt;/p&gt;

&lt;p&gt;-s 输出栈跟踪&lt;/p&gt;

&lt;p&gt;-p PID 监视某个pid&lt;/p&gt;

&lt;p&gt;-t syscall 只监视某个系统调用&lt;/p&gt;

&lt;h5 id=&quot;例子-1&quot;&gt;例子&lt;/h5&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dtruss &lt;span class=&quot;nb&quot;&gt;df&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-h&lt;/span&gt;       &lt;span class=&quot;c&quot;&gt;# run and examine &quot;df -h&quot;  &lt;/span&gt;
dtruss &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; 1871     &lt;span class=&quot;c&quot;&gt;# examine PID 1871  &lt;/span&gt;
dtruss &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;tar&lt;/span&gt;      &lt;span class=&quot;c&quot;&gt;# examine all processes called &quot;tar&quot;  &lt;/span&gt;
dtruss &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; test.sh  &lt;span class=&quot;c&quot;&gt;# run test.sh and follow children&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;参考&quot;&gt;参考&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_38712943/article/details/82149045&quot;&gt;strace&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/kfy2011/article/details/48102843&quot;&gt;系统调用跟踪命令strace和dtruss&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 07 Oct 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/10/07/strace-dtruss/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/10/07/strace-dtruss/</guid>
        
        <category>工具</category>
        
        
      </item>
    
      <item>
        <title>smarty</title>
        <description>&lt;h3 id=&quot;执行流程&quot;&gt;执行流程&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;/assets/img/posts/2018-10-07-smarty/1.jpg&quot;&gt;&lt;img src=&quot;/assets/img/posts/2018-10-07-smarty/1.jpg&quot; alt=&quot;1.jpg&quot; title=&quot;点击查看原图&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;开启缓存&quot;&gt;开启缓存&lt;/h3&gt;

&lt;div class=&quot;language-php highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$smarty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;caching&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$smarty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;cache_lifetime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3600&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;判断是否已有缓存&lt;/p&gt;

&lt;div class=&quot;language-php highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$smarty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isCached&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'index.htm'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;$smarty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;display&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'index.htm'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// do something&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$smarty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;display&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'index.htm'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;清除缓存&quot;&gt;清除缓存&lt;/h3&gt;

&lt;h5 id=&quot;单个页面缓存&quot;&gt;单个页面缓存&lt;/h5&gt;

&lt;div class=&quot;language-php highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$smarty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;clearCache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'index.htm'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;全部页面缓存&quot;&gt;全部页面缓存&lt;/h5&gt;

&lt;div class=&quot;language-php highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$smarty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;clearAllCache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;局部缓存&quot;&gt;局部缓存&lt;/h3&gt;

&lt;h5 id=&quot;变量&quot;&gt;变量&lt;/h5&gt;

&lt;div class=&quot;language-php highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 第三个参数 true 表示不缓存&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$smarty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;assign&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'var'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'value'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;模板变量&quot;&gt;模板变量&lt;/h5&gt;

&lt;div class=&quot;language-smarty highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$num&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;nocache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;模板局部&quot;&gt;模板局部&lt;/h5&gt;

&lt;div class=&quot;language-smarty highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;nocache&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;div&amp;gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$title&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;br/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;div&amp;gt;&lt;/span&gt;评论数：&lt;span class=&quot;k&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$num&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;{/&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;nocache&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;单页面多缓存&quot;&gt;单页面多缓存&lt;/h3&gt;

&lt;p&gt;display拥有第二个参数，我们可以把需要改变的变量放入第二个参数就可以实现根据不同的请求生成不同的缓存！常用于详细内容页。&lt;/p&gt;

&lt;div class=&quot;language-php highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$smarty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;display&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'index.htm'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//集合&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$smarty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;display&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'index.htm'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$id1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'|'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$id2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;局限性&quot;&gt;局限性&lt;/h3&gt;

&lt;p&gt;1.当缓存文件过多，cpu需要耗在遍历文件。&lt;/p&gt;

&lt;p&gt;可以通过设置支持目录分级&lt;/p&gt;

&lt;div class=&quot;language-php highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$smarty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;use_sub_dirs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;2.缓存文件存在I/O消耗。&lt;/p&gt;

&lt;p&gt;可以把缓存内容存到内存中。&lt;/p&gt;

&lt;h3 id=&quot;参考&quot;&gt;参考&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://jingyan.baidu.com/album/ea24bc39c0d376da62b331a4.html?picindex=1&quot;&gt;Smarty缓存技术完整的执行流程&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 07 Oct 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/10/07/smarty/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/10/07/smarty/</guid>
        
        <category>php</category>
        
        
      </item>
    
      <item>
        <title>php加速器</title>
        <description>&lt;h3 id=&quot;opcache推荐&quot;&gt;opcache(推荐)&lt;/h3&gt;

&lt;p&gt;新一代PHP加速器，由Zend公司研发，其实现原理与Xcache类似，都是把PHP执行后的数据缓冲到内存中从而避免重复的编译过程，能够直接使用缓冲区已编译的代码从而提高速度，降低服务器负载，但性能却比Xcache更加优越。&lt;/p&gt;

&lt;p&gt;PHP 5.5.0 及后续版本中已经绑定了 opcache 扩展。 对于 PHP 5.2，5.3 和 5.4 版本可以使用PECL扩展中的 opcache 库。&lt;/p&gt;

&lt;h5 id=&quot;配置说明&quot;&gt;配置说明&lt;/h5&gt;

&lt;div class=&quot;language-ini highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;py&quot;&gt;opcache.enable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;1 (default &quot;1&quot;)&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;;OPcache打开/关闭开关。当设置为Off或者0时，会关闭Opcache, 代码没有被优化和缓存。
&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;opcache.enable_cli&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;1 (default &quot;0&quot;)&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;;CLI环境下，PHP启用OPcache。这主要是为了测试和调试。从 PHP 7.1.2 开始，默认启用。
&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;opcache.memory_consumption&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;128 (default &quot;64&quot;)&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;;OPcache共享内存存储大小。用于存储预编译的opcode（以MB为单位）。
&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;opcache.interned_strings_buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;8 (default &quot;4&quot;)&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;;这是一个很有用的选项，但是似乎完全没有文档说明。PHP使用了一种叫做字符串驻留（string interning）的技术来改善性能。例如，如果你在代码中使用了1000次字符串“foobar”，在PHP内部只会在第一使用这个字符串的时候分配一个不可变的内存区域来存储这个字符串，其他的999次使用都会直接指向这个内存区域。这个选项则会把这个特性提升一个层次——默认情况下这个不可变的内存区域只会存在于单个php-fpm的进程中，如果设置了这个选项，那么它将会在所有的php-fpm进程中共享。在比较大的应用中，这可以非常有效地节约内存，提高应用的性能。
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;这个选项的值是以兆字节（megabytes）作为单位，如果把它设置为16，则表示16MB，默认是4MB，这是一个比较低的值。&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;opcache.max_accelerated_files&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;(default&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&quot;2000&quot;)&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;;这个选项用于控制内存中最多可以缓存多少个PHP文件。这个选项必须得设置得足够大，大于你的项目中的所有PHP文件的总和。
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;设置值取值范围最小值是&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;200，最大值在&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;PHP&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;5.5.6&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;之前是&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;100000，PHP&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;5.5.6&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;及之后是&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;1000000。也就是说在200到1000000之间。&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;你可以运行“find&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-type&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-print&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;grep&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;php&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;wc&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-l”这个命令来快速计算你的代码库中的PHP文件数。&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;opcache.max_wasted_percentage&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;(default&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&quot;5&quot;)&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;;计划重新启动之前，“浪费”内存的最大百分比。
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;opcache.use_cwd&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;(default&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&quot;1&quot;)&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;;如果启用，OPcache将在哈希表的脚本键之后附加改脚本的工作目录， 以避免同名脚本冲突的问题。禁用此选项可以提高性能，但是可能会导致应用崩溃
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;opcache.validate_timestamps&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;(default&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&quot;1&quot;)&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;;如果启用（设置为1），OPcache会在opcache.revalidate_freq设置的秒数去检测文件的时间戳（timestamp）检查脚本是否更新。
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;如果这个选项被禁用（设置为0），opcache.revalidate_freq会被忽略，PHP文件永远不会被检查。这意味着如果你修改了你的代码，然后你把它更新到服务器上，再在浏览器上请求更新的代码对应的功能，你会看不到更新的效果，你必须使用&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;`opcache_reset()`&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;或者&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;`opcache_invalidate()`&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;函数来手动重置&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;OPcache。或者重重你的web服务器或者php-fpm&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;来使文件系统更改生效。&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;我强烈建议你在生产环境中设置为0，why？因为当你在更新服务器代码的时候，如果代码较多，更新操作是有些延迟的，在这个延迟的过程中必然出现老代码和新代码混合的情况，这个时候对用户请求的处理必然存在不确定性。最后，等所有的代码更新完毕后，再平滑重启PHP和web服务器。&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;opcache.revalidate_freq&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;(default&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&quot;2&quot;)&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;;这个选项用于设置缓存的过期时间（单位是秒），当这个时间达到后，opcache会检查你的代码是否改变，如果改变了PHP会重新编译它，生成新的opcode，并且更新缓存。值为“0”表示每次请求都会检查你的PHP代码是否更新（这意味着会增加很多次stat系统调用，译注：stat系统调用是读取文件的状态，这里主要是获取最近修改时间，这个系统调用会发生磁盘I/O，所以必然会消耗一些CPU时间，当然系统调用本身也会消耗一些CPU时间）。可以在开发环境中把它设置为0，生产环境下不用管。
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;如果&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;`opcache.validate_timestamps`&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;配置指令设置为禁用（设置为0），那么此设置项将会被忽略。&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;opcache.revalidate_path&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;(default&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&quot;0&quot;)&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;;在include_path优化中启用或禁用文件搜索
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;如果被禁用，并且找到了使用的缓存文件相同的include_path，该文件不被再次搜索。因此，如果一个文件与include_path中的其他地方相同的名称出现将不会被发现。如果此优化对此有效，请启用此指令你的应用程序，这个指令的默认值是禁用的，这意味着该优化是活跃的。&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;opcache.fast_shutdown（默认“0”）&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;;如果启用，则会使用快速停止续发事件。 所谓快速停止续发事件是指依赖 Zend 引擎的内存管理模块 一次释放全部请求变量的内存，而不是依次释放每一个已分配的内存块。
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;该指令已在PHP&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;7.2.0中被删除。快速关机序列的一个变种已经被集成到PHP中，并且如果可能的话将被自动使用。&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;其他加速器&quot;&gt;其他加速器&lt;/h3&gt;

&lt;h5 id=&quot;apc&quot;&gt;APC&lt;/h5&gt;

&lt;p&gt;Alternative PHP Cache (APC) 是一个开放自由的PHP opcode缓存。它的目标是提供一个自由、 开放，和健全的框架用于缓存和优化PHP的中间代码。 它是PHP PECL中的一个扩展。&lt;/p&gt;

&lt;h5 id=&quot;xcache&quot;&gt;xcache&lt;/h5&gt;

&lt;p&gt;XCache是国人自己开发的东西，性能比早期的eAccelerator加速器要优良。&lt;/p&gt;

&lt;h5 id=&quot;eaccelerator&quot;&gt;eAccelerator&lt;/h5&gt;

&lt;p&gt;eAccelerator的前身其实是truck-mmcache，因为开发truk-mmcache的人被Zend给招安了，所以开发eAccelerator的人继承了truk-mmcache的一些特性，设计出eAccelerator加速器。&lt;/p&gt;
</description>
        <pubDate>Sun, 07 Oct 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/10/07/opcode-cache/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/10/07/opcode-cache/</guid>
        
        <category>php</category>
        
        
      </item>
    
      <item>
        <title>nginx与php-fpm 连接数</title>
        <description>&lt;h2 id=&quot;apache连接请求机制&quot;&gt;Apache连接请求机制&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;/assets/img/posts/2018-08-11-php-nginx-connect/1.png&quot;&gt;&lt;img src=&quot;/assets/img/posts/2018-08-11-php-nginx-connect/1.png&quot; alt=&quot;1.png&quot; title=&quot;点击查看原图&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Apache的处理机制是每有一个请求就会去fork一个子进程来处理请求。&lt;br /&gt;
这样带来的缺点很明显：
当请求量大的时候，需要开启一样数量的进程，这样一来系统内存的消耗，二来cpu执行切换带来的上下文切换消耗非常大。&lt;/p&gt;

&lt;p&gt;Nginx是如何解决这些问题的呢？答案是使用I/O复用技术。
下面只是简单讲解什么是I/O复用，有兴趣的同学可以参考&lt;a href=&quot;/2018/08/04/computer-io.html&quot;&gt;I/O模型&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;nginx使用的io复用技术&quot;&gt;Nginx使用的I/O复用技术&lt;/h2&gt;

&lt;h4 id=&quot;初级io复用&quot;&gt;初级I/O复用&lt;/h4&gt;

&lt;p&gt;采用非阻塞的模式，当一个连接过来时，我们不阻塞住，这样一个进程可以同时处理多个连接了。
比如一个进程接受了10000个连接，这个进程每次从头到尾的问一遍这10000个连接：“有I/O事件没？有的话就交给我处理，没有的话我一会再来问一遍。”
然后进程就一直从头到尾问这10000个连接，如果这1000个连接都没有I/O事件，就会造成CPU的空转，并且效率也很低，不好不好。&lt;/p&gt;

&lt;h4 id=&quot;升级io复用selectpoll&quot;&gt;升级I/O复用（select、poll）&lt;/h4&gt;

&lt;p&gt;我们能不能引入一个代理，这个代理可以同时观察许多I/O流事件呢？&lt;br /&gt;
当没有I/O事件的时候，这个进程处于阻塞状态。当连接有I/O流事件产生的时候，就会去唤醒进程去处理。&lt;/p&gt;

&lt;p&gt;但是唤醒之后，因为不知道是哪个连接产生的I/O流事件，于是进程就挨个去问：“请问是你有事要处理吗？”。&lt;/p&gt;

&lt;p&gt;ps: select与poll原理是一样的，只不过select只能观察1024个连接，poll可以观察无限个连接。&lt;/p&gt;

&lt;h4 id=&quot;超级升级io复用epoll&quot;&gt;超级升级I/O复用（epoll）&lt;/h4&gt;

&lt;p&gt;有了epoll，可以知道是哪个连接产生的I/O流事件。理论上1个进程就可以无限数量的连接，而且无需轮询，真正解决了c10k的问题。&lt;/p&gt;

&lt;p&gt;nginx就是采用基于epoll的异步非阻塞服务器程序。&lt;/p&gt;

&lt;h2 id=&quot;nginx与php-fprm的连接处理&quot;&gt;nginx与php-fprm的连接处理&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;/assets/img/posts/2018-08-11-php-nginx-connect/2.png&quot;&gt;&lt;img src=&quot;/assets/img/posts/2018-08-11-php-nginx-connect/2.png&quot; alt=&quot;2.png&quot; title=&quot;点击查看原图&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;nginx&quot;&gt;nginx&lt;/h4&gt;

&lt;p&gt;worker为epoll异步处理请求。&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;worker_processes&lt;/td&gt;
      &lt;td&gt;worker数量&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;worker_connections&lt;/td&gt;
      &lt;td&gt;每个worker能处理的最大并发连接请求&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;php-fpm&quot;&gt;php-fpm&lt;/h4&gt;

&lt;p&gt;worker为poll异步处理请求。众多的 worker 进程组成了进程池，等待 master 进程分配任务，而且每个 worker 进程只能同时处理单个任务，前一个处理结束，才能为下一个服务。&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;pm&lt;/td&gt;
      &lt;td&gt;分为静态(static)和动态(dynamic)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;pm.max_children&lt;/td&gt;
      &lt;td&gt;static模式下创建的子进程数(固定)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;pm.start_servers&lt;/td&gt;
      &lt;td&gt;动态方式下的起始worker进程数量&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;pm.min_spare_servers&lt;/td&gt;
      &lt;td&gt;动态方式下服务器空闲时最小worker进程数量&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;pm.max_spare_servers&lt;/td&gt;
      &lt;td&gt;动态方式下服务器空闲时最大worker进程数量&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;超时设置&quot;&gt;超时设置&lt;/h2&gt;

&lt;h4 id=&quot;nginx-1&quot;&gt;nginx&lt;/h4&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;fastcgi_connect_timeout&lt;/td&gt;
      &lt;td&gt;后端链接时间&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;fastcgi_send_timeout&lt;/td&gt;
      &lt;td&gt;数据发送时间，两次成功发送时间差，不是整个发送时间&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;fastcgi_read_timeout&lt;/td&gt;
      &lt;td&gt;数据接收时间，两次成功接收时间差，不是整个接收时间&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;php-fpm-1&quot;&gt;php-fpm&lt;/h4&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;request_terminate_timeout&lt;/td&gt;
      &lt;td&gt;PHP脚本的最大执行时间&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;php&quot;&gt;php&lt;/h4&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;max_execution_time&lt;/td&gt;
      &lt;td&gt;PHP脚本的最大执行时间&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;ps:一些版本中php-fpm的配置会覆盖php.ini的配置，使php.ini的配置不起作用&lt;/p&gt;

&lt;h2 id=&quot;常见错误&quot;&gt;常见错误&lt;/h2&gt;

&lt;p&gt;1.502 Connection reset by peer&lt;/p&gt;

&lt;p&gt;php-fpm的worker进程执行php程序脚本时，超过了配置的最长执行时间，master进程将worker进程杀掉，直接返回502。&lt;/p&gt;

&lt;p&gt;2.502 Connection refused&lt;/p&gt;

&lt;p&gt;连接请求数(accpet之前)超出了端口所能监听的tcp连接的最大值(backlog的值)，进不了fpm等待accept的链接队列，直接返回502，这里可能会产生tcp重传。&lt;/p&gt;

&lt;p&gt;backlog的值是半连接和全连接的总和，他的存在也有短时间缓冲解耦nginx请求与fpm处理的作用，半连接指收到了syn请求，3次握手尚未建立，全连接指的是3次握手已经成功，不过尚未被accpet的请求，fpm里面有调节的参数，如果fpm的参数设置为-1，则默认走的是系统内核参数net.core.somaxconn的设置值，如果不设置可以在/proc/sys/net/core/somaxconn里查看，默认值是128，所以在连接请求较高的业务里要增大这个值。&lt;/p&gt;

&lt;p&gt;3.504 Connection timed out&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;php的worker进程池处理慢，无法尽快处理等待accept的链接队列，导致3次握手后的链接队列长时间没有被accept，nginx链接等待超时;&lt;/li&gt;
  &lt;li&gt;后端php-fpm执行脚本的时间太长，超过了nginx配置的超时机制，这个时候也是会报出504错误的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000007614502&quot;&gt;nginx、swoole高并发原理初探&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.2cto.com/net/201609/546064.html&quot;&gt;WebService之nginx+(php-fpm)结构模型剖析及优化&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 11 Aug 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/08/11/php-nginx-connect/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/08/11/php-nginx-connect/</guid>
        
        <category>php</category>
        
        
      </item>
    
      <item>
        <title>「转载」select、poll与epoll</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;转载自&lt;a href=&quot;https://cloud.tencent.com/developer/article/1005481&quot;&gt;大话 Select、Poll、Epoll&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;linux的socket-事件wakeup-callback机制&quot;&gt;Linux的socket 事件wakeup callback机制&lt;/h2&gt;

&lt;p&gt;言归正传，在介绍select、poll、epoll前，有必要说说linux(2.6+)内核的事件wakeup callback机制，这是IO多路复用机制存在的本质。Linux通过socket睡眠队列来管理所有等待socket的某个事件的process，同时通过wakeup机制来异步唤醒整个睡眠队列上等待事件的process，通知process相关事件发生。通常情况，socket的事件发生的时候，其会顺序遍历socket睡眠队列上的每个process节点，调用每个process节点挂载的callback函数。在遍历的过程中，如果遇到某个节点是排他的，那么就终止遍历，总体上会涉及两大逻辑：（1）睡眠等待逻辑；（2）唤醒逻辑。&lt;/p&gt;

&lt;p&gt;（1）睡眠等待逻辑：涉及select、poll、epoll_wait的阻塞等待逻辑&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;[1]select、poll、epoll_wait陷入内核，判断监控的socket是否有关心的事件发生了，如果没，则为当前process构建一个wait_entry节点，然后插入到监控socket的sleep_list  &lt;br /&gt;
[2]进入循环的schedule直到关心的事件发生了  &lt;br /&gt;
[3]关心的事件发生后，将当前process的wait_entry节点从socket的sleep_list中删除。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;（2）唤醒逻辑：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;[1]socket的事件发生了，然后socket顺序遍历其睡眠队列，依次调用每个wait_entry节点的callback函数  &lt;br /&gt;
[2]直到完成队列的遍历或遇到某个wait_entry节点是排他的才停止。  &lt;br /&gt;
[3]一般情况下callback包含两个逻辑：1.wait_entry自定义的私有逻辑；2.唤醒的公共逻辑，主要用于将该wait_entry的process放入CPU的就绪队列，让CPU随后可以调度其执行。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;下面就上面的两大逻辑，分别阐述select、poll、epoll的异同，为什么epoll能够比select、poll高效。&lt;/p&gt;

&lt;h2 id=&quot;select&quot;&gt;Select&lt;/h2&gt;

&lt;p&gt;在一个高性能的网络服务上，大多情况下一个服务进程(线程)process需要同时处理多个socket，我们需要公平对待所有socket，对于read而言，那个socket有数据可读，process就去读取该socket的数据来处理。于是对于read，一个朴素的需求就是关心的N个socket是否有数据”可读”，也就是我们期待”可读”事件的通知，而不是盲目地对每个socket调用recv/recvfrom来尝试接收数据。我们应该block在等待事件的发生上，这个事件简单点就是”关心的N个socket中一个或多个socket有数据可读了”，当block解除的时候，就意味着，我们一定可以找到一个或多个socket上有可读的数据。另一方面，根据上面的socket wakeup callback机制，我们不知道什么时候，哪个socket会有读事件发生，于是，process需要同时插入到这N个socket的sleep_list上等待任意一个socket可读事件发生而被唤醒，当时process被唤醒的时候，其callback里面应该有个逻辑去检查具体那些socket可读了。&lt;/p&gt;

&lt;p&gt;于是，select的多路复用逻辑就清晰了，select为每个socket引入一个poll逻辑，该poll逻辑用于收集socket发生的事件，对于可读事件来说，简单伪码如下：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;poll&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    //其他逻辑
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;recieve queque is not empty&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        sk_event |&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; POLL_IN；
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
   //其他逻辑
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;接下来就到select的逻辑了，下面是select的函数原型：5个参数，后面4个参数都是in/out类型(值可能会被修改返回)&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int &lt;span class=&quot;k&quot;&gt;select&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;int nfds, fd_set &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;readfds, fd_set &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;writefds, fd_set &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;exceptfds, struct timeval &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;timeout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;当用户process调用select的时候，select会将需要监控的readfds集合拷贝到内核空间（假设监控的仅仅是socket可读），然后遍历自己监控的socket sk，挨个调用sk的poll逻辑以便检查该sk是否有可读事件，遍历完所有的sk后，如果没有任何一个sk可读，那么select会调用schedule_timeout进入schedule循环，使得process进入睡眠。如果在timeout时间内某个sk上有数据可读了，或者等待timeout了，则调用select的process会被唤醒，接下来select就是遍历监控的sk集合，挨个收集可读事件并返回给用户了，相应的伪码如下：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;sk &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;readfds&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    sk_event.evt &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; sk.poll&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    sk_event.sk &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; sk&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    ret_event_for_process&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;通过上面的select逻辑过程分析，相信大家都意识到，select存在两个问题：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;[1] 被监控的fds需要从用户空间拷贝到内核空间  &lt;br /&gt;
   为了减少数据拷贝带来的性能损坏，内核对被监控的fds集合大小做了限制，并且这个是通过宏控制的，大小不可改变(限制为1024)。  &lt;br /&gt;
[2] 被监控的fds集合中，只要有一个有数据可读，整个socket集合就会被遍历一次调用sk的poll函数收集可读事件  &lt;br /&gt;
   由于当初的需求是朴素，仅仅关心是否有数据可读这样一个事件，当事件通知来的时候，由于数据的到来是异步的，我们不知道事件来的时候，有多少个被监控的socket有数据可读了，于是，只能挨个遍历每个socket来收集可读事件。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;到这里，我们有三个问题需要解决：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;被监控的fds集合限制为1024，1024太小了，我们希望能够有个比较大的可监控fds集合&lt;/li&gt;
  &lt;li&gt;fds集合需要从用户空间拷贝到内核空间的问题，我们希望不需要拷贝&lt;/li&gt;
  &lt;li&gt;当被监控的fds中某些有数据可读的时候，我们希望通知更加精细一点，就是我们希望能够从通知中得到有可读事件的fds列表，而不是需要遍历整个fds来收集。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;通知中得到有可读事件的fds列表，而不是需要遍历整个fds来收集。&lt;/p&gt;

&lt;h2 id=&quot;poll&quot;&gt;poll&lt;/h2&gt;

&lt;p&gt;select遗留的三个问题中，问题(1)是用法限制问题，问题(2)和(3)则是性能问题。poll和select非常相似，poll并没着手解决性能问题，poll只是解决了select的问题(1)fds集合大小1024限制问题。下面是poll的函数原型，poll改变了fds集合的描述方式，使用了pollfd结构而不是select的fd_set结构，使得poll支持的fds集合限制远大于select的1024。poll虽然解决了fds集合大小1024的限制问题，但是，它并没改变大量描述符数组被整体复制于用户态和内核态的地址空间之间，以及个别描述符就绪触发整体描述符集合的遍历的低效问题。poll随着监控的socket集合的增加性能线性下降，poll不适合用于大并发场景。&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int poll&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;struct pollfd &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;fds, nfds_t nfds, int &lt;span class=&quot;nb&quot;&gt;timeout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;epoll&quot;&gt;epoll&lt;/h2&gt;

&lt;p&gt;select遗留的三个问题，问题(1)是比较好解决，poll简单两三下就解决掉了，但是poll的解决有点鸡肋。要解决问题(2)和(3)似乎比较棘手，要怎么解决呢？我们知道，在计算机行业中，有两种解决问题的思想：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;[1] 计算机科学领域的任何问题, 都可以通过添加一个中间层来解决  &lt;br /&gt;
[2] 变集中(中央)处理为分散(分布式)处理&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;下面，我们看看，epoll在解决select的遗留问题(2)和(3)的时候，怎么运用这两个思想的。&lt;/p&gt;

&lt;h4 id=&quot;fds集合拷贝问题的解决&quot;&gt;fds集合拷贝问题的解决&lt;/h4&gt;

&lt;p&gt;对于IO多路复用，有两件事是必须要做的(对于监控可读事件而言)：1. 准备好需要监控的fds集合；2. 探测并返回fds集合中哪些fd可读了。细看select或poll的函数原型，我们会发现，每次调用select或poll都在重复地准备(集中处理)整个需要监控的fds集合。然而对于频繁调用的select或poll而言，fds集合的变化频率要低得多，我们没必要每次都重新准备(集中处理)整个fds集合。&lt;/p&gt;

&lt;p&gt;于是，epoll引入了epoll_ctl系统调用，将高频调用的epoll_wait和低频的epoll_ctl隔离开。同时，epoll_ctl通过(EPOLL_CTL_ADD、EPOLL_CTL_MOD、EPOLL_CTL_DEL)三个操作来分散对需要监控的fds集合的修改，做到了有变化才变更，将select或poll高频、大块内存拷贝(集中处理)变成epoll_ctl的低频、小块内存的拷贝(分散处理)，避免了大量的内存拷贝。同时，对于高频epoll_wait的可读就绪的fd集合返回的拷贝问题，epoll通过内核与用户空间mmap(内存映射)同一块内存来解决。mmap将用户空间的一块地址和内核空间的一块地址同时映射到相同的一块物理内存地址（不管是用户空间还是内核空间都是虚拟地址，最终要通过地址映射映射到物理地址），使得这块物理内存对内核和对用户均可见，减少用户态和内核态之间的数据交换。&lt;/p&gt;

&lt;p&gt;另外，epoll通过epoll_ctl来对监控的fds集合来进行增、删、改，那么必须涉及到fd的快速查找问题，于是，一个低时间复杂度的增、删、改、查的数据结构来组织被监控的fds集合是必不可少的了。在linux 2.6.8之前的内核，epoll使用hash来组织fds集合，于是在创建epoll fd的时候，epoll需要初始化hash的大小。于是epoll_create(int size)有一个参数size，以便内核根据size的大小来分配hash的大小。在linux 2.6.8以后的内核中，epoll使用红黑树来组织监控的fds集合，于是epoll_create(int size)的参数size实际上已经没有意义了。&lt;/p&gt;

&lt;h4 id=&quot;按需遍历就绪的fds集合&quot;&gt;按需遍历就绪的fds集合&lt;/h4&gt;

&lt;p&gt;通过上面的socket的睡眠队列唤醒逻辑我们知道，socket唤醒睡眠在其睡眠队列的wait_entry(process)的时候会调用wait_entry的回调函数callback，并且，我们可以在callback中做任何事情。为了做到只遍历就绪的fd，我们需要有个地方来组织那些已经就绪的fd。为此，epoll引入了一个中间层，一个双向链表(ready_list)，一个单独的睡眠队列(single_epoll_wait_list)，并且，与select或poll不同的是，epoll的process不需要同时插入到多路复用的socket集合的所有睡眠队列中，相反process只是插入到中间层的epoll的单独睡眠队列中，process睡眠在epoll的单独队列上，等待事件的发生。同时，引入一个中间的wait_entry_sk，它与某个socket sk密切相关，wait_entry_sk睡眠在sk的睡眠队列上，其callback函数逻辑是将当前sk排入到epoll的ready_list中，并唤醒epoll的single_epoll_wait_list。而single_epoll_wait_list上睡眠的process的回调函数就明朗了：遍历ready_list上的所有sk，挨个调用sk的poll函数收集事件，然后唤醒process从epoll_wait返回。
于是，整个过来可以分为以下几个逻辑：&lt;/p&gt;

&lt;p&gt;（1）epoll_ctl EPOLL_CTL_ADD逻辑&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;[1] 构建睡眠实体wait_entry_sk，将当前socket sk关联给wait_entry_sk，并设置wait_entry_sk的回调函数为epoll_callback_sk  &lt;br /&gt;
[2] 将wait_entry_sk排入当前socket sk的睡眠队列上&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;回调函数epoll_callback_sk的逻辑如下：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;[1] 将之前关联的sk排入epoll的ready_list  &lt;br /&gt;
[2] 然后唤醒epoll的单独睡眠队列single_epoll_wait_list&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;（2）epoll_wait逻辑&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;[1] 构建睡眠实体wait_entry_proc，将当前process关联给wait_entry_proc，并设置回调函数为epoll_callback_proc  &lt;br /&gt;
[2] 判断epoll的ready_list是否为空，如果为空，则将wait_entry_proc排入epoll的single_epoll_wait_list中，随后进入schedule循环，这会导致调用
epoll_wait的process睡眠。  &lt;br /&gt;
[3] wait_entry_proc被事件唤醒或超时醒来，wait_entry_proc将被从single_epoll_wait_list移除掉，然后wait_entry_proc执行回调函数epoll_callback_proc&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;回调函数epoll_callback_proc的逻辑如下：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;[1] 遍历epoll的ready_list，挨个调用每个sk的poll逻辑收集发生的事件，对于监控可读事件而已，ready_list上的每个sk都是有数据可读的，这里的遍历必要的(不同于select/poll的遍历，它不管有没数据可读都需要遍历一些来判断，这样就做了很多无用功。)  &lt;br /&gt;
[2] 将每个sk收集到的事件，通过epoll_wait传入的events数组回传并唤醒相应的process。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;（3）epoll唤醒逻辑&lt;/p&gt;

&lt;p&gt;整个epoll的协议栈唤醒逻辑如下(对于可读事件而言)：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;[1] 协议数据包到达网卡并被排入socket sk的接收队列  &lt;br /&gt;
[2] 睡眠在sk的睡眠队列wait_entry被唤醒，wait_entry_sk的回调函数epoll_callback_sk被执行  &lt;br /&gt;
[3] epoll_callback_sk将当前sk插入epoll的ready_list中  &lt;br /&gt;
[4] 唤醒睡眠在epoll的单独睡眠队列single_epoll_wait_list的wait_entry，wait_entry_proc被唤醒执行回调函数epoll_callback_proc  &lt;br /&gt;
[5] 遍历epoll的ready_list，挨个调用每个sk的poll逻辑收集发生的事件  &lt;br /&gt;
[6] 将每个sk收集到的事件，通过epoll_wait传入的events数组回传并唤醒相应的process。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;epoll巧妙的引入一个中间层解决了大量监控socket的无效遍历问题。细心的同学会发现，epoll在中间层上为每个监控的socket准备了一个单独的回调函数epoll_callback_sk，而对于select/poll，所有的socket都公用一个相同的回调函数。正是这个单独的回调epoll_callback_sk使得每个socket都能单独处理自身，当自己就绪的时候将自身socket挂入epoll的ready_list。同时，epoll引入了一个睡眠队列single_epoll_wait_list，分割了两类睡眠等待。process不再睡眠在所有的socket的睡眠队列上，而是睡眠在epoll的睡眠队列上，在等待”任意一个socket可读就绪”事件。而中间wait_entry_sk则代替process睡眠在具体的socket上，当socket就绪的时候，它就可以处理自身了。&lt;/p&gt;
</description>
        <pubDate>Sun, 05 Aug 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/08/05/computer-select-poll-epoll/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/08/05/computer-select-poll-epoll/</guid>
        
        <category>计算机</category>
        
        <category>转载</category>
        
        
      </item>
    
      <item>
        <title>I/O模型</title>
        <description>&lt;p&gt;I/O发生过程涉及的对象：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;调用该IO的线程(thread)&lt;/li&gt;
  &lt;li&gt;系统内核(kernel)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I/O发生过程步骤：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;等待数据准备&lt;/li&gt;
  &lt;li&gt;将数据从内核拷贝到用户的进程空间。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;阻塞型ioblocking-io&quot;&gt;阻塞型I/O（blocking I/O）&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;/assets/img/posts/2018-08-04-computer-io/1.jpg&quot;&gt;&lt;img src=&quot;/assets/img/posts/2018-08-04-computer-io/1.jpg&quot; alt=&quot;1.jpg&quot; title=&quot;点击查看原图&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;用户thread在整个过程当中，都需要等待kernel返回数据，所以整个过程都是被block的。&lt;/p&gt;

&lt;h4 id=&quot;非阻塞型ionon-blocking-io&quot;&gt;非阻塞型I/O（non-blocking I/O）&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;/assets/img/posts/2018-08-04-computer-io/2.jpg&quot;&gt;&lt;img src=&quot;/assets/img/posts/2018-08-04-computer-io/2.jpg&quot; alt=&quot;2.jpg&quot; title=&quot;点击查看原图&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;等待数据阶段，如果请求的数据没准备好，kernel会返回失败，用户thread是采用轮询方式进行的，所以在这个阶段不会被block。&lt;br /&gt;
拷贝数据阶段，当kernel返回成功，则发送拷贝数据请求，等待kennel把数据从内核拷贝到用户空间，所以这个阶段是被block的。&lt;/p&gt;

&lt;h4 id=&quot;io复用io-multiplexing&quot;&gt;I/O复用（IO multiplexing）&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;/assets/img/posts/2018-08-04-computer-io/3.jpg&quot;&gt;&lt;img src=&quot;/assets/img/posts/2018-08-04-computer-io/3.jpg&quot; alt=&quot;3.jpg&quot; title=&quot;点击查看原图&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;我们常用的select、epoll都是使用这种模型。&lt;br /&gt;
等待数据阶段，用户调用了select，并等待select返回结果，这个阶段是被block的。&lt;br /&gt;
读取数据阶段，当select返回了可读结果，则发送拷贝数据请求，等待kennel把数据从内核拷贝到用户空间，这个阶段也是被block的。&lt;/p&gt;

&lt;p&gt;这么看来其实I/O复用还不如阻塞I/O，虽然整个过程同样都是被block的，但需要发送两次系统请求，性能会有所下降。&lt;br /&gt;
用select的优势在于它可以同时处理多个connection。（多说一句。所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。&lt;/p&gt;

&lt;h4 id=&quot;异步ioasynchronous-io&quot;&gt;异步I/O（asynchronous I/O）&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;/assets/img/posts/2018-08-04-computer-io/4.jpg&quot;&gt;&lt;img src=&quot;/assets/img/posts/2018-08-04-computer-io/4.jpg&quot; alt=&quot;4.jpg&quot; title=&quot;点击查看原图&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;等待数据阶段，用户发送请求之后kernel会立即返回结果，之后用户进程就可以去处理其他事情了，这个阶段不会被block。  &lt;br /&gt;
拷贝数据阶段，用户也不需要感知，kernel在数据准备好之后，会立刻被数据拷贝到用户进程空间，然后给用户进程发信号去读取，这个阶段也不会被block。&lt;/p&gt;

&lt;h4 id=&quot;信号驱动io-signal-driven-io&quot;&gt;信号驱动I/O (signal-driven I/O）&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;/assets/img/posts/2018-08-04-computer-io/5.jpg&quot;&gt;&lt;img src=&quot;/assets/img/posts/2018-08-04-computer-io/5.jpg&quot; alt=&quot;5.jpg&quot; title=&quot;点击查看原图&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;对比&quot;&gt;对比&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;/assets/img/posts/2018-08-04-computer-io/.jpg&quot;&gt;&lt;img src=&quot;/assets/img/posts/2018-08-04-computer-io/6.jpg&quot; alt=&quot;6.jpg&quot; title=&quot;点击查看原图&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;同步和异步&lt;br /&gt;
其实只要判断在整个过程中，用户能不能去处理其他事情，如果能，就是异步，不能，就是同步。&lt;/p&gt;

&lt;p&gt;阻塞与非阻塞  &lt;br /&gt;
如果需要等待kernel返回结果，这个进程就会被block。所以主要判断用户是否需要等待kernel返回结果。&lt;br /&gt;
从这个点看，其实非阻塞I/O并不能完全算是非阻塞，毕竟拷贝数据阶段也是被block的。&lt;/p&gt;
</description>
        <pubDate>Sat, 04 Aug 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/08/04/computer-io/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/08/04/computer-io/</guid>
        
        <category>计算机</category>
        
        
      </item>
    
      <item>
        <title>进程与线程</title>
        <description>&lt;p&gt;先理解一下，什么是进程和线程：&lt;/p&gt;

&lt;p&gt;在现代操作系统中，进程支持多线程。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;进程是资源管理的最小单元；&lt;/li&gt;
  &lt;li&gt;线程是程序执行的最小单元。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;它们之间的关系如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/img/posts/2018-07-29-computer-thread/1.png&quot;&gt;&lt;img src=&quot;/assets/img/posts/2018-07-29-computer-thread/1.png&quot; alt=&quot;1.png&quot; title=&quot;点击查看原图&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;那么什么是程序执行的最小单位呢？&lt;/p&gt;

&lt;p&gt;线程作为调度和分配的基本单位（也被称为轻量级进程），这是因为他们共享进程的资源，所以没有太多的内存消耗。&lt;/p&gt;

&lt;p&gt;当多个程序同时在执行的时候，我们的cpu（当cpu数小于程序数）并不能同时处理，cpu将会按照自己的逻辑排优先级，每次分配一定数量的时间片（1时间片=10ms），执行完时间片时间，就必须挂起等待，轮到其他程序执行，以此类推，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/img/posts/2018-07-29-computer-thread/2.png&quot;&gt;&lt;img src=&quot;/assets/img/posts/2018-07-29-computer-thread/2.png&quot; alt=&quot;2.png&quot; title=&quot;点击查看原图&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;当然cpu并不认识我们的程序，它只认进程里面的线程，所以是分配时间片给线程。&lt;/p&gt;

&lt;p&gt;我们上面所说的线程都是指内核级线程，即系统知道该线程的存在。  &lt;br /&gt;
还有一种是&lt;strong&gt;用户级线程&lt;/strong&gt;，由程序的线程库产生的，这种是系统不知道该线程存在的，所以可以认为是程序自己实现的虚拟线程。如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/img/posts/2018-07-29-computer-thread/3.png&quot;&gt;&lt;img src=&quot;/assets/img/posts/2018-07-29-computer-thread/3.png&quot; alt=&quot;3.png&quot; title=&quot;点击查看原图&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;用户级线程与内核级线程的区别：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;用户级线程是共享进程资源的，切换不需要有上下文切换的消耗，这是因为内核级线程切换通常会跨进程，所以需要把资源存储到其他地方，等轮到它执行时，再把资源拿回来。&lt;/li&gt;
  &lt;li&gt;用户级线程如果其中一个处于阻塞，则派生它的内核级线程也会被阻塞，因为系统不知道这个线程存在。而内核级别线程不会有这个问题。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 29 Jul 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/07/29/computer-thread/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/07/29/computer-thread/</guid>
        
        <category>计算机</category>
        
        
      </item>
    
      <item>
        <title>「构建高性能web站点」服务器并发</title>
        <description>&lt;h4 id=&quot;吞吐率&quot;&gt;吞吐率&lt;/h4&gt;

&lt;p&gt;单位时间内服务器处理的请求数 reqs/s&lt;/p&gt;

&lt;h4 id=&quot;用户并发数&quot;&gt;用户并发数&lt;/h4&gt;

&lt;p&gt;服务器最大并发数是有一定的利益前提的，就是服务器和用户双方所能接受的最大利益下。&lt;br /&gt;
每个用户可以在同一时间发起不止一个请求（与浏览器、http版本有关），所以用户并发数 &amp;gt; 请求并发数。&lt;/p&gt;

&lt;h4 id=&quot;请求等待时间&quot;&gt;请求等待时间&lt;/h4&gt;

&lt;p&gt;分为以下两种&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;用户平均请求等待时间。&lt;/li&gt;
  &lt;li&gt;服务器平均请求处理时间（等于吞吐率的倒数）。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;线程与进程&quot;&gt;线程与进程&lt;/h4&gt;

&lt;p&gt;参考这篇文章&lt;a href=&quot;/2018/07/29/computer-thread/&quot;&gt;进程与线程&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;系统负载&quot;&gt;系统负载&lt;/h4&gt;

&lt;p&gt;可以通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;cat /proc/loadavg&lt;/code&gt; 或者 &lt;code class=&quot;highlighter-rouge&quot;&gt;top&lt;/code&gt; 查看。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/2018-07-27-bhpws-service/1.jpg&quot; alt=&quot;1.jpg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上面数字的含义：&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;10/200&lt;/td&gt;
      &lt;td&gt;10表示此时运行队列中的进程个数；200表示此时的进程总数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;17145&lt;/td&gt;
      &lt;td&gt;目前创建的最后一个进程ID&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1.63&lt;/td&gt;
      &lt;td&gt;1分钟内运行队列中就绪等待的进程数平均值&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0.48&lt;/td&gt;
      &lt;td&gt;5分钟内运行队列中就绪等待的进程数平均值&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0.21&lt;/td&gt;
      &lt;td&gt;10分钟内运行队列中就绪等待的进程数平均值&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;io模型&quot;&gt;I/O模型&lt;/h4&gt;

&lt;p&gt;参考这篇文章&lt;a href=&quot;/2018/08/04/computer-io/&quot;&gt;I/O模型&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 27 Jul 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/07/27/bhpws-service/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/07/27/bhpws-service/</guid>
        
        <category>web</category>
        
        
      </item>
    
      <item>
        <title>PerconaToolkit工具集合</title>
        <description>&lt;h3 id=&quot;pt-align&quot;&gt;pt-align&lt;/h3&gt;

&lt;p&gt;将其它工具的输出按列对齐。&lt;/p&gt;

&lt;h3 id=&quot;pt-archiver&quot;&gt;pt-archiver&lt;/h3&gt;

&lt;p&gt;将数据归档到另一张表或者文件。&lt;/p&gt;

&lt;h3 id=&quot;pt-config-diff&quot;&gt;pt-config-diff&lt;/h3&gt;

&lt;p&gt;对比数据库配置、环境变量差异&lt;/p&gt;

&lt;h3 id=&quot;pt-deadlock-logger&quot;&gt;pt-deadlock-logger&lt;/h3&gt;

&lt;p&gt;记录死锁日志，并保存到文件或者数据表&lt;/p&gt;

&lt;h3 id=&quot;pt-diskstats&quot;&gt;pt-diskstats&lt;/h3&gt;

&lt;p&gt;功能和iostat类似，给出磁盘的I/O统计信息&lt;/p&gt;

&lt;h3 id=&quot;pt-duplicate-key-checker&quot;&gt;pt-duplicate-key-checker&lt;/h3&gt;

&lt;p&gt;检测表中重复多余的索引或者主键&lt;/p&gt;

&lt;h3 id=&quot;pt-fifo-split&quot;&gt;pt-fifo-split&lt;/h3&gt;

&lt;p&gt;文件分割&lt;/p&gt;

&lt;h3 id=&quot;pt-find&quot;&gt;pt-find&lt;/h3&gt;

&lt;p&gt;按条件查找、排序数据库表&lt;/p&gt;

&lt;h3 id=&quot;pt-fingerprint&quot;&gt;pt-fingerprint&lt;/h3&gt;

&lt;p&gt;将sql转为绑定形式&lt;/p&gt;

&lt;h3 id=&quot;pt-fk-error-logger&quot;&gt;pt-fk-error-logger&lt;/h3&gt;

&lt;p&gt;记录外键错误&lt;/p&gt;

&lt;h3 id=&quot;pt-heartbeat&quot;&gt;pt-heartbeat&lt;/h3&gt;

&lt;p&gt;监控备库延迟&lt;/p&gt;

&lt;h3 id=&quot;pt-index-usage&quot;&gt;pt-index-usage&lt;/h3&gt;

&lt;p&gt;能够从日志当中分析索引的使用情况&lt;/p&gt;

&lt;h3 id=&quot;pt-kill&quot;&gt;pt-kill&lt;/h3&gt;

&lt;p&gt;杀死mysql会话&lt;/p&gt;

&lt;h3 id=&quot;pt-summary&quot;&gt;pt-summary&lt;/h3&gt;

&lt;p&gt;查看系统摘要报告&lt;/p&gt;

&lt;p&gt;打印出来的信息包括：CPU、内存、硬盘、网卡等信息，还包括文件系统、磁盘调度和队列大小、LVM、RAID、网络链接信息、netstat 的统计，以及前10的负载占用信息和vmstat信息。&lt;/p&gt;

&lt;h3 id=&quot;pt-online-schema-change&quot;&gt;pt-online-schema-change&lt;/h3&gt;

&lt;p&gt;可以在执行ALTER语句中，不堵塞数据库表格的写操作。&lt;/p&gt;

&lt;h3 id=&quot;pt-pmp&quot;&gt;pt-pmp&lt;/h3&gt;

&lt;p&gt;获取MySQL的堆栈信息&lt;/p&gt;

&lt;h3 id=&quot;pt-query-digest&quot;&gt;pt-query-digest&lt;/h3&gt;

&lt;p&gt;分析mysql慢查询的一个工具，它可以分析binlog、General log、slowlog，也可以通过SHOWPROCESSLIST或者通过tcpdump抓取的MySQL协议数据来进行分析。&lt;/p&gt;

&lt;h3 id=&quot;pt-show-grants&quot;&gt;pt-show-grants&lt;/h3&gt;

&lt;p&gt;格式化打印输出MySQL上的赋权，以便你可以有效地复制、比较以及版本控制。&lt;/p&gt;

&lt;h3 id=&quot;pt-slave-delay&quot;&gt;pt-slave-delay&lt;/h3&gt;

&lt;p&gt;让主库的操作延迟写入到从库&lt;/p&gt;

&lt;h3 id=&quot;pt-slave-find&quot;&gt;pt-slave-find&lt;/h3&gt;

&lt;p&gt;查找和打印MySQL从库的复制层次树&lt;/p&gt;

&lt;h3 id=&quot;pt-slave-restart&quot;&gt;pt-slave-restart&lt;/h3&gt;

&lt;p&gt;监控一个或者多个MySQL复制slave的错误，然后当复制停止时试图重启。&lt;/p&gt;

&lt;h3 id=&quot;pt-stalk&quot;&gt;pt-stalk&lt;/h3&gt;

&lt;p&gt;mysql 性能瓶颈是值得关注的，但往往出现问题的时候，总是持续那么一点时间，没能抓住事故现场，从而无法分析.pt-stalk 是一款当条件触发时,记录相关系统信息的mysql监控工具.这款工具帮助我们设定自己的条件与阀值，当触发条件时可以提供邮件报警，采集回来的信息会存储在文件里，诸如 ps/netstat/vmstat/iostat/processlist/innodbstat 全部一览无余. 就算在认为mysql性能没什么问题时，也可以跑起这款工具，以防不测&lt;/p&gt;

&lt;h3 id=&quot;pt-table-checksum&quot;&gt;pt-table-checksum&lt;/h3&gt;

&lt;p&gt;检查主从数据是否一致&lt;/p&gt;

&lt;h3 id=&quot;pt-table-sync&quot;&gt;pt-table-sync&lt;/h3&gt;

&lt;p&gt;同步两张表之间的数据差异&lt;/p&gt;

&lt;h3 id=&quot;pt-table-usage&quot;&gt;pt-table-usage&lt;/h3&gt;

&lt;p&gt;分析日志中查询并分析表使用情况&lt;/p&gt;

&lt;h3 id=&quot;pt-upgrade&quot;&gt;pt-upgrade&lt;/h3&gt;

&lt;p&gt;验证不同服务器上的查询结果是否相同&lt;/p&gt;

&lt;h3 id=&quot;pt-variable-advisor&quot;&gt;pt-variable-advisor&lt;/h3&gt;

&lt;p&gt;分析mysql参数，并且给出参数设置建议的一款PT工具&lt;/p&gt;

&lt;h3 id=&quot;pt-visual-explain&quot;&gt;pt-visual-explain&lt;/h3&gt;

&lt;p&gt;格式化explain输出结果为树结构&lt;/p&gt;
</description>
        <pubDate>Sat, 14 Jul 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/07/14/perconaToolkit/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/07/14/perconaToolkit/</guid>
        
        <category>MYSQL</category>
        
        
      </item>
    
  </channel>
</rss>
