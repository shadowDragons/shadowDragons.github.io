<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <!-- JQuery (used for bootstrap and jekyll search) -->
    <script src="/assets/js/jquery-3.2.1.min.js" ></script>
    
    <!-- Main JS (navbar.js and katex_init.js)-->
    <script defer=true src="/assets/js/main.min.js"></script>
    
    <!-- CSS -->
    <link rel="stylesheet" href="/assets/css/main.css">

    <link rel="stylesheet" href="/assets/css/mermaid.css">

    <!--Favicon-->
    <link rel="shortcut icon" href="/assets/favicon.ico" type="image/x-icon">

    <!-- Canonical -->
    <link rel="canonical" href="http://localhost:4000/2018/04/10/ethereum-crypto-currency-2.html">

    <!-- RSS -->
    <link rel="alternate" type="application/atom+xml" title="小白" href="http://localhost:4000///feed.xml"/>

    <!-- Font Awesome -->
    <!-- <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"> -->
    <link rel="stylesheet" type="text/css" href="/assets/css/font-awesome.min.css">

    <!-- Google Fonts -->
    
    <link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700,700italic,400italic" rel="stylesheet" type="text/css"> 
    

    <!-- KaTeX 0.8.3 -->
    
    <!--<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/KaTeX/0.8.3/katex.min.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/KaTeX/0.8.3/katex.min.js"></script> -->
    <link rel="stylesheet" type="text/css" href="/assets/css/katex.min.css">
    <script src="/assets/js/katex.min.js">
    </script>
    

    <!-- Google Analytics -->
    
    <script>
        (function(i, s, o, g, r, a, m) {
            i['GoogleAnalyticsObject'] = r;
            i[r] = i[r] || function() {
                (i[r].q = i[r].q || []).push(arguments)
            }, i[r].l = 1 * new Date();
            a = s.createElement(o),
                m = s.getElementsByTagName(o)[0];
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m)
        })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');

        ga('create', 'UA-89143952-2', 'auto');
        ga('send', 'pageview');

    </script>
    

    <!-- Baidu Analytics -->
    
    <script>
        var _hmt = _hmt || [];
        (function() {
          var hm = document.createElement("script");
          hm.src = 'https://hm.baidu.com/hm.js?2a8326534823f90fa4eef816aea2ef08';
          var s = document.getElementsByTagName("script")[0]; 
          s.parentNode.insertBefore(hm, s);
        })();
    </script>        
    
    
    <!-- seo tags -->
    <!-- Begin Jekyll SEO tag v2.4.0 -->
<title>以太坊发行代币(二) | 小白成长史</title>
<meta name="generator" content="Jekyll v3.7.3" />
<meta property="og:title" content="以太坊发行代币(二)" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="在上一节中，已经讲了如何去发行一个简单的代币，如果没看过的同学，请先去阅读以太坊发行代币(一)" />
<meta property="og:description" content="在上一节中，已经讲了如何去发行一个简单的代币，如果没看过的同学，请先去阅读以太坊发行代币(一)" />
<link rel="canonical" href="http://localhost:4000/2018/04/10/ethereum-crypto-currency-2.html" />
<meta property="og:url" content="http://localhost:4000/2018/04/10/ethereum-crypto-currency-2.html" />
<meta property="og:site_name" content="小白成长史" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-04-10T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"在上一节中，已经讲了如何去发行一个简单的代币，如果没看过的同学，请先去阅读以太坊发行代币(一)","@type":"BlogPosting","url":"http://localhost:4000/2018/04/10/ethereum-crypto-currency-2.html","headline":"以太坊发行代币(二)","dateModified":"2018-04-10T00:00:00+08:00","datePublished":"2018-04-10T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2018/04/10/ethereum-crypto-currency-2.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <!-- Manual seo tags -->
    <!--
    <title>以太坊发行代币(二) | 小白</title>
    <meta name="description" content="在上一节中，已经讲了如何去发行一个简单的代币，如果没看过的同学，请先去阅读以太坊发行代币(一)">
    -->
</head>

  <body>
    <header class="site-header">
    
    <!-- Logo and title -->
	<div class="branding">
		<a href="/">
			<img class="avatar" src="/assets/img/photo.jpeg" alt=""/>
		</a>

		<h1 class="site-title">
			<a href="/">小白</a>
		</h1>
	</div>
    
    <!-- Toggle menu -->
    <nav class="clear">
    <a id="pull" class="toggle" href="#">
    <i class="fa fa-bars fa-lg"></i>
    </a>
    
    <!-- Menu -->
    <ul>
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
         
        
        
        
        <li class="separator">
            |
        </li>
        <li>
            <a class="clear" href="/search">
                <i class="fa fa-search" aria-hidden="true"></i>
            </a>
        </li>
        
        
        <li class="separator">
            |
        </li>
        <li>
            <a class="clear" href="/tags">
                <i class="fa fa-tags" aria-hidden="true"></i>
            </a>
        </li>
        
        
    </ul>
        
	</nav>
</header>

    <div class="content">
      <article >
  <header id="main" style="background-image: url('/')">
    <h1 id="%E4%BB%A5%E5%A4%AA%E5%9D%8A%E5%8F%91%E8%A1%8C%E4%BB%A3%E5%B8%81%28%E4%BA%8C%29" class="title">以太坊发行代币(二)</h1>
    <p class="meta">
    April 10, 2018
    
    </p>
  </header>
  <section class="post-content"><p>在上一节中，已经讲了如何去发行一个简单的代币，如果没看过的同学，请先去阅读<a href="/2018/04/07/ethereum-crypto-currency-1.html">以太坊发行代币(一)</a></p>

<p>这一节，我们将对之前的代币做一次升级。</p>

<p>如果你想把你的代币卖给一个交易所，只是发送到一个其他合约的以太坊地址是不够的，因为它不会意识到这个新代币或者谁发送给它的，因为这个合约没有发布一些事件或者接口。所以对于合约，你应该首先批准它们可以从你账号转出代币，然后让它们知道它们应该怎么去做。</p>

<p>由于里面的一些函数是必须去做一些交易操作，这里很有必要把它们弄成集成为一个内部函数（只有这个合约本身能够调用）。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="cm">/* Internal transfer, can only be called by this contract */</span>
<span class="kd">function</span> <span class="nx">_transfer</span><span class="p">(</span><span class="nx">address</span> <span class="nx">_from</span><span class="p">,</span> <span class="nx">address</span> <span class="nx">_to</span><span class="p">,</span> <span class="nx">uint</span> <span class="nx">_value</span><span class="p">)</span> <span class="nx">internal</span> <span class="p">{</span>
    <span class="nx">require</span> <span class="p">(</span><span class="nx">_to</span> <span class="o">!=</span> <span class="mh">0x0</span><span class="p">);</span>                               <span class="c1">// Prevent transfer to 0x0 address. Use burn() instead</span>
    <span class="nx">require</span> <span class="p">(</span><span class="nx">balanceOf</span><span class="p">[</span><span class="nx">_from</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="nx">_value</span><span class="p">);</span>                <span class="c1">// Check if the sender has enough</span>
    <span class="nx">require</span> <span class="p">(</span><span class="nx">balanceOf</span><span class="p">[</span><span class="nx">_to</span><span class="p">]</span> <span class="o">+</span> <span class="nx">_value</span> <span class="o">&gt;=</span> <span class="nx">balanceOf</span><span class="p">[</span><span class="nx">_to</span><span class="p">]);</span> <span class="c1">// Check for overflows</span>
    <span class="nx">require</span><span class="p">(</span><span class="o">!</span><span class="nx">frozenAccount</span><span class="p">[</span><span class="nx">_from</span><span class="p">]);</span>                     <span class="c1">// Check if sender is frozen</span>
    <span class="nx">require</span><span class="p">(</span><span class="o">!</span><span class="nx">frozenAccount</span><span class="p">[</span><span class="nx">_to</span><span class="p">]);</span>                       <span class="c1">// Check if recipient is frozen</span>
    <span class="nx">balanceOf</span><span class="p">[</span><span class="nx">_from</span><span class="p">]</span> <span class="o">-=</span> <span class="nx">_value</span><span class="p">;</span>                         <span class="c1">// Subtract from the sender</span>
    <span class="nx">balanceOf</span><span class="p">[</span><span class="nx">_to</span><span class="p">]</span> <span class="o">+=</span> <span class="nx">_value</span><span class="p">;</span>                           <span class="c1">// Add the same to the recipient</span>
    <span class="nx">Transfer</span><span class="p">(</span><span class="nx">_from</span><span class="p">,</span> <span class="nx">_to</span><span class="p">,</span> <span class="nx">_value</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>现在你的其他涉及到交易操作的函数可以做它们自己的校验，然后用正确的参数去调用<strong>transfer</strong>这个函数。  <br />
注意这个函数没有做任何的权限校验就可以去转移代币，这是因为这个函数是内部函数，只有这个合约本身能够调用。  <br />
所以如果你添加了任何调用到它的函数，需要在调用前确保调用者有权限去转移代币。</p>

<h3 id="中心管理">中心管理</h3>

<p>所有的dapp默认是去中心化的，这不意味着他们不能拥有某些中心管理，比如你想有能力能够造更多的代币，又或者你想禁止某人使用你的代币。你可以把任何你想加的功能加到你的合约里面去，但你只能在最开始的时候加，这样那些代币拥有者可以知道你的游戏规则，然后决定要不要拥有你的代币。</p>

<p>这里我们将学习到一个合约特别有用的属性：<strong>继承</strong>  <br />
继承允许一个合约获得父合约的熟属性，而不需要重新定义它们。这样可以使我们的代码更加的简洁和重复使用。  <br />
添加下面这段代码到你的代码第一行，在<strong>contract MyToken {</strong>前添加</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">contract</span> <span class="nx">owned</span> <span class="p">{</span>
    <span class="nx">address</span> <span class="kr">public</span> <span class="nx">owner</span><span class="p">;</span>

    <span class="kd">function</span> <span class="nx">owned</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">owner</span> <span class="o">=</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nx">modifier</span> <span class="nx">onlyOwner</span> <span class="p">{</span>
        <span class="nx">require</span><span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">sender</span> <span class="o">==</span> <span class="nx">owner</span><span class="p">);</span>
        <span class="nx">_</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">transferOwnership</span><span class="p">(</span><span class="nx">address</span> <span class="nx">newOwner</span><span class="p">)</span> <span class="nx">onlyOwner</span> <span class="p">{</span>
        <span class="nx">owner</span> <span class="o">=</span> <span class="nx">newOwner</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这里创建了一个非常基本的合约，只是定义了关于这个合约的一些公共函数。下一步只要添加<em>is owner</em>到你的合约。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">contract</span> <span class="nx">MyToken</span> <span class="nx">is</span> <span class="nx">owned</span> <span class="p">{</span>
    <span class="cm">/* the rest of the contract as usual */</span>
</code></pre></div></div>

<p>这样所有<strong>MyToken</strong>的函数可以使用<em>owner</em>这个变量和<em>modifer onlyOnwer</em>。这个合约也可以获得一个可以修改合约拥有者的函数。即使合约一开始设置了合约拥有者，你也可以在构造函数添加这段代码：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">MyToken</span><span class="p">(</span>
    <span class="nx">uint256</span> <span class="nx">initialSupply</span><span class="p">,</span>
    <span class="nx">string</span> <span class="nx">tokenName</span><span class="p">,</span>
    <span class="nx">uint8</span> <span class="nx">decimalUnits</span><span class="p">,</span>
    <span class="nx">string</span> <span class="nx">tokenSymbol</span><span class="p">,</span>
    <span class="nx">address</span> <span class="nx">centralMinter</span>
    <span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">centralMinter</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span> <span class="nx">owner</span> <span class="o">=</span> <span class="nx">centralMinter</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="中心代币发行">中心代币发行</h3>

<p>支持你能够去控制流通代币的数量。  <br />
一种情况是当你的货币实际上代表了一种区块链资产（像金币券或者政府货币），然后你想要你的虚拟库存能够真实的反应其中一种。又或者你想要控制代币的价格，适当的增加或减少流通数量。</p>

<p>首先，我们需要增加一个变量来存储总发行量，然后在我们的构造函数去指定它。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">contract</span> <span class="nx">MyToken</span> <span class="p">{</span>
    <span class="nx">uint256</span> <span class="kr">public</span> <span class="nx">totalSupply</span><span class="p">;</span>

    <span class="kd">function</span> <span class="nx">MyToken</span><span class="p">(...)</span> <span class="p">{</span>
        <span class="nx">totalSupply</span> <span class="o">=</span> <span class="nx">initialSupply</span><span class="p">;</span>
        <span class="p">...</span>
    <span class="p">}</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>现在添加一个新函数来允许合约拥有者去创建新的代币。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">mintToken</span><span class="p">(</span><span class="nx">address</span> <span class="nx">target</span><span class="p">,</span> <span class="nx">uint256</span> <span class="nx">mintedAmount</span><span class="p">)</span> <span class="nx">onlyOwner</span> <span class="p">{</span>
    <span class="nx">balanceOf</span><span class="p">[</span><span class="nx">target</span><span class="p">]</span> <span class="o">+=</span> <span class="nx">mintedAmount</span><span class="p">;</span>
    <span class="nx">totalSupply</span> <span class="o">+=</span> <span class="nx">mintedAmount</span><span class="p">;</span>
    <span class="nx">Transfer</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">owner</span><span class="p">,</span> <span class="nx">mintedAmount</span><span class="p">);</span>
    <span class="nx">Transfer</span><span class="p">(</span><span class="nx">owner</span><span class="p">,</span> <span class="nx">target</span><span class="p">,</span> <span class="nx">mintedAmount</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>注意到函数名最后加了<strong>onlyOwner</strong>，意味着这个函数只能被设置为合约拥有者的账号调用，这样你就可以创造更多的代币。</p>

<h3 id="冻结资产">冻结资产</h3>

<p>根据你的使用场景，你可能需要会遇到一些管理障碍，比如谁可以拥有你的代币，谁不可以。这样的话你需要增加一个参数来允许合约拥有者去冻结或者解冻资产。</p>

<p>在这个合约的任何地方添加这个变量和函数。不过建议你把映射跟其他映射放到一起，事件跟其他事件放到一起。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">mapping</span> <span class="p">(</span><span class="nx">address</span> <span class="o">=&gt;</span> <span class="nx">bool</span><span class="p">)</span> <span class="kr">public</span> <span class="nx">frozenAccount</span><span class="p">;</span>
<span class="nx">event</span> <span class="nx">FrozenFunds</span><span class="p">(</span><span class="nx">address</span> <span class="nx">target</span><span class="p">,</span> <span class="nx">bool</span> <span class="nx">frozen</span><span class="p">);</span>

<span class="kd">function</span> <span class="nx">freezeAccount</span><span class="p">(</span><span class="nx">address</span> <span class="nx">target</span><span class="p">,</span> <span class="nx">bool</span> <span class="nx">freeze</span><span class="p">)</span> <span class="nx">onlyOwner</span> <span class="p">{</span>
    <span class="nx">frozenAccount</span><span class="p">[</span><span class="nx">target</span><span class="p">]</span> <span class="o">=</span> <span class="nx">freeze</span><span class="p">;</span>
    <span class="nx">FrozenFunds</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">freeze</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>对于这段代码所有账号默认都是解冻的，不过合约拥有者可以通过调用<strong>freezeAccount</strong>设置它们的一个冻结状态。  <br />
不幸的是，冻结没有任何的实际效果，因为我们还没有在转移代币的函数中做任何操作。现在修改它：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">transfer</span><span class="p">(</span><span class="nx">address</span> <span class="nx">_to</span><span class="p">,</span> <span class="nx">uint256</span> <span class="nx">_value</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">require</span><span class="p">(</span><span class="o">!</span><span class="nx">frozenAccount</span><span class="p">[</span><span class="nx">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">]);</span>
</code></pre></div></div>

<p>现在任何冻结的账号可以保留他们的代币，但是不是转移这些代币。任何账号默认都是解冻的直到你去冻结它，你也可以通过白名单的方式来管理。  <br />
只要把<strong>freezeAccount</strong>重命名为<strong>approvedAccount</strong>，然后修改最后一行代码为：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">require</span><span class="p">(</span><span class="nx">approvedAccount</span><span class="p">[</span><span class="nx">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">]);</span>
</code></pre></div></div>

<h3 id="自动买卖">自动买卖</h3>

<p>到目前为止，你已经可以信任你的代币并应用到实际场景中。但如果你想通过市场价格自动买卖来通过以太币（或其他代币）赎回。</p>

<p>首先，需要设置买卖的价格。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">uint256</span> <span class="kr">public</span> <span class="nx">sellPrice</span><span class="p">;</span>
<span class="nx">uint256</span> <span class="kr">public</span> <span class="nx">buyPrice</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">setPrices</span><span class="p">(</span><span class="nx">uint256</span> <span class="nx">newSellPrice</span><span class="p">,</span> <span class="nx">uint256</span> <span class="nx">newBuyPrice</span><span class="p">)</span> <span class="nx">onlyOwner</span> <span class="p">{</span>
    <span class="nx">sellPrice</span> <span class="o">=</span> <span class="nx">newSellPrice</span><span class="p">;</span>
    <span class="nx">buyPrice</span> <span class="o">=</span> <span class="nx">newBuyPrice</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这是一个不经常变动的可接受价格，因为每次价格变动都需要你执行一个交易并且话费一点以太币。如果你需要一个不变的带小数位的架构，建议你参考<a href="https://github.com/ethereum/wiki/wiki/Standardized_Contract_APIs#data-feeds">standard data feeds</a></p>

<p>下一步创建买卖函数：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">buy</span><span class="p">()</span> <span class="nx">payable</span> <span class="nx">returns</span> <span class="p">(</span><span class="nx">uint</span> <span class="nx">amount</span><span class="p">){</span>
    <span class="nx">amount</span> <span class="o">=</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">value</span> <span class="o">/</span> <span class="nx">buyPrice</span><span class="p">;</span>                    <span class="c1">// calculates the amount</span>
    <span class="nx">require</span><span class="p">(</span><span class="nx">balanceOf</span><span class="p">[</span><span class="k">this</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="nx">amount</span><span class="p">);</span>               <span class="c1">// checks if it has enough to sell</span>
    <span class="nx">balanceOf</span><span class="p">[</span><span class="nx">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">]</span> <span class="o">+=</span> <span class="nx">amount</span><span class="p">;</span>                  <span class="c1">// adds the amount to buyer's balance</span>
    <span class="nx">balanceOf</span><span class="p">[</span><span class="k">this</span><span class="p">]</span> <span class="o">-=</span> <span class="nx">amount</span><span class="p">;</span>                        <span class="c1">// subtracts amount from seller's balance</span>
    <span class="nx">Transfer</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">,</span> <span class="nx">amount</span><span class="p">);</span>               <span class="c1">// execute an event reflecting the change</span>
    <span class="k">return</span> <span class="nx">amount</span><span class="p">;</span>                                    <span class="c1">// ends function and returns</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">sell</span><span class="p">(</span><span class="nx">uint</span> <span class="nx">amount</span><span class="p">)</span> <span class="nx">returns</span> <span class="p">(</span><span class="nx">uint</span> <span class="nx">revenue</span><span class="p">){</span>
    <span class="nx">require</span><span class="p">(</span><span class="nx">balanceOf</span><span class="p">[</span><span class="nx">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="nx">amount</span><span class="p">);</span>         <span class="c1">// checks if the sender has enough to sell</span>
    <span class="nx">balanceOf</span><span class="p">[</span><span class="k">this</span><span class="p">]</span> <span class="o">+=</span> <span class="nx">amount</span><span class="p">;</span>                        <span class="c1">// adds the amount to owner's balance</span>
    <span class="nx">balanceOf</span><span class="p">[</span><span class="nx">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">]</span> <span class="o">-=</span> <span class="nx">amount</span><span class="p">;</span>                  <span class="c1">// subtracts the amount from seller's balance</span>
    <span class="nx">revenue</span> <span class="o">=</span> <span class="nx">amount</span> <span class="o">*</span> <span class="nx">sellPrice</span><span class="p">;</span>
    <span class="nx">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">.</span><span class="nx">transfer</span><span class="p">(</span><span class="nx">revenue</span><span class="p">);</span>                     <span class="c1">// sends ether to the seller: it's important to do this last to prevent recursion attacks</span>
    <span class="nx">Transfer</span><span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span> <span class="nx">amount</span><span class="p">);</span>               <span class="c1">// executes an event reflecting on the change</span>
    <span class="k">return</span> <span class="nx">revenue</span><span class="p">;</span>                                   <span class="c1">// ends function and returns</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这些操作并不会增加新代币而是改变合约拥有者的余额。</p>

<p>注意设置的价格不是以太币为单位，而是以wei为单位。一个以太币相当于1000000000000000000wei，所以当在以太坊设置你代币的价格时，需要在后面增加18个0。</p>

<p>当创建合约时，为了能够回购市场上所有代币，需要支付足够多的以太币。否则你的合约就破产了，你的用户没办法去卖掉他们的代币。</p>

<p>一个更有趣的合约可以允许一个交易所的任何人都能出价，或者可以从外部直接获取价格。</p>

<h3 id="自动充值">自动充值</h3>

<p>每次你在以太坊做交易，你都需要支付小费给矿工，让他去计算你合约的结果。这一切可以在将来会被改变，但目前只能支付以太币，因此你所有的代币用户都需要持有以太币。如果用户的以太币数量不足以支付小费会被冻结，知道合约拥有者来支付它。但在某些场景下，你可能不想你的用户来考虑以太坊，区块链或者如何拥有以太币，所以一个有效的方法是如果检测到用户余额不足，你能够自动帮用户充值余额。</p>

<p>首先，你需要创建一个变量来存储账户的阈值和一个函数来设置他。如果你不知道设置多少合适，可以设置<strong>5 finney（0.005个以太币）</strong></p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">uint</span> <span class="kr">public</span> <span class="nx">minBalanceForAccounts</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">setMinBalance</span><span class="p">(</span><span class="nx">uint</span> <span class="nx">minimumBalanceInFinney</span><span class="p">)</span> <span class="nx">onlyOwner</span> <span class="p">{</span>
        <span class="nx">minBalanceForAccounts</span> <span class="o">=</span> <span class="nx">minimumBalanceInFinney</span> <span class="o">*</span> <span class="mi">1</span> <span class="nx">finney</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>然后，添加下面代码到<strong>trensfer</strong>函数，让卖家退还一部分代币来充值以太币：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Send coins */</span>
<span class="kd">function</span> <span class="nx">transfer</span><span class="p">(</span><span class="nx">address</span> <span class="nx">_to</span><span class="p">,</span> <span class="nx">uint256</span> <span class="nx">_value</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">.</span><span class="nx">balance</span> <span class="o">&lt;</span> <span class="nx">minBalanceForAccounts</span><span class="p">)</span>
        <span class="nx">sell</span><span class="p">((</span><span class="nx">minBalanceForAccounts</span> <span class="o">-</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">.</span><span class="nx">balance</span><span class="p">)</span> <span class="o">/</span> <span class="nx">sellPrice</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>你也可以把支付小费的操作从卖家转移到买家：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Send coins */</span>
<span class="kd">function</span> <span class="nx">transfer</span><span class="p">(</span><span class="nx">address</span> <span class="nx">_to</span><span class="p">,</span> <span class="nx">uint256</span> <span class="nx">_value</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">_to</span><span class="p">.</span><span class="nx">balance</span><span class="o">&lt;</span><span class="nx">minBalanceForAccounts</span><span class="p">)</span>
        <span class="nx">_to</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="nx">sell</span><span class="p">((</span><span class="nx">minBalanceForAccounts</span> <span class="o">-</span> <span class="nx">_to</span><span class="p">.</span><span class="nx">balance</span><span class="p">)</span> <span class="o">/</span> <span class="nx">sellPrice</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这样可以保证所有人都有足够的以太币来支付小费。</p>

<h3 id="工作量证明">工作量证明</h3>

<p>这里有一些方法通过数学公式来增加你的代币供应。一个最简单的办法就是绑定以太坊的挖矿，意思就是一旦任何人找到以太坊的区块，它也相应获得你的代币回报。你可以通过一些<a href="https://solidity.readthedocs.io/en/latest/units-and-global-variables.html#block-and-transaction-properties">特殊接口</a>来获得找到区块的账号。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">giveBlockReward</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">balanceOf</span><span class="p">[</span><span class="nx">block</span><span class="p">.</span><span class="nx">coinbase</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>也可以增加一个数学公式，让任何人知道如果解答这个公式来获得回报。下面这个例子你必须解答出当前挑战，并正确设置下一个挑战。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">uint</span> <span class="kr">public</span> <span class="nx">currentChallenge</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// Can you figure out the cubic root of this number?</span>

<span class="kd">function</span> <span class="nx">rewardMathGeniuses</span><span class="p">(</span><span class="nx">uint</span> <span class="nx">answerToCurrentReward</span><span class="p">,</span> <span class="nx">uint</span> <span class="nx">nextChallenge</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">require</span><span class="p">(</span><span class="nx">answerToCurrentReward</span><span class="o">**</span><span class="mi">3</span> <span class="o">==</span> <span class="nx">currentChallenge</span><span class="p">);</span> <span class="c1">// If answer is wrong do not continue</span>
    <span class="nx">balanceOf</span><span class="p">[</span><span class="nx">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>         <span class="c1">// Reward the player</span>
    <span class="nx">currentChallenge</span> <span class="o">=</span> <span class="nx">nextChallenge</span><span class="p">;</span>   <span class="c1">// Set the next challenge</span>
<span class="p">}</span>
</code></pre></div></div>

<p>当然，计算上面这个结果通过手动是很困难的，但使用计算器就很简单，所以这游戏容易被计算机给破解。也因为最后一名赢家可以选择下一个挑战的难度，他们可以选择他们知道的，所以对其他玩家来说是很不公平的。一个更公平的系统需要设计一个对计算机来说很难的挑战，但也不是完全不可能挑战成功。一个非常好的方案是需要挑战者从很多数字中找到一个低于困难值的hash。</p>

<p>这个方案是Adam Back在1997年首次提出，称为<a href="https://en.wikipedia.org/wiki/Hashcash">Hashcash</a>,然后中本聪在2008年将它应用于比特币的工作量证明。</p>

<p>当然你也可以创建自己的工作量证明。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">bytes32</span> <span class="kr">public</span> <span class="nx">currentChallenge</span><span class="p">;</span>                         <span class="c1">// The coin starts with a challenge</span>
<span class="nx">uint</span> <span class="kr">public</span> <span class="nx">timeOfLastProof</span><span class="p">;</span>                             <span class="c1">// Variable to keep track of when rewards were given</span>
<span class="nx">uint</span> <span class="kr">public</span> <span class="nx">difficulty</span> <span class="o">=</span> <span class="mi">10</span><span class="o">**</span><span class="mi">32</span><span class="p">;</span>                         <span class="c1">// Difficulty starts reasonably low</span>

<span class="kd">function</span> <span class="nx">proofOfWork</span><span class="p">(</span><span class="nx">uint</span> <span class="nx">nonce</span><span class="p">){</span>
    <span class="nx">bytes8</span> <span class="nx">n</span> <span class="o">=</span> <span class="nx">bytes8</span><span class="p">(</span><span class="nx">sha3</span><span class="p">(</span><span class="nx">nonce</span><span class="p">,</span> <span class="nx">currentChallenge</span><span class="p">));</span>    <span class="c1">// Generate a random hash based on input</span>
    <span class="nx">require</span><span class="p">(</span><span class="nx">n</span> <span class="o">&gt;=</span> <span class="nx">bytes8</span><span class="p">(</span><span class="nx">difficulty</span><span class="p">));</span>                   <span class="c1">// Check if it's under the difficulty</span>

    <span class="nx">uint</span> <span class="nx">timeSinceLastProof</span> <span class="o">=</span> <span class="p">(</span><span class="nx">now</span> <span class="o">-</span> <span class="nx">timeOfLastProof</span><span class="p">);</span>  <span class="c1">// Calculate time since last reward was given</span>
    <span class="nx">require</span><span class="p">(</span><span class="nx">timeSinceLastProof</span> <span class="o">&gt;=</span>  <span class="mi">5</span> <span class="nx">seconds</span><span class="p">);</span>         <span class="c1">// Rewards cannot be given too quickly</span>
    <span class="nx">balanceOf</span><span class="p">[</span><span class="nx">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">]</span> <span class="o">+=</span> <span class="nx">timeSinceLastProof</span> <span class="o">/</span> <span class="mi">60</span> <span class="nx">seconds</span><span class="p">;</span>  <span class="c1">// The reward to the winner grows by the minute</span>

    <span class="nx">difficulty</span> <span class="o">=</span> <span class="nx">difficulty</span> <span class="o">*</span> <span class="mi">10</span> <span class="nx">minutes</span> <span class="o">/</span> <span class="nx">timeSinceLastProof</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// Adjusts the difficulty</span>

    <span class="nx">timeOfLastProof</span> <span class="o">=</span> <span class="nx">now</span><span class="p">;</span>                              <span class="c1">// Reset the counter</span>
    <span class="nx">currentChallenge</span> <span class="o">=</span> <span class="nx">sha3</span><span class="p">(</span><span class="nx">nonce</span><span class="p">,</span> <span class="nx">currentChallenge</span><span class="p">,</span> <span class="nx">block</span><span class="p">.</span><span class="nx">blockhash</span><span class="p">(</span><span class="nx">block</span><span class="p">.</span><span class="nx">number</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>  <span class="c1">// Save a hash that will be used as the next proof</span>
<span class="p">}</span>
</code></pre></div></div>

<p>构造函数同样也要修改，增加下面这行代码：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">timeOfLastProof</span> <span class="o">=</span> <span class="nx">now</span><span class="p">;</span>
</code></pre></div></div>

<p>一旦你运行合约，选择这个工作量证明函数，添加你的幸运数字，然后运行。如果这个确认窗口显示一个红色警告“Data can’t be execute”，需要返回上一步设置另一个数字直到你找到一个满足交易能够执行下去的数字。一旦你找到了这个数字，你将每分钟获得一个代币奖励，分钟数取决于距离上次挑战的时间。然后这个难度将被调整，保证平均每隔10分钟才能被计算出来。</p>

<h3 id="完整代码">完整代码</h3>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">16</span><span class="p">;</span>

<span class="nx">contract</span> <span class="nx">owned</span> <span class="p">{</span>
    <span class="nx">address</span> <span class="kr">public</span> <span class="nx">owner</span><span class="p">;</span>

    <span class="kd">function</span> <span class="nx">owned</span><span class="p">()</span> <span class="kr">public</span> <span class="p">{</span>
        <span class="nx">owner</span> <span class="o">=</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nx">modifier</span> <span class="nx">onlyOwner</span> <span class="p">{</span>
        <span class="nx">require</span><span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">sender</span> <span class="o">==</span> <span class="nx">owner</span><span class="p">);</span>
        <span class="nx">_</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">transferOwnership</span><span class="p">(</span><span class="nx">address</span> <span class="nx">newOwner</span><span class="p">)</span> <span class="nx">onlyOwner</span> <span class="kr">public</span> <span class="p">{</span>
        <span class="nx">owner</span> <span class="o">=</span> <span class="nx">newOwner</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kr">interface</span> <span class="nx">tokenRecipient</span> <span class="p">{</span> <span class="kd">function</span> <span class="nx">receiveApproval</span><span class="p">(</span><span class="nx">address</span> <span class="nx">_from</span><span class="p">,</span> <span class="nx">uint256</span> <span class="nx">_value</span><span class="p">,</span> <span class="nx">address</span> <span class="nx">_token</span><span class="p">,</span> <span class="nx">bytes</span> <span class="nx">_extraData</span><span class="p">)</span> <span class="kr">public</span><span class="p">;</span> <span class="p">}</span>

<span class="nx">contract</span> <span class="nx">TokenERC20</span> <span class="p">{</span>
    <span class="c1">// Public variables of the token</span>
    <span class="nx">string</span> <span class="kr">public</span> <span class="nx">name</span><span class="p">;</span>
    <span class="nx">string</span> <span class="kr">public</span> <span class="nx">symbol</span><span class="p">;</span>
    <span class="nx">uint8</span> <span class="kr">public</span> <span class="nx">decimals</span> <span class="o">=</span> <span class="mi">18</span><span class="p">;</span>
    <span class="c1">// 18 decimals is the strongly suggested default, avoid changing it</span>
    <span class="nx">uint256</span> <span class="kr">public</span> <span class="nx">totalSupply</span><span class="p">;</span>

    <span class="c1">// This creates an array with all balances</span>
    <span class="nx">mapping</span> <span class="p">(</span><span class="nx">address</span> <span class="o">=&gt;</span> <span class="nx">uint256</span><span class="p">)</span> <span class="kr">public</span> <span class="nx">balanceOf</span><span class="p">;</span>
    <span class="nx">mapping</span> <span class="p">(</span><span class="nx">address</span> <span class="o">=&gt;</span> <span class="nx">mapping</span> <span class="p">(</span><span class="nx">address</span> <span class="o">=&gt;</span> <span class="nx">uint256</span><span class="p">))</span> <span class="kr">public</span> <span class="nx">allowance</span><span class="p">;</span>

    <span class="c1">// This generates a public event on the blockchain that will notify clients</span>
    <span class="nx">event</span> <span class="nx">Transfer</span><span class="p">(</span><span class="nx">address</span> <span class="nx">indexed</span> <span class="k">from</span><span class="p">,</span> <span class="nx">address</span> <span class="nx">indexed</span> <span class="nx">to</span><span class="p">,</span> <span class="nx">uint256</span> <span class="nx">value</span><span class="p">);</span>

    <span class="c1">// This notifies clients about the amount burnt</span>
    <span class="nx">event</span> <span class="nx">Burn</span><span class="p">(</span><span class="nx">address</span> <span class="nx">indexed</span> <span class="k">from</span><span class="p">,</span> <span class="nx">uint256</span> <span class="nx">value</span><span class="p">);</span>

    <span class="cm">/**
     * Constrctor function
     *
     * Initializes contract with initial supply tokens to the creator of the contract
     */</span>
    <span class="kd">function</span> <span class="nx">TokenERC20</span><span class="p">(</span>
        <span class="nx">uint256</span> <span class="nx">initialSupply</span><span class="p">,</span>
        <span class="nx">string</span> <span class="nx">tokenName</span><span class="p">,</span>
        <span class="nx">string</span> <span class="nx">tokenSymbol</span>
    <span class="p">)</span> <span class="kr">public</span> <span class="p">{</span>
        <span class="nx">totalSupply</span> <span class="o">=</span> <span class="nx">initialSupply</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">**</span> <span class="nx">uint256</span><span class="p">(</span><span class="nx">decimals</span><span class="p">);</span>  <span class="c1">// Update total supply with the decimal amount</span>
        <span class="nx">balanceOf</span><span class="p">[</span><span class="nx">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">]</span> <span class="o">=</span> <span class="nx">totalSupply</span><span class="p">;</span>                <span class="c1">// Give the creator all initial tokens</span>
        <span class="nx">name</span> <span class="o">=</span> <span class="nx">tokenName</span><span class="p">;</span>                                   <span class="c1">// Set the name for display purposes</span>
        <span class="nx">symbol</span> <span class="o">=</span> <span class="nx">tokenSymbol</span><span class="p">;</span>                               <span class="c1">// Set the symbol for display purposes</span>
    <span class="p">}</span>

    <span class="cm">/**
     * Internal transfer, only can be called by this contract
     */</span>
    <span class="kd">function</span> <span class="nx">_transfer</span><span class="p">(</span><span class="nx">address</span> <span class="nx">_from</span><span class="p">,</span> <span class="nx">address</span> <span class="nx">_to</span><span class="p">,</span> <span class="nx">uint</span> <span class="nx">_value</span><span class="p">)</span> <span class="nx">internal</span> <span class="p">{</span>
        <span class="c1">// Prevent transfer to 0x0 address. Use burn() instead</span>
        <span class="nx">require</span><span class="p">(</span><span class="nx">_to</span> <span class="o">!=</span> <span class="mh">0x0</span><span class="p">);</span>
        <span class="c1">// Check if the sender has enough</span>
        <span class="nx">require</span><span class="p">(</span><span class="nx">balanceOf</span><span class="p">[</span><span class="nx">_from</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="nx">_value</span><span class="p">);</span>
        <span class="c1">// Check for overflows</span>
        <span class="nx">require</span><span class="p">(</span><span class="nx">balanceOf</span><span class="p">[</span><span class="nx">_to</span><span class="p">]</span> <span class="o">+</span> <span class="nx">_value</span> <span class="o">&gt;</span> <span class="nx">balanceOf</span><span class="p">[</span><span class="nx">_to</span><span class="p">]);</span>
        <span class="c1">// Save this for an assertion in the future</span>
        <span class="nx">uint</span> <span class="nx">previousBalances</span> <span class="o">=</span> <span class="nx">balanceOf</span><span class="p">[</span><span class="nx">_from</span><span class="p">]</span> <span class="o">+</span> <span class="nx">balanceOf</span><span class="p">[</span><span class="nx">_to</span><span class="p">];</span>
        <span class="c1">// Subtract from the sender</span>
        <span class="nx">balanceOf</span><span class="p">[</span><span class="nx">_from</span><span class="p">]</span> <span class="o">-=</span> <span class="nx">_value</span><span class="p">;</span>
        <span class="c1">// Add the same to the recipient</span>
        <span class="nx">balanceOf</span><span class="p">[</span><span class="nx">_to</span><span class="p">]</span> <span class="o">+=</span> <span class="nx">_value</span><span class="p">;</span>
        <span class="nx">Transfer</span><span class="p">(</span><span class="nx">_from</span><span class="p">,</span> <span class="nx">_to</span><span class="p">,</span> <span class="nx">_value</span><span class="p">);</span>
        <span class="c1">// Asserts are used to use static analysis to find bugs in your code. They should never fail</span>
        <span class="nx">assert</span><span class="p">(</span><span class="nx">balanceOf</span><span class="p">[</span><span class="nx">_from</span><span class="p">]</span> <span class="o">+</span> <span class="nx">balanceOf</span><span class="p">[</span><span class="nx">_to</span><span class="p">]</span> <span class="o">==</span> <span class="nx">previousBalances</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/**
     * Transfer tokens
     *
     * Send `_value` tokens to `_to` from your account
     *
     * @param _to The address of the recipient
     * @param _value the amount to send
     */</span>
    <span class="kd">function</span> <span class="nx">transfer</span><span class="p">(</span><span class="nx">address</span> <span class="nx">_to</span><span class="p">,</span> <span class="nx">uint256</span> <span class="nx">_value</span><span class="p">)</span> <span class="kr">public</span> <span class="p">{</span>
        <span class="nx">_transfer</span><span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">,</span> <span class="nx">_to</span><span class="p">,</span> <span class="nx">_value</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/**
     * Transfer tokens from other address
     *
     * Send `_value` tokens to `_to` in behalf of `_from`
     *
     * @param _from The address of the sender
     * @param _to The address of the recipient
     * @param _value the amount to send
     */</span>
    <span class="kd">function</span> <span class="nx">transferFrom</span><span class="p">(</span><span class="nx">address</span> <span class="nx">_from</span><span class="p">,</span> <span class="nx">address</span> <span class="nx">_to</span><span class="p">,</span> <span class="nx">uint256</span> <span class="nx">_value</span><span class="p">)</span> <span class="kr">public</span> <span class="nx">returns</span> <span class="p">(</span><span class="nx">bool</span> <span class="nx">success</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">require</span><span class="p">(</span><span class="nx">_value</span> <span class="o">&lt;=</span> <span class="nx">allowance</span><span class="p">[</span><span class="nx">_from</span><span class="p">][</span><span class="nx">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">]);</span>     <span class="c1">// Check allowance</span>
        <span class="nx">allowance</span><span class="p">[</span><span class="nx">_from</span><span class="p">][</span><span class="nx">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">]</span> <span class="o">-=</span> <span class="nx">_value</span><span class="p">;</span>
        <span class="nx">_transfer</span><span class="p">(</span><span class="nx">_from</span><span class="p">,</span> <span class="nx">_to</span><span class="p">,</span> <span class="nx">_value</span><span class="p">);</span>
        <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/**
     * Set allowance for other address
     *
     * Allows `_spender` to spend no more than `_value` tokens in your behalf
     *
     * @param _spender The address authorized to spend
     * @param _value the max amount they can spend
     */</span>
    <span class="kd">function</span> <span class="nx">approve</span><span class="p">(</span><span class="nx">address</span> <span class="nx">_spender</span><span class="p">,</span> <span class="nx">uint256</span> <span class="nx">_value</span><span class="p">)</span> <span class="kr">public</span>
        <span class="nx">returns</span> <span class="p">(</span><span class="nx">bool</span> <span class="nx">success</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">allowance</span><span class="p">[</span><span class="nx">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">][</span><span class="nx">_spender</span><span class="p">]</span> <span class="o">=</span> <span class="nx">_value</span><span class="p">;</span>
        <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/**
     * Set allowance for other address and notify
     *
     * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it
     *
     * @param _spender The address authorized to spend
     * @param _value the max amount they can spend
     * @param _extraData some extra information to send to the approved contract
     */</span>
    <span class="kd">function</span> <span class="nx">approveAndCall</span><span class="p">(</span><span class="nx">address</span> <span class="nx">_spender</span><span class="p">,</span> <span class="nx">uint256</span> <span class="nx">_value</span><span class="p">,</span> <span class="nx">bytes</span> <span class="nx">_extraData</span><span class="p">)</span>
        <span class="kr">public</span>
        <span class="nx">returns</span> <span class="p">(</span><span class="nx">bool</span> <span class="nx">success</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">tokenRecipient</span> <span class="nx">spender</span> <span class="o">=</span> <span class="nx">tokenRecipient</span><span class="p">(</span><span class="nx">_spender</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">approve</span><span class="p">(</span><span class="nx">_spender</span><span class="p">,</span> <span class="nx">_value</span><span class="p">))</span> <span class="p">{</span>
            <span class="nx">spender</span><span class="p">.</span><span class="nx">receiveApproval</span><span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">,</span> <span class="nx">_value</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span> <span class="nx">_extraData</span><span class="p">);</span>
            <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cm">/**
     * Destroy tokens
     *
     * Remove `_value` tokens from the system irreversibly
     *
     * @param _value the amount of money to burn
     */</span>
    <span class="kd">function</span> <span class="nx">burn</span><span class="p">(</span><span class="nx">uint256</span> <span class="nx">_value</span><span class="p">)</span> <span class="kr">public</span> <span class="nx">returns</span> <span class="p">(</span><span class="nx">bool</span> <span class="nx">success</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">require</span><span class="p">(</span><span class="nx">balanceOf</span><span class="p">[</span><span class="nx">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="nx">_value</span><span class="p">);</span>   <span class="c1">// Check if the sender has enough</span>
        <span class="nx">balanceOf</span><span class="p">[</span><span class="nx">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">]</span> <span class="o">-=</span> <span class="nx">_value</span><span class="p">;</span>            <span class="c1">// Subtract from the sender</span>
        <span class="nx">totalSupply</span> <span class="o">-=</span> <span class="nx">_value</span><span class="p">;</span>                      <span class="c1">// Updates totalSupply</span>
        <span class="nx">Burn</span><span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">,</span> <span class="nx">_value</span><span class="p">);</span>
        <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/**
     * Destroy tokens from other account
     *
     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.
     *
     * @param _from the address of the sender
     * @param _value the amount of money to burn
     */</span>
    <span class="kd">function</span> <span class="nx">burnFrom</span><span class="p">(</span><span class="nx">address</span> <span class="nx">_from</span><span class="p">,</span> <span class="nx">uint256</span> <span class="nx">_value</span><span class="p">)</span> <span class="kr">public</span> <span class="nx">returns</span> <span class="p">(</span><span class="nx">bool</span> <span class="nx">success</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">require</span><span class="p">(</span><span class="nx">balanceOf</span><span class="p">[</span><span class="nx">_from</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="nx">_value</span><span class="p">);</span>                <span class="c1">// Check if the targeted balance is enough</span>
        <span class="nx">require</span><span class="p">(</span><span class="nx">_value</span> <span class="o">&lt;=</span> <span class="nx">allowance</span><span class="p">[</span><span class="nx">_from</span><span class="p">][</span><span class="nx">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">]);</span>    <span class="c1">// Check allowance</span>
        <span class="nx">balanceOf</span><span class="p">[</span><span class="nx">_from</span><span class="p">]</span> <span class="o">-=</span> <span class="nx">_value</span><span class="p">;</span>                         <span class="c1">// Subtract from the targeted balance</span>
        <span class="nx">allowance</span><span class="p">[</span><span class="nx">_from</span><span class="p">][</span><span class="nx">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">]</span> <span class="o">-=</span> <span class="nx">_value</span><span class="p">;</span>             <span class="c1">// Subtract from the sender's allowance</span>
        <span class="nx">totalSupply</span> <span class="o">-=</span> <span class="nx">_value</span><span class="p">;</span>                              <span class="c1">// Update totalSupply</span>
        <span class="nx">Burn</span><span class="p">(</span><span class="nx">_from</span><span class="p">,</span> <span class="nx">_value</span><span class="p">);</span>
        <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/******************************************/</span>
<span class="cm">/*       ADVANCED TOKEN STARTS HERE       */</span>
<span class="cm">/******************************************/</span>

<span class="nx">contract</span> <span class="nx">MyAdvancedToken</span> <span class="nx">is</span> <span class="nx">owned</span><span class="p">,</span> <span class="nx">TokenERC20</span> <span class="p">{</span>

    <span class="nx">uint256</span> <span class="kr">public</span> <span class="nx">sellPrice</span><span class="p">;</span>
    <span class="nx">uint256</span> <span class="kr">public</span> <span class="nx">buyPrice</span><span class="p">;</span>

    <span class="nx">mapping</span> <span class="p">(</span><span class="nx">address</span> <span class="o">=&gt;</span> <span class="nx">bool</span><span class="p">)</span> <span class="kr">public</span> <span class="nx">frozenAccount</span><span class="p">;</span>

    <span class="cm">/* This generates a public event on the blockchain that will notify clients */</span>
    <span class="nx">event</span> <span class="nx">FrozenFunds</span><span class="p">(</span><span class="nx">address</span> <span class="nx">target</span><span class="p">,</span> <span class="nx">bool</span> <span class="nx">frozen</span><span class="p">);</span>

    <span class="cm">/* Initializes contract with initial supply tokens to the creator of the contract */</span>
    <span class="kd">function</span> <span class="nx">MyAdvancedToken</span><span class="p">(</span>
        <span class="nx">uint256</span> <span class="nx">initialSupply</span><span class="p">,</span>
        <span class="nx">string</span> <span class="nx">tokenName</span><span class="p">,</span>
        <span class="nx">string</span> <span class="nx">tokenSymbol</span>
    <span class="p">)</span> <span class="nx">TokenERC20</span><span class="p">(</span><span class="nx">initialSupply</span><span class="p">,</span> <span class="nx">tokenName</span><span class="p">,</span> <span class="nx">tokenSymbol</span><span class="p">)</span> <span class="kr">public</span> <span class="p">{}</span>

    <span class="cm">/* Internal transfer, only can be called by this contract */</span>
    <span class="kd">function</span> <span class="nx">_transfer</span><span class="p">(</span><span class="nx">address</span> <span class="nx">_from</span><span class="p">,</span> <span class="nx">address</span> <span class="nx">_to</span><span class="p">,</span> <span class="nx">uint</span> <span class="nx">_value</span><span class="p">)</span> <span class="nx">internal</span> <span class="p">{</span>
        <span class="nx">require</span> <span class="p">(</span><span class="nx">_to</span> <span class="o">!=</span> <span class="mh">0x0</span><span class="p">);</span>                               <span class="c1">// Prevent transfer to 0x0 address. Use burn() instead</span>
        <span class="nx">require</span> <span class="p">(</span><span class="nx">balanceOf</span><span class="p">[</span><span class="nx">_from</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="nx">_value</span><span class="p">);</span>               <span class="c1">// Check if the sender has enough</span>
        <span class="nx">require</span> <span class="p">(</span><span class="nx">balanceOf</span><span class="p">[</span><span class="nx">_to</span><span class="p">]</span> <span class="o">+</span> <span class="nx">_value</span> <span class="o">&gt;=</span> <span class="nx">balanceOf</span><span class="p">[</span><span class="nx">_to</span><span class="p">]);</span> <span class="c1">// Check for overflows</span>
        <span class="nx">require</span><span class="p">(</span><span class="o">!</span><span class="nx">frozenAccount</span><span class="p">[</span><span class="nx">_from</span><span class="p">]);</span>                     <span class="c1">// Check if sender is frozen</span>
        <span class="nx">require</span><span class="p">(</span><span class="o">!</span><span class="nx">frozenAccount</span><span class="p">[</span><span class="nx">_to</span><span class="p">]);</span>                       <span class="c1">// Check if recipient is frozen</span>
        <span class="nx">balanceOf</span><span class="p">[</span><span class="nx">_from</span><span class="p">]</span> <span class="o">-=</span> <span class="nx">_value</span><span class="p">;</span>                         <span class="c1">// Subtract from the sender</span>
        <span class="nx">balanceOf</span><span class="p">[</span><span class="nx">_to</span><span class="p">]</span> <span class="o">+=</span> <span class="nx">_value</span><span class="p">;</span>                           <span class="c1">// Add the same to the recipient</span>
        <span class="nx">Transfer</span><span class="p">(</span><span class="nx">_from</span><span class="p">,</span> <span class="nx">_to</span><span class="p">,</span> <span class="nx">_value</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">/// @notice Create `mintedAmount` tokens and send it to `target`</span>
    <span class="c1">/// @param target Address to receive the tokens</span>
    <span class="c1">/// @param mintedAmount the amount of tokens it will receive</span>
    <span class="kd">function</span> <span class="nx">mintToken</span><span class="p">(</span><span class="nx">address</span> <span class="nx">target</span><span class="p">,</span> <span class="nx">uint256</span> <span class="nx">mintedAmount</span><span class="p">)</span> <span class="nx">onlyOwner</span> <span class="kr">public</span> <span class="p">{</span>
        <span class="nx">balanceOf</span><span class="p">[</span><span class="nx">target</span><span class="p">]</span> <span class="o">+=</span> <span class="nx">mintedAmount</span><span class="p">;</span>
        <span class="nx">totalSupply</span> <span class="o">+=</span> <span class="nx">mintedAmount</span><span class="p">;</span>
        <span class="nx">Transfer</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span> <span class="nx">mintedAmount</span><span class="p">);</span>
        <span class="nx">Transfer</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">target</span><span class="p">,</span> <span class="nx">mintedAmount</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">/// @notice `freeze? Prevent | Allow` `target` from sending &amp; receiving tokens</span>
    <span class="c1">/// @param target Address to be frozen</span>
    <span class="c1">/// @param freeze either to freeze it or not</span>
    <span class="kd">function</span> <span class="nx">freezeAccount</span><span class="p">(</span><span class="nx">address</span> <span class="nx">target</span><span class="p">,</span> <span class="nx">bool</span> <span class="nx">freeze</span><span class="p">)</span> <span class="nx">onlyOwner</span> <span class="kr">public</span> <span class="p">{</span>
        <span class="nx">frozenAccount</span><span class="p">[</span><span class="nx">target</span><span class="p">]</span> <span class="o">=</span> <span class="nx">freeze</span><span class="p">;</span>
        <span class="nx">FrozenFunds</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">freeze</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">/// @notice Allow users to buy tokens for `newBuyPrice` eth and sell tokens for `newSellPrice` eth</span>
    <span class="c1">/// @param newSellPrice Price the users can sell to the contract</span>
    <span class="c1">/// @param newBuyPrice Price users can buy from the contract</span>
    <span class="kd">function</span> <span class="nx">setPrices</span><span class="p">(</span><span class="nx">uint256</span> <span class="nx">newSellPrice</span><span class="p">,</span> <span class="nx">uint256</span> <span class="nx">newBuyPrice</span><span class="p">)</span> <span class="nx">onlyOwner</span> <span class="kr">public</span> <span class="p">{</span>
        <span class="nx">sellPrice</span> <span class="o">=</span> <span class="nx">newSellPrice</span><span class="p">;</span>
        <span class="nx">buyPrice</span> <span class="o">=</span> <span class="nx">newBuyPrice</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">/// @notice Buy tokens from contract by sending ether</span>
    <span class="kd">function</span> <span class="nx">buy</span><span class="p">()</span> <span class="nx">payable</span> <span class="kr">public</span> <span class="p">{</span>
        <span class="nx">uint</span> <span class="nx">amount</span> <span class="o">=</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">value</span> <span class="o">/</span> <span class="nx">buyPrice</span><span class="p">;</span>               <span class="c1">// calculates the amount</span>
        <span class="nx">_transfer</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">,</span> <span class="nx">amount</span><span class="p">);</span>              <span class="c1">// makes the transfers</span>
    <span class="p">}</span>

    <span class="c1">/// @notice Sell `amount` tokens to contract</span>
    <span class="c1">/// @param amount amount of tokens to be sold</span>
    <span class="kd">function</span> <span class="nx">sell</span><span class="p">(</span><span class="nx">uint256</span> <span class="nx">amount</span><span class="p">)</span> <span class="kr">public</span> <span class="p">{</span>
        <span class="nx">require</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">balance</span> <span class="o">&gt;=</span> <span class="nx">amount</span> <span class="o">*</span> <span class="nx">sellPrice</span><span class="p">);</span>      <span class="c1">// checks if the contract has enough ether to buy</span>
        <span class="nx">_transfer</span><span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span> <span class="nx">amount</span><span class="p">);</span>              <span class="c1">// makes the transfers</span>
        <span class="nx">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">.</span><span class="nx">transfer</span><span class="p">(</span><span class="nx">amount</span> <span class="o">*</span> <span class="nx">sellPrice</span><span class="p">);</span>          <span class="c1">// sends ether to the seller. It's important to do this last to avoid recursion attacks</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
</section>
   
   <!-- Tag list -->
  
  


<footer>
  <div class="tag-list">
    
      <div class="meta">Tags</div>
    

    
    <a class="button" href="/tags#以太坊">
      <p><i class="fa fa-tag fa-fw"></i> 以太坊</p>
    </a>
    
    <a class="button" href="/tags#区块链">
      <p><i class="fa fa-tag fa-fw"></i> 区块链</p>
    </a>
    
  </div>
</footer>

    
</article>

<!-- Disqus -->


<!-- Post navigation -->

  <div id="post-nav">
  
  <div id="previous-post" class="post-nav-post">
      <p>Previous post</p>
      <a href="/2018/04/07/ethereum-crypto-currency-1.html">
        以太坊发行代币(一)
      </a>
  </div>
  
  
</div>

    </div>
    
<footer class="site-footer">
    <p class="text">Powered by <a href="https://jekyllrb.com/">Jekyll</a> with <a href="https://github.com/sylhare/Type-on-Strap">Type on Strap</a>
</p>
            <div class="footer-icons">
                <ul>
                <!-- Social icons from Font Awesome, if enabled -->
                
<li>
	<a href="http://localhost:4000/feed.xml" title="Follow RSS feed">
		<span class="fa-stack fa-lg">
            <i class="fa fa-circle fa-stack-2x"></i>
            <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
        </span>
	</a>
</li>















<li>
	<a href="https://github.com/shadowdragons" title="Follow on GitHub">
		<span class="fa-stack fa-lg">
            <i class="fa fa-circle fa-stack-2x"></i>
            <i class="fa fa-github fa-stack-1x fa-inverse"></i>
        </span>
	</a>
</li>
































                </ul>
            </div>
</footer>




  </body>
</html>
