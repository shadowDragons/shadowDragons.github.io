<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <!-- JQuery (used for bootstrap and jekyll search) -->
    <script src="/assets/js/jquery-3.2.1.min.js" ></script>
    
    <!-- Main JS (navbar.js and katex_init.js)-->
    <script defer=true src="/assets/js/main.min.js"></script>
    
    <!-- CSS -->
    <link rel="stylesheet" href="/assets/css/main.css">

    <link rel="stylesheet" href="/assets/css/mermaid.css">

    <!--Favicon-->
    <link rel="shortcut icon" href="/assets/favicon.ico" type="image/x-icon">

    <!-- Canonical -->
    <link rel="canonical" href="http://localhost:4000/search/">

    <!-- RSS -->
    <link rel="alternate" type="application/atom+xml" title="小白" href="http://localhost:4000///feed.xml"/>

    <!-- Font Awesome -->
    <!-- <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"> -->
    <link rel="stylesheet" type="text/css" href="/assets/css/font-awesome.min.css">

    <!-- Google Fonts -->
    
    <link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700,700italic,400italic" rel="stylesheet" type="text/css"> 
    

    <!-- KaTeX 0.8.3 -->
    
    <!--<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/KaTeX/0.8.3/katex.min.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/KaTeX/0.8.3/katex.min.js"></script> -->
    <link rel="stylesheet" type="text/css" href="/assets/css/katex.min.css">
    <script src="/assets/js/katex.min.js">
    </script>
    

    <!-- Google Analytics -->
    
    <script>
        (function(i, s, o, g, r, a, m) {
            i['GoogleAnalyticsObject'] = r;
            i[r] = i[r] || function() {
                (i[r].q = i[r].q || []).push(arguments)
            }, i[r].l = 1 * new Date();
            a = s.createElement(o),
                m = s.getElementsByTagName(o)[0];
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m)
        })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');

        ga('create', 'UA-89143952-2', 'auto');
        ga('send', 'pageview');

    </script>
    

    <!-- Baidu Analytics -->
    
    <script>
        var _hmt = _hmt || [];
        (function() {
          var hm = document.createElement("script");
          hm.src = 'https://hm.baidu.com/hm.js?2a8326534823f90fa4eef816aea2ef08';
          var s = document.getElementsByTagName("script")[0]; 
          s.parentNode.insertBefore(hm, s);
        })();
    </script>        
    
    
    <!-- seo tags -->
    <!-- Begin Jekyll SEO tag v2.4.0 -->
<title>Search | 小白成长史</title>
<meta name="generator" content="Jekyll v3.7.3" />
<meta property="og:title" content="Search" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="php mysql 分布式 区块链" />
<meta property="og:description" content="php mysql 分布式 区块链" />
<link rel="canonical" href="http://localhost:4000/search/" />
<meta property="og:url" content="http://localhost:4000/search/" />
<meta property="og:site_name" content="小白成长史" />
<script type="application/ld+json">
{"description":"php mysql 分布式 区块链","@type":"WebPage","url":"http://localhost:4000/search/","headline":"Search","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <!-- Manual seo tags -->
    <!--
    <title>Search | 小白</title>
    <meta name="description" content="">
    -->
</head>

  <body>
    <header class="site-header">
    
    <!-- Logo and title -->
	<div class="branding">
		<a href="/">
			<img class="avatar" src="/assets/img/photo.jpeg" alt=""/>
		</a>

		<h1 class="site-title">
			<a href="/">小白</a>
		</h1>
	</div>
    
    <!-- Toggle menu -->
    <nav class="clear">
    <a id="pull" class="toggle" href="#">
    <i class="fa fa-bars fa-lg"></i>
    </a>
    
    <!-- Menu -->
    <ul>
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
         
        
        
        
        <li class="separator">
            |
        </li>
        <li>
            <a class="clear" href="http://localhost:4000/search">
                <i class="fa fa-search" aria-hidden="true"></i>
            </a>
        </li>
        
        
        <li class="separator">
            |
        </li>
        <li>
            <a class="clear" href="http://localhost:4000/tags">
                <i class="fa fa-tags" aria-hidden="true"></i>
            </a>
        </li>
        
        
    </ul>
        
	</nav>
</header>

    <div class="content">
      <article class="feature-image">
  <header id="main" style="background-image: url('/assets/img/pexels/search-map.jpeg')">
    <h1 id="Search" class="title">
        Search
    </h1>
    
    
    <h2 class="subtitle">What are you looking for?</h2>
    
      
  </header>
  <section class="post-content"><!-- Html Elements for Search -->
<input type="text" id="search-input" placeholder="Enter keywords..." class="search-bar">
<br>
<br>
<ul id="results-container"></ul>

<section>
    <!-- Script pointing to jekyll-search.js -->
    <script src="/assets/js/simple-jekyll-search.min.js" type="text/javascript"></script>

    <script type="text/javascript">
        SimpleJekyllSearch({
            searchInput: document.getElementById('search-input'),
            resultsContainer: document.getElementById('results-container'),
            json: [
                    
                     
                        {
                          "title"    : "以太坊发行代币(二)",
                          "category" : "",
                          "tags"     : " 区块链, 以太坊",
                          "url"      : "/2018/04/10/ethereum-crypto-currency-2.html",
                          "date"     : "April 10, 2018",
                          "excerpt"  : "在上一节中，已经讲了如何去发行一个简单的代币，如果没看过的同学，请先去阅读以太坊发行代币(一)这一节，我们将对之前的代币做一次升级。如果你想把你的代币卖给一个交易所，只是发送到一个其他合约的以太坊地址是不够的，因为它不会意识到这个新代币或者谁发送给它的，因为这个合约没有发布一些事件或者接口。所以对于合约，你应该首先批准它们可以从你账号转出代币，然后让它们知道它们应该怎么去做。由于里面的一些函数是必须去做一些交易操作，这里很有必要把它们弄成集成为一个内部函数（只有这个合约本身能够调用）。 /...",
                          "content"  : "在上一节中，已经讲了如何去发行一个简单的代币，如果没看过的同学，请先去阅读以太坊发行代币(一)这一节，我们将对之前的代币做一次升级。如果你想把你的代币卖给一个交易所，只是发送到一个其他合约的以太坊地址是不够的，因为它不会意识到这个新代币或者谁发送给它的，因为这个合约没有发布一些事件或者接口。所以对于合约，你应该首先批准它们可以从你账号转出代币，然后让它们知道它们应该怎么去做。由于里面的一些函数是必须去做一些交易操作，这里很有必要把它们弄成集成为一个内部函数（只有这个合约本身能够调用）。 /* Internal transfer, can only be called by this contract */function _transfer(address _from, address _to, uint _value) internal {    require (_to != 0x0);                               // Prevent transfer to 0x0 address. Use burn() instead    require (balanceOf[_from] &gt;= _value);                // Check if the sender has enough    require (balanceOf[_to] + _value &gt;= balanceOf[_to]); // Check for overflows    require(!frozenAccount[_from]);                     // Check if sender is frozen    require(!frozenAccount[_to]);                       // Check if recipient is frozen    balanceOf[_from] -= _value;                         // Subtract from the sender    balanceOf[_to] += _value;                           // Add the same to the recipient    Transfer(_from, _to, _value);}现在你的其他涉及到交易操作的函数可以做它们自己的校验，然后用正确的参数去调用transfer这个函数。  注意这个函数没有做任何的权限校验就可以去转移代币，这是因为这个函数是内部函数，只有这个合约本身能够调用。  所以如果你添加了任何调用到它的函数，需要在调用前确保调用者有权限去转移代币。中心管理所有的dapp默认是去中心化的，这不意味着他们不能拥有某些中心管理，比如你想有能力能够造更多的代币，又或者你想禁止某人使用你的代币。你可以把任何你想加的功能加到你的合约里面去，但你只能在最开始的时候加，这样那些代币拥有者可以知道你的游戏规则，然后决定要不要拥有你的代币。这里我们将学习到一个合约特别有用的属性：继承  继承允许一个合约获得父合约的熟属性，而不需要重新定义它们。这样可以使我们的代码更加的简洁和重复使用。  添加下面这段代码到你的代码第一行，在contract MyToken {前添加contract owned {    address public owner;    function owned() {        owner = msg.sender;    }    modifier onlyOwner {        require(msg.sender == owner);        _;    }    function transferOwnership(address newOwner) onlyOwner {        owner = newOwner;    }}这里创建了一个非常基本的合约，只是定义了关于这个合约的一些公共函数。下一步只要添加is owner到你的合约。contract MyToken is owned {    /* the rest of the contract as usual */这样所有MyToken的函数可以使用owner这个变量和modifer onlyOnwer。这个合约也可以获得一个可以修改合约拥有者的函数。即使合约一开始设置了合约拥有者，你也可以在构造函数添加这段代码：function MyToken(    uint256 initialSupply,    string tokenName,    uint8 decimalUnits,    string tokenSymbol,    address centralMinter    ) {    if(centralMinter != 0 ) owner = centralMinter;}中心代币发行支持你能够去控制流通代币的数量。  一种情况是当你的货币实际上代表了一种区块链资产（像金币券或者政府货币），然后你想要你的虚拟库存能够真实的反应其中一种。又或者你想要控制代币的价格，适当的增加或减少流通数量。首先，我们需要增加一个变量来存储总发行量，然后在我们的构造函数去指定它。contract MyToken {    uint256 public totalSupply;    function MyToken(...) {        totalSupply = initialSupply;        ...    }    ...}现在添加一个新函数来允许合约拥有者去创建新的代币。function mintToken(address target, uint256 mintedAmount) onlyOwner {    balanceOf[target] += mintedAmount;    totalSupply += mintedAmount;    Transfer(0, owner, mintedAmount);    Transfer(owner, target, mintedAmount);}注意到函数名最后加了onlyOwner，意味着这个函数只能被设置为合约拥有者的账号调用，这样你就可以创造更多的代币。冻结资产根据你的使用场景，你可能需要会遇到一些管理障碍，比如谁可以拥有你的代币，谁不可以。这样的话你需要增加一个参数来允许合约拥有者去冻结或者解冻资产。在这个合约的任何地方添加这个变量和函数。不过建议你把映射跟其他映射放到一起，事件跟其他事件放到一起。mapping (address =&gt; bool) public frozenAccount;event FrozenFunds(address target, bool frozen);function freezeAccount(address target, bool freeze) onlyOwner {    frozenAccount[target] = freeze;    FrozenFunds(target, freeze);}对于这段代码所有账号默认都是解冻的，不过合约拥有者可以通过调用freezeAccount设置它们的一个冻结状态。  不幸的是，冻结没有任何的实际效果，因为我们还没有在转移代币的函数中做任何操作。现在修改它：function transfer(address _to, uint256 _value) {        require(!frozenAccount[msg.sender]);现在任何冻结的账号可以保留他们的代币，但是不是转移这些代币。任何账号默认都是解冻的直到你去冻结它，你也可以通过白名单的方式来管理。  只要把freezeAccount重命名为approvedAccount，然后修改最后一行代码为：require(approvedAccount[msg.sender]);自动买卖到目前为止，你已经可以信任你的代币并应用到实际场景中。但如果你想通过市场价格自动买卖来通过以太币（或其他代币）赎回。首先，需要设置买卖的价格。uint256 public sellPrice;uint256 public buyPrice;function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner {    sellPrice = newSellPrice;    buyPrice = newBuyPrice;}这是一个不经常变动的可接受价格，因为每次价格变动都需要你执行一个交易并且话费一点以太币。如果你需要一个不变的带小数位的架构，建议你参考standard data feeds下一步创建买卖函数：function buy() payable returns (uint amount){    amount = msg.value / buyPrice;                    // calculates the amount    require(balanceOf[this] &gt;= amount);               // checks if it has enough to sell    balanceOf[msg.sender] += amount;                  // adds the amount to buyer's balance    balanceOf[this] -= amount;                        // subtracts amount from seller's balance    Transfer(this, msg.sender, amount);               // execute an event reflecting the change    return amount;                                    // ends function and returns}function sell(uint amount) returns (uint revenue){    require(balanceOf[msg.sender] &gt;= amount);         // checks if the sender has enough to sell    balanceOf[this] += amount;                        // adds the amount to owner's balance    balanceOf[msg.sender] -= amount;                  // subtracts the amount from seller's balance    revenue = amount * sellPrice;    msg.sender.transfer(revenue);                     // sends ether to the seller: it's important to do this last to prevent recursion attacks    Transfer(msg.sender, this, amount);               // executes an event reflecting on the change    return revenue;                                   // ends function and returns}这些操作并不会增加新代币而是改变合约拥有者的余额。注意设置的价格不是以太币为单位，而是以wei为单位。一个以太币相当于1000000000000000000wei，所以当在以太坊设置你代币的价格时，需要在后面增加18个0。当创建合约时，为了能够回购市场上所有代币，需要支付足够多的以太币。否则你的合约就破产了，你的用户没办法去卖掉他们的代币。一个更有趣的合约可以允许一个交易所的任何人都能出价，或者可以从外部直接获取价格。自动充值每次你在以太坊做交易，你都需要支付小费给矿工，让他去计算你合约的结果。这一切可以在将来会被改变，但目前只能支付以太币，因此你所有的代币用户都需要持有以太币。如果用户的以太币数量不足以支付小费会被冻结，知道合约拥有者来支付它。但在某些场景下，你可能不想你的用户来考虑以太坊，区块链或者如何拥有以太币，所以一个有效的方法是如果检测到用户余额不足，你能够自动帮用户充值余额。首先，你需要创建一个变量来存储账户的阈值和一个函数来设置他。如果你不知道设置多少合适，可以设置5 finney（0.005个以太币）uint public minBalanceForAccounts;function setMinBalance(uint minimumBalanceInFinney) onlyOwner {        minBalanceForAccounts = minimumBalanceInFinney * 1 finney;}然后，添加下面代码到trensfer函数，让卖家退还一部分代币来充值以太币：/* Send coins */function transfer(address _to, uint256 _value) {    ...    if(msg.sender.balance &lt; minBalanceForAccounts)        sell((minBalanceForAccounts - msg.sender.balance) / sellPrice);}你也可以把支付小费的操作从卖家转移到买家：/* Send coins */function transfer(address _to, uint256 _value) {    ...    if(_to.balance&lt;minBalanceForAccounts)        _to.send(sell((minBalanceForAccounts - _to.balance) / sellPrice));}这样可以保证所有人都有足够的以太币来支付小费。工作量证明这里有一些方法通过数学公式来增加你的代币供应。一个最简单的办法就是绑定以太坊的挖矿，意思就是一旦任何人找到以太坊的区块，它也相应获得你的代币回报。你可以通过一些特殊接口来获得找到区块的账号。function giveBlockReward() {    balanceOf[block.coinbase] += 1;}也可以增加一个数学公式，让任何人知道如果解答这个公式来获得回报。下面这个例子你必须解答出当前挑战，并正确设置下一个挑战。uint public currentChallenge = 1; // Can you figure out the cubic root of this number?function rewardMathGeniuses(uint answerToCurrentReward, uint nextChallenge) {    require(answerToCurrentReward**3 == currentChallenge); // If answer is wrong do not continue    balanceOf[msg.sender] += 1;         // Reward the player    currentChallenge = nextChallenge;   // Set the next challenge}当然，计算上面这个结果通过手动是很困难的，但使用计算器就很简单，所以这游戏容易被计算机给破解。也因为最后一名赢家可以选择下一个挑战的难度，他们可以选择他们知道的，所以对其他玩家来说是很不公平的。一个更公平的系统需要设计一个对计算机来说很难的挑战，但也不是完全不可能挑战成功。一个非常好的方案是需要挑战者从很多数字中找到一个低于困难值的hash。这个方案是Adam Back在1997年首次提出，称为Hashcash,然后中本聪在2008年将它应用于比特币的工作量证明。当然你也可以创建自己的工作量证明。bytes32 public currentChallenge;                         // The coin starts with a challengeuint public timeOfLastProof;                             // Variable to keep track of when rewards were givenuint public difficulty = 10**32;                         // Difficulty starts reasonably lowfunction proofOfWork(uint nonce){    bytes8 n = bytes8(sha3(nonce, currentChallenge));    // Generate a random hash based on input    require(n &gt;= bytes8(difficulty));                   // Check if it's under the difficulty    uint timeSinceLastProof = (now - timeOfLastProof);  // Calculate time since last reward was given    require(timeSinceLastProof &gt;=  5 seconds);         // Rewards cannot be given too quickly    balanceOf[msg.sender] += timeSinceLastProof / 60 seconds;  // The reward to the winner grows by the minute    difficulty = difficulty * 10 minutes / timeSinceLastProof + 1;  // Adjusts the difficulty    timeOfLastProof = now;                              // Reset the counter    currentChallenge = sha3(nonce, currentChallenge, block.blockhash(block.number - 1));  // Save a hash that will be used as the next proof}构造函数同样也要修改，增加下面这行代码：timeOfLastProof = now;一旦你运行合约，选择这个工作量证明函数，添加你的幸运数字，然后运行。如果这个确认窗口显示一个红色警告“Data can’t be execute”，需要返回上一步设置另一个数字直到你找到一个满足交易能够执行下去的数字。一旦你找到了这个数字，你将每分钟获得一个代币奖励，分钟数取决于距离上次挑战的时间。然后这个难度将被调整，保证平均每隔10分钟才能被计算出来。完整代码pragma solidity ^0.4.16;contract owned {    address public owner;    function owned() public {        owner = msg.sender;    }    modifier onlyOwner {        require(msg.sender == owner);        _;    }    function transferOwnership(address newOwner) onlyOwner public {        owner = newOwner;    }}interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; }contract TokenERC20 {    // Public variables of the token    string public name;    string public symbol;    uint8 public decimals = 18;    // 18 decimals is the strongly suggested default, avoid changing it    uint256 public totalSupply;    // This creates an array with all balances    mapping (address =&gt; uint256) public balanceOf;    mapping (address =&gt; mapping (address =&gt; uint256)) public allowance;    // This generates a public event on the blockchain that will notify clients    event Transfer(address indexed from, address indexed to, uint256 value);    // This notifies clients about the amount burnt    event Burn(address indexed from, uint256 value);    /**     * Constrctor function     *     * Initializes contract with initial supply tokens to the creator of the contract     */    function TokenERC20(        uint256 initialSupply,        string tokenName,        string tokenSymbol    ) public {        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens        name = tokenName;                                   // Set the name for display purposes        symbol = tokenSymbol;                               // Set the symbol for display purposes    }    /**     * Internal transfer, only can be called by this contract     */    function _transfer(address _from, address _to, uint _value) internal {        // Prevent transfer to 0x0 address. Use burn() instead        require(_to != 0x0);        // Check if the sender has enough        require(balanceOf[_from] &gt;= _value);        // Check for overflows        require(balanceOf[_to] + _value &gt; balanceOf[_to]);        // Save this for an assertion in the future        uint previousBalances = balanceOf[_from] + balanceOf[_to];        // Subtract from the sender        balanceOf[_from] -= _value;        // Add the same to the recipient        balanceOf[_to] += _value;        Transfer(_from, _to, _value);        // Asserts are used to use static analysis to find bugs in your code. They should never fail        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);    }    /**     * Transfer tokens     *     * Send `_value` tokens to `_to` from your account     *     * @param _to The address of the recipient     * @param _value the amount to send     */    function transfer(address _to, uint256 _value) public {        _transfer(msg.sender, _to, _value);    }    /**     * Transfer tokens from other address     *     * Send `_value` tokens to `_to` in behalf of `_from`     *     * @param _from The address of the sender     * @param _to The address of the recipient     * @param _value the amount to send     */    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {        require(_value &lt;= allowance[_from][msg.sender]);     // Check allowance        allowance[_from][msg.sender] -= _value;        _transfer(_from, _to, _value);        return true;    }    /**     * Set allowance for other address     *     * Allows `_spender` to spend no more than `_value` tokens in your behalf     *     * @param _spender The address authorized to spend     * @param _value the max amount they can spend     */    function approve(address _spender, uint256 _value) public        returns (bool success) {        allowance[msg.sender][_spender] = _value;        return true;    }    /**     * Set allowance for other address and notify     *     * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it     *     * @param _spender The address authorized to spend     * @param _value the max amount they can spend     * @param _extraData some extra information to send to the approved contract     */    function approveAndCall(address _spender, uint256 _value, bytes _extraData)        public        returns (bool success) {        tokenRecipient spender = tokenRecipient(_spender);        if (approve(_spender, _value)) {            spender.receiveApproval(msg.sender, _value, this, _extraData);            return true;        }    }    /**     * Destroy tokens     *     * Remove `_value` tokens from the system irreversibly     *     * @param _value the amount of money to burn     */    function burn(uint256 _value) public returns (bool success) {        require(balanceOf[msg.sender] &gt;= _value);   // Check if the sender has enough        balanceOf[msg.sender] -= _value;            // Subtract from the sender        totalSupply -= _value;                      // Updates totalSupply        Burn(msg.sender, _value);        return true;    }    /**     * Destroy tokens from other account     *     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.     *     * @param _from the address of the sender     * @param _value the amount of money to burn     */    function burnFrom(address _from, uint256 _value) public returns (bool success) {        require(balanceOf[_from] &gt;= _value);                // Check if the targeted balance is enough        require(_value &lt;= allowance[_from][msg.sender]);    // Check allowance        balanceOf[_from] -= _value;                         // Subtract from the targeted balance        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance        totalSupply -= _value;                              // Update totalSupply        Burn(_from, _value);        return true;    }}/******************************************//*       ADVANCED TOKEN STARTS HERE       *//******************************************/contract MyAdvancedToken is owned, TokenERC20 {    uint256 public sellPrice;    uint256 public buyPrice;    mapping (address =&gt; bool) public frozenAccount;    /* This generates a public event on the blockchain that will notify clients */    event FrozenFunds(address target, bool frozen);    /* Initializes contract with initial supply tokens to the creator of the contract */    function MyAdvancedToken(        uint256 initialSupply,        string tokenName,        string tokenSymbol    ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}    /* Internal transfer, only can be called by this contract */    function _transfer(address _from, address _to, uint _value) internal {        require (_to != 0x0);                               // Prevent transfer to 0x0 address. Use burn() instead        require (balanceOf[_from] &gt;= _value);               // Check if the sender has enough        require (balanceOf[_to] + _value &gt;= balanceOf[_to]); // Check for overflows        require(!frozenAccount[_from]);                     // Check if sender is frozen        require(!frozenAccount[_to]);                       // Check if recipient is frozen        balanceOf[_from] -= _value;                         // Subtract from the sender        balanceOf[_to] += _value;                           // Add the same to the recipient        Transfer(_from, _to, _value);    }    /// @notice Create `mintedAmount` tokens and send it to `target`    /// @param target Address to receive the tokens    /// @param mintedAmount the amount of tokens it will receive    function mintToken(address target, uint256 mintedAmount) onlyOwner public {        balanceOf[target] += mintedAmount;        totalSupply += mintedAmount;        Transfer(0, this, mintedAmount);        Transfer(this, target, mintedAmount);    }    /// @notice `freeze? Prevent | Allow` `target` from sending &amp; receiving tokens    /// @param target Address to be frozen    /// @param freeze either to freeze it or not    function freezeAccount(address target, bool freeze) onlyOwner public {        frozenAccount[target] = freeze;        FrozenFunds(target, freeze);    }    /// @notice Allow users to buy tokens for `newBuyPrice` eth and sell tokens for `newSellPrice` eth    /// @param newSellPrice Price the users can sell to the contract    /// @param newBuyPrice Price users can buy from the contract    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public {        sellPrice = newSellPrice;        buyPrice = newBuyPrice;    }    /// @notice Buy tokens from contract by sending ether    function buy() payable public {        uint amount = msg.value / buyPrice;               // calculates the amount        _transfer(this, msg.sender, amount);              // makes the transfers    }    /// @notice Sell `amount` tokens to contract    /// @param amount amount of tokens to be sold    function sell(uint256 amount) public {        require(this.balance &gt;= amount * sellPrice);      // checks if the contract has enough ether to buy        _transfer(msg.sender, this, amount);              // makes the transfers        msg.sender.transfer(amount * sellPrice);          // sends ether to the seller. It's important to do this last to avoid recursion attacks    }}"
                        } ,
                     
                        {
                          "title"    : "以太坊发行代币(一)",
                          "category" : "",
                          "tags"     : " 区块链, 以太坊",
                          "url"      : "/2018/04/07/ethereum-crypto-currency-1.html",
                          "date"     : "April 7, 2018",
                          "excerpt"  : "本文使用到的工具geth、Mist，并通过私有链来做测试。如果你不知道还不了解，请先阅读这篇文章《搭建以太坊私有网络》先从最基本的开始，打开Mist，进入到 Contract 标签页，然后点击 Deploy New Contract在Solidity Contract Source code输入框，输入以下代码：contract MyToken {    /* This creates an array with all balances */    mapping (address =&...",
                          "content"  : "本文使用到的工具geth、Mist，并通过私有链来做测试。如果你不知道还不了解，请先阅读这篇文章《搭建以太坊私有网络》先从最基本的开始，打开Mist，进入到 Contract 标签页，然后点击 Deploy New Contract在Solidity Contract Source code输入框，输入以下代码：contract MyToken {    /* This creates an array with all balances */    mapping (address =&gt; uint256) public balanceOf;}mapping是一种关联数组，这里我们把地址和余额关联起来。  address是基本的16进制以太坊格式。  余额是一个256位的非负数整数。public意味着这个变量可以被区块链中的任何人开放，这里意味着余额是公开的。如果你这时候马上发布你的合约，它可以工作但是一点用都没有：因为里面为0没有余额，且不能挖矿来获得代币。  所以，我们可以先在合约安装时初始化一定的代币数量给创建合约的人。在最后一个大括号前添加以下代码：function MyToken() {    balanceOf[msg.sender] = 21000000;}也许你已经注意到添加代码的函数名MyToken与我们的合约名MyToken是一样的。这点非常重要，类似于我们的构造函数，它只会运行一次，且是在合约上传到网络的时候运行。  这个函数设置了msg.sender（部署了这个合约的地址）的余额21000000个。除了直接在代码中设置余额，我们还可以用更好的方法，通过传参来设置。像这样：function MyToken(uint256 initialSupply) public {    balanceOf[msg.sender] = initialSupply;}修改上面的代码后，我们在Mist的右侧选择MyToken然后就可以看到我们定义的Constructor parameters。现在你已经拥有了一个能初始化余额功能的合约，但不能交易，所有余额只会一直留在同一个账号中，所以我们接下来实现交易功能。  在最后一个大括号前添加以下代码：/* Send coins */function transfer(address _to, uint256 _value) {    /* Add and subtract new balances */    balanceOf[msg.sender] -= _value;    balanceOf[_to] += _value;}这是个非常简单的函数：它有一个接收者_to和一个数量值_value，一旦有人执行它，它会减掉他们的代币数量_value，然后添加这些代币数量到接收者_to的余额中。  这里有一个很明显的问题：由于我们没有对发送数量做限制，一个人可以发送超过他拥有的代币数量。  接下来我们将做一个简单的校验，如果发送者没有足够的余额，合约的执行将被终止。也将校验泛滥的情况，如果一个人拥有特别大的余额，将会对他做归零处理。  你可以通过return或者throw来终止合约执行。throw将会失去执行合约所支付的gas，而retun更让人头疼,他对合约所做的任何改动都将保留，而throw将会回滚所有的合约操作。由于钱包会察觉到合约将抛的异常，对用户做出警告，所以可以有效的防止因throw所浪费的gas。function transfer(address _to, uint256 _value) {    /* Check if sender has balance and for overflows */    require(balanceOf[msg.sender] &gt;= _value &amp;&amp; balanceOf[_to] + _value &gt;= balanceOf[_to]);    /* Add and subtract new balances */    balanceOf[msg.sender] -= _value;    balanceOf[_to] += _value;}我们先直接添加以下变量，在后面用来处理代币注册。string public name;string public symbol;uint8 public decimals;接下来在合约启动时，允许设置这些变量。/* Initializes contract with initial supply tokens to the creator of the contract */function MyToken(uint256 initialSupply, string tokenName, string tokenSymbol, uint8 decimalUnits) {    balanceOf[msg.sender] = initialSupply;              // Give the creator all initial tokens    name = tokenName;                                   // Set the name for display purposes    symbol = tokenSymbol;                               // Set the symbol for display purposes    decimals = decimalUnits;                            // Amount of decimals for display purposes}最后我们需要一些事件。它们是一些空函数，可以帮助客户端来发生在合约的活动。  在合约的开头声明这个事件：event Transfer(address indexed from, address indexed to, uint256 value);然后你需要在涉及到交易的函数中添加以下两行代码：/* Notify anyone listening that this transfer took place */Transfer(msg.sender, _to, _value);现在可以你的代币已经准备好了！部署现在把上面的代码复制到SOLIDITY CONTRACT SOURCE CODE。如果代码在编译没有报错，你可以在右边看到SELECT CONTRACT TO DEPLOY的下拉列表。选择MyToken合约，然后你可以在右边看到所有你需要自定义的参数。但为了这次教程，建议你设置变量为：  Initial supply : 10000  Token name : 任意你想到的名字  Token symbol : %  Decimal units : 2滚动到页面最下面，你可以看到创建合约所需要的估计费用，然后你选择一个你将要支付的费用。  你额外支付的那部分费用会退还给你，所以你可以使用默认设置。  点击deploy，输入你账号密码，点击SEND TRANSACTION,然后等待几秒让你的交易被记录。返回首页，你将看到你的交易正在被等待确认。这里我们可以利用私有链的优势，通过挖矿来实现确认。一旦确认完成，你就可以在账号主页看到你所创建的代币。如果你发送代币给你朋友，它们不会在他们的钱包看到。这是因为钱包只会追踪那些它所知道的代币，你必须手动去添加它们。  现在进入到Contract标签页,你可以看到你新创建的合约链接，点击它会去到它的页面。点击copy address，然后复制这个地址到一个文本编辑器中。为了添加钱包对代币的追踪，去到合约页，然后点击 Watch Token。这时将会出现一个弹出框，然后你需要将你上一步复制的合约地址粘贴进去。代币名称，代币符号，和小数位会自动填充进去。做完这些操作，钱包会自动显示你拥有的代币，然后你也可以发送给任何人。"
                        } ,
                     
                        {
                          "title"    : "加密散列-sha256",
                          "category" : "",
                          "tags"     : " 区块链, 密码学",
                          "url"      : "/2018/04/05/sha256.html",
                          "date"     : "April 5, 2018",
                          "excerpt"  : "SHA256是安全散列算法SHA（Secure Hash Algorithm）系列算法之一，其摘要长度为256bits，即32个字节，故称SHA256（1个字节=8位）。算法步骤原始消息分为N个512bit的消息块。每个消息块分成16个32bit，标记为M(i)0、M(i)1、M(i)2、…、M(i)15然后对这N个消息块依次进行处理。1.补位  由于必须分成n个512bit块，所以必须进行补位。  最后还需要预留64bit记录消息块的长度，所以消息块的长度不能大于2^64。补位使其长度...",
                          "content"  : "SHA256是安全散列算法SHA（Secure Hash Algorithm）系列算法之一，其摘要长度为256bits，即32个字节，故称SHA256（1个字节=8位）。算法步骤原始消息分为N个512bit的消息块。每个消息块分成16个32bit，标记为M(i)0、M(i)1、M(i)2、…、M(i)15然后对这N个消息块依次进行处理。1.补位  由于必须分成n个512bit块，所以必须进行补位。  最后还需要预留64bit记录消息块的长度，所以消息块的长度不能大于2^64。补位使其长度 先补一个1，然后再补0，直到长度满足对512取模后余数是448。总而言之，补位是至少补一位，最多补512位。以信息“abc”为例显示补位的过程。  原始信息：01100001 01100010 01100011  补位第一步：0110000101100010 01100011 1  首先补一个“1”  补位第二步：0110000101100010 01100011 10…..0  然后补423个“0”  我们可以把最后补位完成后的数据用16进制写成下面的样子  61626380 0000000000000000 00000000  00000000 0000000000000000 00000000  00000000 0000000000000000 00000000  00000000 000000002.补长度  所谓的补长度是将原始数据的长度补到已经进行了补位操作的消息后面。通常用一个64位的数据来表示原始消息的长度。如果消息长度不大于2^64，那么第一个字就是0。在进行了补长度的操作以后，整个消息就变成下面这样了（16进制格式）61626380 0000000000000000 00000000  00000000 0000000000000000 00000000  00000000 0000000000000000 00000000  00000000 0000000000000000 00000018如果原始的消息长度超过了512，我们需要将它补成512的倍数。然后我们把整个消息分成一个一个512位的数据块，分别处理每一个数据块，从而得到消息摘要。3.常量定义这些常量是对自然数中前64个质数的立方根的小数部分取前32bit而来。k[0..63] :=  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f24.哈希初值这些初值是对自然数中前8个质数3、5、7、11等的平方根的小数部分取前32bit而来。H(0)0 = 6a09e667  H(0)1 = bb67ae85  H(0)2 = 3c6ef372  H(0)3 = a54ff53a  H(0)4 = 510e527f  H(0)5 = 9b05688c  H(0)6 = 1f83d9ab  H(0)7 = 5be0cd19实现伪代码预处理append the bit '1' to the messageappend k bits '0', where k is the minimum number &gt;= 0 such that the resulting message    length (in bits) is congruent to 448(mod 512)append length of message (before pre-processing), in bits, as 64-bit big-endian integer处理# 分割512块for each chunk    # 每块分割成16个32bit    break chunk into sixteen 32-bit big-endian words w[0..15]    # 用16个32bit，扩展其他48个32bit    for i from 16 to 63        s0 := (w[i-15] rightrotate 7) xor (w[i-15] rightrotate 18) xor(w[i-15] rightshift 3)        s1 := (w[i-2] rightrotate 17) xor (w[i-2] rightrotate 19) xor(w[i-2] rightshift 10)        w[i] := w[i-16] + s0 + w[i-7] + s1    # 哈希初始值    a := h0    b := h1    c := h2    d := h3    e := h4    f := h5    g := h6    h := h7    # 主循环    for i from 0 to 63        s0 := (a rightrotate 2) xor (a rightrotate 13) xor(a rightrotate 22)        maj := (a and b) xor (a and c) xor(b and c)        t2 := s0 + maj        s1 := (e rightrotate 6) xor (e rightrotate 11) xor(e rightrotate 25)        ch := (e and f) xor ((not e) and g)        t1 := h + s1 + ch + k[i] + w[i]        h := g        g := f        f := e        e := d + t1        d := c        c := b        b := a        a := t1 + t2    # 修改哈希值    h0 := h0 + a    h1 := h1 + b    h2 := h2 + c    h3 := h3 + d    h4 := h4 + e    h5 := h5 + f    h6 := h6 + g    h7 := h7 + h# 输出结果digest = hash = h0 append h1 append h2 append h3 append h4 append h5 append h6 append h7输出值256bit的二进制值或者64个16进制的ascii码。"
                        } ,
                     
                        {
                          "title"    : "加密散列-sha1",
                          "category" : "",
                          "tags"     : " 区块链, 密码学",
                          "url"      : "/2018/04/05/sha1.html",
                          "date"     : "April 5, 2018",
                          "excerpt"  : "SHA-1（英语：Secure Hash Algorithm 1，中文名：安全散列算法1）是一种密码散列函数，美国国家安全局设计，并由美国国家标准技术研究所（NIST）发布为联邦数据处理标准（FIPS）[2]。SHA-1可以生成一个被称为消息摘要的160位（20字节）散列值，散列值通常的呈现形式为40个十六进制数。算法步骤原始消息分为N个512bit的消息块。每个消息块分成16个32bit。1.补位  由于必须分成n个512bit块，所以必须进行补位。  最后还需要预留64bit记录消息块...",
                          "content"  : "SHA-1（英语：Secure Hash Algorithm 1，中文名：安全散列算法1）是一种密码散列函数，美国国家安全局设计，并由美国国家标准技术研究所（NIST）发布为联邦数据处理标准（FIPS）[2]。SHA-1可以生成一个被称为消息摘要的160位（20字节）散列值，散列值通常的呈现形式为40个十六进制数。算法步骤原始消息分为N个512bit的消息块。每个消息块分成16个32bit。1.补位  由于必须分成n个512bit块，所以必须进行补位。  最后还需要预留64bit记录消息块的长度，所以消息块的长度不能大于2^64。补位使其长度 先补一个1，然后再补0，直到长度满足对512取模后余数是448。总而言之，补位是至少补一位，最多补512位。以信息“abc”为例显示补位的过程。  原始信息：01100001 01100010 01100011  补位第一步：0110000101100010 01100011 1  首先补一个“1”  补位第二步：0110000101100010 01100011 10…..0  然后补423个“0”  我们可以把最后补位完成后的数据用16进制写成下面的样子  61626380 0000000000000000 00000000  00000000 0000000000000000 00000000  00000000 0000000000000000 00000000  00000000 000000002.补长度  所谓的补长度是将原始数据的长度补到已经进行了补位操作的消息后面。通常用一个64位的数据来表示原始消息的长度。如果消息长度不大于2^64，那么第一个字就是0。在进行了补长度的操作以后，整个消息就变成下面这样了（16进制格式）61626380 0000000000000000 00000000  00000000 0000000000000000 00000000  00000000 0000000000000000 00000000  00000000 0000000000000000 00000018如果原始的消息长度超过了512，我们需要将它补成512的倍数。然后我们把整个消息分成一个一个512位的数据块，分别处理每一个数据块，从而得到消息摘要。3.哈希初值h0 := 0x67452301h1 := 0xEFCDAB89h2 := 0x98BADCFEh3 := 0x10325476h4 := 0xC3D2E1F0实现伪代码预处理append \"1\" bit to messageappend \"0\" bits until message length in bits ≡ 448 (mod 512)append bit length of message as 64-bit little-endian integer to message处理# 分割512块for each 512-bit chunk of message    # 每块分割成16个32bit    break chunk into sixteen 32-bit little-endian words w[i], 0 ≤ i ≤ 15    # 用16个32bit，扩展其他64个32bit    for i from 16 to 79        w[i] := (w[i-3] xor w[i-8] xor w[i-14] xor w[i-16]) leftrotate 1    # 哈希初始值    a := h0    b := h1    c := h2    d := h3    e := h4    # 主循环    for i from 0 to 79        if 0 ≤ i ≤ 19 then            f := (b and c) or ((not b) and d)            k := 0x5A827999        else if 20 ≤ i ≤ 39            f := b xor c xor d            k := 0x6ED9EBA1        else if 40 ≤ i ≤ 59            f := (b and c) or (b and d) or(c and d)            k := 0x8F1BBCDC        else if 60 ≤ i ≤ 79            f := b xor c xor d            k := 0xCA62C1D6         temp := (a leftrotate 5) + f + e + k + w[i]        e := d        d := c        c := b leftrotate 30        b := a        a := temp    # 修改哈希值    h0 := h0 + a    h1 := h1 + b    h2 := h2 + c    h3 := h3 + d    h4 := h4 + e# 输出结果digest = hash = h0 append h1 append h2 append h3 append h4输出值160bit的二进制值或者40个16进制的ascii码。"
                        } ,
                     
                        {
                          "title"    : "加密散列-PIPEMD160",
                          "category" : "",
                          "tags"     : " 区块链, 密码学",
                          "url"      : "/2018/04/05/ripemd160.html",
                          "date"     : "April 5, 2018",
                          "excerpt"  : "RIPEMD (RACE原始完整性校验讯息摘要)是一种加密哈希函数，由 鲁汶大学 Hans Dobbertin,Antoon Bosselaers 和 Bart Prenee组成的COSIC 研究小组发布于1996年。 RIPEMD是以MD4为基础原则所设计的 ，而且其表现与更有名的SHA-1类似.RIPEMD-160是以原始版RIPEMD所改进的160位元版本，而且是RIPEMD系列中最常见的版本。 RIPEMD-160是设计给学术社群所使用的，刚好相对于 国家安全局 所设计 SHA-1...",
                          "content"  : "RIPEMD (RACE原始完整性校验讯息摘要)是一种加密哈希函数，由 鲁汶大学 Hans Dobbertin,Antoon Bosselaers 和 Bart Prenee组成的COSIC 研究小组发布于1996年。 RIPEMD是以MD4为基础原则所设计的 ，而且其表现与更有名的SHA-1类似.RIPEMD-160是以原始版RIPEMD所改进的160位元版本，而且是RIPEMD系列中最常见的版本。 RIPEMD-160是设计给学术社群所使用的，刚好相对于 国家安全局 所设计 SHA-1 和 SHA-2 算法。 另一方面，RIPEMD-160比SHA-1较少使用，所以可能造成RIPEMD-160比SHA还不常被审查。另外，RIPEMD-160并没有任何专利所限制。同时也存在着128,256-320位元的这种算法，称为RIPEMD-128,RIPEMD-256和RIPEMD-320。 128位版本的用意仅是取代原始版RIPEMD，因为原版也同样是128位元，并且被发现有潜在的安全问题。 而256和320位版本只有减少碰撞发生的机率，但没有提升安全等级(以 preimage举例)。不过，RIPEMD的设计者们没有真正设计256和320位元这2种标准，他们只是在128位元和160位元的基础上，修改了初始参数和s-box来达到输出为256和320位元。所以，256位的强度和128相当，而320位的强度和160位相当。且RIPEMD建立在md的基础之上，所以其添加数据的方式和md5完全一样。伪代码原始消息分为N个512bit的消息块。每个消息块分成16个32bit。1.补位  由于必须分成n个512bit块，所以必须进行补位。  最后还需要预留64bit记录消息块的长度，所以消息块的长度不能大于2^64补位使其长度 先补一个1，然后再补0，直到长度满足对512取模后余数是448。总而言之，补位是至少补一位，最多补512位。以信息“abc”为例显示补位的过程。  原始信息：01100001 01100010 01100011  补位第一步：0110000101100010 01100011 1  首先补一个“1”  补位第二步：0110000101100010 01100011 10…..0  然后补423个“0”  我们可以把最后补位完成后的数据用16进制写成下面的样子  61626380 0000000000000000 00000000  00000000 0000000000000000 00000000  00000000 0000000000000000 00000000  00000000 000000002.补长度  所谓的补长度是将原始数据的长度补到已经进行了补位操作的消息后面。通常用一个64位的数据来表示原始消息的长度。如果消息长度不大于2^64，那么第一个字就是0。在进行了补长度的操作以后，整个消息就变成下面这样了（16进制格式）61626380 0000000000000000 00000000  00000000 0000000000000000 00000000  00000000 0000000000000000 00000000  00000000 0000000000000000 00000018如果原始的消息长度超过了512，我们需要将它补成512的倍数。然后我们把整个消息分成一个一个512位的数据块，分别处理每一个数据块，从而得到消息摘要。2.函数定义f(j, x, y, z) = x XOR y XOR z (0 &lt;= j &lt;= 15)   f(j, x, y, z) = (x AND y) OR (NOT(x) AND z) (16 &lt;= j &lt;= 31)   f(j, x, y, z) = (x OR NOT(y)) XOR z (32 &lt;= j &lt;= 47)   f(j, x, y, z) = (x AND z) OR (y AND NOT(z)) (48 &lt;= j &lt;= 63)   f(j, x, y, z) = x XOR (y OR NOT(z)) (64 &lt;= j &lt;= 79)3.常量定义added constants (hexadecimal)K(j) = 0x00000000 (0 &lt;= j &lt;= 15)   K(j) = 0x5A827999 (16 &lt;= j &lt;= 31) int(230 x sqrt(2))   K(j) = 0x6ED9EBA1 (32 &lt;= j &lt;= 47) int(230 x sqrt(3))   K(j) = 0x8F1BBCDC (48 &lt;= j &lt;= 63) int(230 x sqrt(5))   K(j) = 0xA953FD4E (64 &lt;= j &lt;= 79) int(230 x sqrt(7))   K’(j) = 0x50A28BE6 (0 &lt;= j &lt;= 15) int(230 x cbrt(2))   K’(j) = 0x5C4DD124 (16 &lt;= j &lt;= 31) int(230 x cbrt(3))   K’(j) = 0x6D703EF3 (32 &lt;= j &lt;= 47) int(230 x cbrt(5))   K’(j) = 0x7A6D76E9 (48 &lt;= j &lt;= 63) int(230 x cbrt(7))   K’(j) = 0x00000000 (64 &lt;= j &lt;= 79)selection of message wordr(j) = j (0 &lt;= j &lt;= 15)   r(16..31) = 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8   r(32..47) = 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12   r(48..63) = 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2   r(64..79) = 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13   r’(0..15) = 5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12   r’(16..31)= 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2   r’(32..47)= 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13   r’(48..63)= 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14   r’(64..79)= 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11amount for rotate left (rol)s(0..15)  = 11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8   s(16..31) = 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12   s(32..47) = 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5   s(48..63) = 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12   s(64..79) = 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6   s’(0..15) = 8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6   s’(16..31)= 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11   s’(32..47)= 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5   s’(48..63)= 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8   s’(64..79)= 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 114.哈希初值这些初值是对自然数中前8个质数3、5、7、11等的平方根的小数部分取前32bit而来。h0 = 0x67452301   h1 = 0xEFCDAB89   h2 = 0x98BADCFE   h3 = 0x10325476   h4 = 0xC3D2E1F0实现伪代码#It is assumed that the message after padding consists of t 16-word blocks#that will be denoted with X[i][j], with 0 &lt;= i &lt;= t-1 and 0 &lt;= j &lt;= 15. #The symbol [+] denotes addition modulo 2**32 and rol_s denotes cyclic left#shift (rotate) over s positions.for i := 0 to t-1 {    A := h0; B := h1; C := h2; D = h3; E = h4;    A' := h0; B' := h1; C' := h2; D' = h3; E' = h4;    for j := 0 to 79 {        T := rol_s(j)(A [+] f(j, B, C, D) [+] X[i][r(j)] [+] K(j)) [+] E;        A := E; E := D; D := rol_10(C); C := B; B := T;        T := rol_s'(j)(A' [+] f(79-j, B', C', D') [+] X[i][r'(j)] [+] K'(j)) [+] E';        A' := E'; E' := D'; D' := rol_10(C'); C' := B'; B' := T;    }    T := h1 [+] C [+] D'; h1 := h2 [+] D [+] E'; h2 := h3 [+] E [+] A';    h3 := h4 [+] A [+] B'; h4 := h0 [+] B [+] C'; h0 := T;}# 输出结果digest = hash = h0 append h1 append h2 append h3 append h4输出值160bit的二进制值或者40个16进制的ascii码。"
                        } ,
                     
                        {
                          "title"    : "Merkle树",
                          "category" : "",
                          "tags"     : " 区块链, 密码学",
                          "url"      : "/2018/04/05/merkle-tree.html",
                          "date"     : "April 5, 2018",
                          "excerpt"  : "Merkle树是一种哈希二叉树，它是一种用作快速归纳和校验大规模数据完整性的数据结构。  比特币校验区块交易数据就是使用这种算法。Merkle树是自底向上构建的。如图所示Merkle树一般用来进行完整性验证处理。在处理完整性验证的应用场景中，Merkle树会大大减少数据的传输量及计算的复杂度。成如果想要证明一个确切的数据块是Merkle树中的一员。通常，只需要树根及这个区块和通向树根沿途的中间哈希值，就可以暂时忽略树的其他部分，这些就已经足以让我们验证到树根。  一个节点只需要计算log~...",
                          "content"  : "Merkle树是一种哈希二叉树，它是一种用作快速归纳和校验大规模数据完整性的数据结构。  比特币校验区块交易数据就是使用这种算法。Merkle树是自底向上构建的。如图所示Merkle树一般用来进行完整性验证处理。在处理完整性验证的应用场景中，Merkle树会大大减少数据的传输量及计算的复杂度。成如果想要证明一个确切的数据块是Merkle树中的一员。通常，只需要树根及这个区块和通向树根沿途的中间哈希值，就可以暂时忽略树的其他部分，这些就已经足以让我们验证到树根。  一个节点只需要计算log~2~(N)个32字节的哈希值，形成一条从特定交易到树根的认证路径或者Merkle路径即可。如图所示，我们只要知道蓝色节点的hash值，就能验证  是否在树中。"
                        } ,
                     
                        {
                          "title"    : "加密散列-md5",
                          "category" : "",
                          "tags"     : " 区块链, 密码学",
                          "url"      : "/2018/04/05/md5.html",
                          "date"     : "April 5, 2018",
                          "excerpt"  : "MD5消息摘要算法（英语：MD5 Message-Digest Algorithm），一种被广泛使用的密码散列函数，可以产生出一个128位（16字节）的散列值（hash value），用于确保信息传输完整一致。算法步骤原始消息分为N个512bit的消息块。每个消息块分成16个32bit。1.补位  由于必须分成n个512bit块，所以必须进行补位。  最后还需要预留64bit记录消息块的长度，所以消息块的长度不能大于2^64。补位使其长度 先补一个1，然后再补0，直到长度满足对512取模后...",
                          "content"  : "MD5消息摘要算法（英语：MD5 Message-Digest Algorithm），一种被广泛使用的密码散列函数，可以产生出一个128位（16字节）的散列值（hash value），用于确保信息传输完整一致。算法步骤原始消息分为N个512bit的消息块。每个消息块分成16个32bit。1.补位  由于必须分成n个512bit块，所以必须进行补位。  最后还需要预留64bit记录消息块的长度，所以消息块的长度不能大于2^64。补位使其长度 先补一个1，然后再补0，直到长度满足对512取模后余数是448。总而言之，补位是至少补一位，最多补512位。以信息“abc”为例显示补位的过程。  原始信息：01100001 01100010 01100011  补位第一步：0110000101100010 01100011 1  首先补一个“1”  补位第二步：0110000101100010 01100011 10…..0  然后补423个“0”  我们可以把最后补位完成后的数据用16进制写成下面的样子  61626380 0000000000000000 00000000  00000000 0000000000000000 00000000  00000000 0000000000000000 00000000  00000000 000000002.补长度  所谓的补长度是将原始数据的长度补到已经进行了补位操作的消息后面。通常用一个64位的数据来表示原始消息的长度。如果消息长度不大于2^64，那么第一个字就是0。在进行了补长度的操作以后，整个消息就变成下面这样了（16进制格式）61626380 0000000000000000 00000000  00000000 0000000000000000 00000000  00000000 0000000000000000 00000000  00000000 0000000000000000 00000018如果原始的消息长度超过了512，我们需要将它补成512的倍数。然后我们把整个消息分成一个一个512位的数据块，分别处理每一个数据块，从而得到消息摘要。3.常量定义r[ 0..15]：= {7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22}  r[16..31]：= {5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20}  r[32..47]：= {4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23}  r[48..63]：= {6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21}4.哈希初值h0 := 0x67452301h1 := 0xEFCDAB89h2 := 0x98BADCFEh3 := 0x10325476实现伪代码预处理append \"1\" bit to messageappend \"0\" bits until message length in bits ≡ 448 (mod 512)append bit length of message as 64-bit little-endian integer to message处理# 分割512块for each 512-bit chunk of message    # 每块分割成16个32bit    break chunk into sixteen 32-bit little-endian words w[i], 0 ≤ i ≤ 15    # 哈希初始值    var int a := h0    var int b := h1    var int c := h2    var int d := h3    # 主循环    for i from 0 to 63        if 0 ≤ i ≤ 15 then            f := (b and c) or ((not b) and d)            g := i        else if 16 ≤ i ≤ 31            f := (d and b) or ((not d) and c)            g := (5×i + 1) mod 16        else if 32 ≤ i ≤ 47            f := b xor c xor d            g := (3×i + 5) mod 16        else if 48 ≤ i ≤ 63            f := c xor (b or (not d))            g := (7×i) mod 16         temp := d        d := c        c := b        b := leftrotate((a + f + k[i] + w[g]),r[i]) + b        a := temp    Next i    # 修改哈希值    h0 := h0 + a    h1 := h1 + b    h2 := h2 + c    h3 := h3 + dEnd ForEach# 输出结果var int digest := h0 append h1 append h2 append h3 //(expressed as little-endian)输出值128bit的二进制值或者32个16进制的ascii码。"
                        } ,
                     
                        {
                          "title"    : "搭建以太坊私有网络",
                          "category" : "",
                          "tags"     : " 区块链, 以太坊",
                          "url"      : "/2018/04/01/ether-private-network.html",
                          "date"     : "April 1, 2018",
                          "excerpt"  : "Geth可以通过命令行方式实现以太坊的各种功能,如账户的新建编辑删除，开启挖矿，ether币的转移，智能合约的部署和执行等等。安装brew tap ethereum/ethereumbrew install ethereum安装完成后检查，输入geth version创建私有网络1.创建一个目录，如geth-private-test2.进入该目录下，创建文件genesis.json，并写入以下内容{  \"config\": {        \"chainId\": 10,       ...",
                          "content"  : "Geth可以通过命令行方式实现以太坊的各种功能,如账户的新建编辑删除，开启挖矿，ether币的转移，智能合约的部署和执行等等。安装brew tap ethereum/ethereumbrew install ethereum安装完成后检查，输入geth version创建私有网络1.创建一个目录，如geth-private-test2.进入该目录下，创建文件genesis.json，并写入以下内容{  \"config\": {        \"chainId\": 10,        \"homesteadBlock\": 0,        \"eip155Block\": 0,        \"eip158Block\": 0  },  \"coinbase\"   : \"0x0000000000000000000000000000000000000000\",  \"difficulty\" : \"0x20000\",  \"extraData\"  : \"\",  \"gasLimit\"   : \"0x2fefd8\",  \"nonce\"      : \"0x0000000000000042\",  \"mixhash\"    : \"0x0000000000000000000000000000000000000000000000000000000000000000\",  \"parentHash\" : \"0x0000000000000000000000000000000000000000000000000000000000000000\",  \"timestamp\"  : \"0x00\",  \"alloc\"      : { }}3.初始化，并指定数据目录，例如这里的chaingeth init ./genesis.json --datadir ./chain4.进入后台，并指定日志输出文件，例如这里的eth_output.logsgeth --datadir ./chain --nodiscover console 2&gt;&gt; eth_output.logs后续操作可以通过 tail -f eth_output.logs 查看日志输出5.创建用户查看当前用户列表eth.accounts可以看到是空的[]创建新用户personal.newAccount(密码)完成再查看用户列表，即可看到用户。例如我这里创建了两个用户。挖矿开始挖矿miner.start()执行一段时间后，可以看到用户余额已经增加了。结束挖矿miner.stop()MistMist是以太坊钱包，可作为我们geth的可视化操作界面。安装可直接到官网选择适合自己版本下载安装。启动并连接我们的已经创建好的私有网络/Applications/Mist.app/Contents/MacOS/Mist --rpc ~/geth-private-test/chain/geth.ipc启动后如下图所示点击 LAUNCH APPLICATION 进入，如图所示如果页面显示的账号跟我们geth显示的账号一致，且显示的网络是Private，说明已经连接成功了。   后续geth的操作都会同步到Mist。"
                        } ,
                     
                        {
                          "title"    : "密码学",
                          "category" : "",
                          "tags"     : " 区块链, 密码学",
                          "url"      : "/2018/04/01/cryptography.html",
                          "date"     : "April 1, 2018",
                          "excerpt"  : "对称加密加密  解密   优点  加解密效率高（速度快，空间占用小），加密强度高。缺点  安全性弱，密钥由多方管理，密钥容易泄露。常见加密算法  DES、3DES、Blowfish、RC2、AES以及国密的SM4。非对称加密加密  解密   优点  安全性高，公私钥分离。缺点  加解密效率低。常见加密算法  RSA、椭圆曲线算法同态加密是一种特殊的加密方法，允许对密文进行处理得到仍然是加密的结果，即对密文直接进行处理，跟对明文进行处理再加密，得到的结果相同。从代数的角度讲，即同态性。如果定...",
                          "content"  : "对称加密加密  解密   优点  加解密效率高（速度快，空间占用小），加密强度高。缺点  安全性弱，密钥由多方管理，密钥容易泄露。常见加密算法  DES、3DES、Blowfish、RC2、AES以及国密的SM4。非对称加密加密  解密   优点  安全性高，公私钥分离。缺点  加解密效率低。常见加密算法  RSA、椭圆曲线算法同态加密是一种特殊的加密方法，允许对密文进行处理得到仍然是加密的结果，即对密文直接进行处理，跟对明文进行处理再加密，得到的结果相同。从代数的角度讲，即同态性。如果定义一个运算符 ，对加密算法 E 和 解密算法 D，满足 则意味着对于该运算满足同态性。同态性在代数上包括：加法同态、乘法同态、减法同态和除法同态。同时满足加法同态和乘法同态，则意味着是 代数同态，即 全同态。同时满足四种同态性，则被称为 算数同态。函数加密与同态加密相关的一个问题是函数加密。同态加密保护的是数据本身，而函数加密顾名思义保护的是处理函数本身，即让第三方看不到处理过程的前提下，对数据进行处理。该问题已被证明是不存在对多个通用函数的任意多 key 的方案，目前仅能做到对某个特定函数的一个 key 的方案。Hash算法公式  公式说明  m：任意长度消息（实际上有长度限制的，但因为长度可以非常大，这里可以认为是任意长度消息） H：哈希函数  h：固定长度的哈希值一个优秀的 hash 算法，将能实现：  正向快速：给定明文和 hash 算法，在有限时间和有限资源内能计算出 hash 值。  逆向困难：给定（若干） hash 值，在有限时间内很难（基本不可能）逆推出明文。  输入敏感：原始输入信息修改一点信息，产生的 hash 值看起来应该都有很大不同。  冲突避免：很难找到两段内容不同的明文，使得它们的 hash 值一致（发生冲突），又称抗碰撞性。抗碰撞性  哈希函数的抗碰撞性是指寻找两个能够产生碰撞的消息在计算上是不可行的。但找到两个碰撞的消息在计算上不可行，并不意味着不存在两个碰撞的消息。哈希函数是把大空间上的消息压缩到小空间上，碰撞肯定存在。只是计算上是不可行的。主流hash算法  MD5(安全性不足应用于商业场景)  SHA-1(安全性不足应用于商业场景)  SHA-2PIPEMD其他流行加密算法Merkle树数字摘要对数字内容进行 Hash 运算，获取唯一的摘要值来指代原始数字内容。数字摘要是解决确保内容没被篡改过的问题（利用 Hash 函数的抗碰撞性特点）。数字摘要是 Hash 算法最重要的一个用途。在网络上下载软件或文件时，往往同时会提供一个数字摘要值，用户下载下来原始文件可以自行进行计算，并同提供的摘要值进行比对，以确保内容没有被修改过。数字签名乙方收到甲方传过来的一串信息，怎么能够确定确实是甲方而不是有人伪造呢？我们把非对称加密反过来做就可以了，因为只有甲方自己才持有一份秘密的私钥，他拿这个私钥对数据进行加密得到密文 C = EA私(M)，乙方持有甲方的公钥，解密明文P = DA公(C)，如果能够解密成功就证明信息确实是甲方所发。不过通常不需要对发送信息的整个内容都加密，那样太慢。只需要计算一个信息的唯一信息摘要并对信息摘要加密解密即可，下面就会讲到数据摘要算法（俗称HASH算法），这也是数字签名的算法名称，很多时候是一个摘要算法+非对称算法，例如SHA1RSA, SHA256RSA等。数字证书数字证书用来证明某个公钥是谁的，并且内容是正确的。对于非对称加密算法和数字签名来说，很重要的一点就是公钥的分发。一旦公钥被人替换（典型的如中间人攻击），则整个安全体系将被破坏掉。怎么确保一个公钥确实是某个人的原始公钥？这就需要数字证书机制。顾名思义，数字证书就是像一个证书一样，证明信息和合法性。由证书认证机构（Certification Authority，CA）来签发，权威的 CA 包括 verisign 等。数字证书内容可能包括版本、序列号、签名算法类型、签发者信息、有效期、被签发人、签发的公开密钥、CA 数字签名、其它信息等等，一般使用最广泛的标准为 ITU 和 ISO 联合制定的 X.509 规范。其中，最重要的包括 签发的公开密钥、CA 数字签名 两个信息。因此，只要通过这个证书就能证明某个公钥是合法的，因为带有 CA 的数字签名。更进一步地，怎么证明 CA 的签名合法不合法呢？类似的，CA 的数字签名合法不合法也是通过 CA 的证书来证明的。主流操作系统和浏览器里面会提前预置一些 CA 的证书（承认这些是合法的证书），然后所有基于他们认证的签名都会自然被认为合法。PKI体系在非对称加密中，公钥则可以通过证书机制来进行保护，如何管理和分发证书则可以通过 PKI（Public Key Infrastructure）来保障。顾名思义，PKI 体系在现代密码学应用领域处于十分基础的地位，解决了十分核心的证书管理问题。PKI 并不代表某个特定的密码学技术和流程，PKI 是建立在公私钥基础上实现安全可靠传递消息和身份确认的一个通用框架。实现了 PKI 的平台可以安全可靠地管理网络中用户的密钥和证书，包括多个实现和变种，知名的有 RSA 公司的 PKCS（Public Key Cryptography Standards）标准和 X.509 规范等。一般情况下，PKI 至少包括如下组件：CA（Certification Authority）：负责证书的颁发和作废，接收来自 RA 的请求，是最核心的部分；RA（Registration Authority）：对用户身份进行验证，校验数据合法性，负责登记，审核过了就发给 CA；证书数据库：存放证书，一般采用 LDAP 目录服务，标准格式采用 X.500 系列。CA 是最核心的组件，主要完成对证书的管理。常见的流程为，用户通过 RA 登记申请证书，CA 完成证书的制造，颁发给用户。用户需要撤销证书则向 CA 发出申请。之前章节内容介绍过，密钥有两种类型：用于签名和用于加解密，对应称为 签名密钥对 和 加密密钥对。用户证书可以有两种方式。一般可以由 CA 来生成证书和私钥；也可以自己生成公钥和私钥，然后由 CA 来对公钥进行签发。后者情况下，当用户私钥丢失后，CA 无法完成恢复。"
                        } ,
                     
                        {
                          "title"    : "共识算法",
                          "category" : "",
                          "tags"     : " 区块链, 算法",
                          "url"      : "/2018/03/23/agreement.html",
                          "date"     : "March 23, 2018",
                          "excerpt"  : "查看原图  drow.io源文件下载",
                          "content"  : "查看原图  drow.io源文件下载"
                        } ,
                     
                        {
                          "title"    : "比特币挖矿",
                          "category" : "",
                          "tags"     : " 区块链, 比特币",
                          "url"      : "/2018/03/18/bitcoin-mining.html",
                          "date"     : "March 18, 2018",
                          "excerpt"  : "查看原图  drow.io源文件下载",
                          "content"  : "查看原图  drow.io源文件下载"
                        } ,
                     
                        {
                          "title"    : "比特币51攻击",
                          "category" : "",
                          "tags"     : " 区块链, 比特币",
                          "url"      : "/2018/03/18/bitcoin-51attach.html",
                          "date"     : "March 18, 2018",
                          "excerpt"  : "查看原图  drow.io源文件下载",
                          "content"  : "查看原图  drow.io源文件下载"
                        } ,
                     
                        {
                          "title"    : "RSA算法",
                          "category" : "",
                          "tags"     : " 加密, 算法",
                          "url"      : "/2018/03/17/rsa.html",
                          "date"     : "March 17, 2018",
                          "excerpt"  : "查看原图  drow.io源文件下载",
                          "content"  : "查看原图  drow.io源文件下载"
                        } ,
                     
                        {
                          "title"    : "拜占庭算法",
                          "category" : "",
                          "tags"     : " 共识, 算法",
                          "url"      : "/2018/03/09/Byzantine-failures.html",
                          "date"     : "March 9, 2018",
                          "excerpt"  : "查看原图  drow.io源文件下载",
                          "content"  : "查看原图  drow.io源文件下载"
                        } ,
                     
                        {
                          "title"    : "比特币网络",
                          "category" : "",
                          "tags"     : " 区块链, 比特币",
                          "url"      : "/2018/03/03/bitcoin-network.html",
                          "date"     : "March 3, 2018",
                          "excerpt"  : "查看原图  drow.io源文件下载",
                          "content"  : "查看原图  drow.io源文件下载"
                        } ,
                     
                        {
                          "title"    : "比特币区块链",
                          "category" : "",
                          "tags"     : " 区块链, 比特币",
                          "url"      : "/2018/03/03/bitcoin-chain.html",
                          "date"     : "March 3, 2018",
                          "excerpt"  : "查看原图  drow.io源文件下载",
                          "content"  : "查看原图  drow.io源文件下载"
                        } ,
                     
                        {
                          "title"    : "比特币交易",
                          "category" : "",
                          "tags"     : " 区块链, 比特币",
                          "url"      : "/2018/02/25/bitcoin-exchange.html",
                          "date"     : "February 25, 2018",
                          "excerpt"  : "查看原图  drow.io源文件下载",
                          "content"  : "查看原图  drow.io源文件下载"
                        } ,
                     
                        {
                          "title"    : "比特币钱包",
                          "category" : "",
                          "tags"     : " 区块链, 比特币",
                          "url"      : "/2018/02/21/bitcoin-wallet.html",
                          "date"     : "February 21, 2018",
                          "excerpt"  : "查看原图  drow.io源文件下载",
                          "content"  : "查看原图  drow.io源文件下载"
                        } ,
                     
                        {
                          "title"    : "比特币地址&amp;密钥",
                          "category" : "",
                          "tags"     : " 区块链, 比特币",
                          "url"      : "/2018/02/21/bitcoin-address.html",
                          "date"     : "February 21, 2018",
                          "excerpt"  : "查看原图  drow.io源文件下载",
                          "content"  : "查看原图  drow.io源文件下载"
                        } ,
                     
                        {
                          "title"    : "shadowsock部署",
                          "category" : "",
                          "tags"     : " shadowsock",
                          "url"      : "/2017/12/11/shadowsock.html",
                          "date"     : "December 11, 2017",
                          "excerpt"  : "部署我是选了网上大多数人推荐的vultr，性价比高，而且还有很骚的操作，后面讲。  1.选服务器，直接选最便宜的，因为我只是拿来当ss用。  2.安装ss参考文章以root用户进入该服务器终端，执行一下命令wget --no-check-certificate -O shadowsocks-all.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.shchmo...",
                          "content"  : "部署我是选了网上大多数人推荐的vultr，性价比高，而且还有很骚的操作，后面讲。  1.选服务器，直接选最便宜的，因为我只是拿来当ss用。  2.安装ss参考文章以root用户进入该服务器终端，执行一下命令wget --no-check-certificate -O shadowsocks-all.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.shchmod +x shadowsocks-all.sh./shadowsocks-all.sh 2&gt;&amp;1 | tee shadowsocks-all.log过程中会提示你输入ss的脚本语言、密码、端口、以及加密方式3.安装加速器参考文章执行wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh &amp;&amp; chmod +x bbr.sh &amp;&amp; ./bbr.sh验证uname -r4.骚操作vultr它是以小时来计费的，即使你是月付的，它也会折算成小时。 那它是怎么算使用的，你部署了服务器，就算使用。  所以我们可以把部署好ss的服务器备份，然后在你不使用的时候摧毁掉，想用的时候再恢复。第一步：点击Add Snapshot，创建一个备份，名称随便填第二步：摧毁第三步：恢复使用安装shadowsocks客户端macbrew install shadowsocks-libevubuntusudo apt install shadowsocks使用shadowsocks客户端1.创建新连接  2.设置ip、端口、加密方式  这样就可以使用我们搭建的ss服务了，其他应用如果要走ss，只需连上我们的shadowsocks即可。 默认shadowsocks的端口为1080我以dropbox为例  只要在首选项&gt;网络&gt;设置代理即可  命令行使用安装proxychains-ngmacbrew install proxychains-ngubuntu# 安装git clone https://github.com/rofl0r/proxychains-ng.git./configure --prefix=/usr --sysconfdir=/etcmakesudo make installsudo make install-config# 配置 socks4 127.0.0.1 9050改为socks5 127.0.0.1 1080vi /usr/local/etc/proxychains.conf# 验证ip是否为ss服务器的ipproxychains4 curl ip.gs之后如果需要只用ss，只要在命令前加上proxychains4即可。"
                        } ,
                     
                        {
                          "title"    : "php实现记住登录",
                          "category" : "",
                          "tags"     : " php, 登录",
                          "url"      : "/2017/06/25/php-remember-login.html",
                          "date"     : "June 25, 2017",
                          "excerpt"  : "流程1.用户通过点击“记住密码”，提交登陆表单传递给服务器。  2.服务器生成唯一标识token，保存到数据库  3.写cookie，设置失效时间（这样token就保存到了客户端）  4.如果用户登陆失效，服务器取客户端token进行校验  5.token与服务器保存的token一致，且没有失效，则判定用户登录成功  6.token与服务器保存的token不一致或超过失效时间，则判定用户需要重新登录方案一用用户id来作为token，如remember_user=1337，这样等于把用户id...",
                          "content"  : "流程1.用户通过点击“记住密码”，提交登陆表单传递给服务器。  2.服务器生成唯一标识token，保存到数据库  3.写cookie，设置失效时间（这样token就保存到了客户端）  4.如果用户登陆失效，服务器取客户端token进行校验  5.token与服务器保存的token一致，且没有失效，则判定用户登录成功  6.token与服务器保存的token不一致或超过失效时间，则判定用户需要重新登录方案一用用户id来作为token，如remember_user=1337，这样等于把用户id暴露了出来。 这样一来，可以不断尝试不同的用户id来登录其他人的账号，甚至可以登录管理员账号，相当危险！！方案二使用一个随机字符串作为token。function generateInsecureToken($length = 20){    $buf = '';    for ($i = 0; $i &lt; $length; ++$i) {        $buf .= chr(mt_rand(0, 255));    }    return bin2hex($buf);}mt_rant其实并不安全，如果你要生成随机数，可以使用以下几个方案1.RandomLib12.random_bytes($length) (PHP 7, or available in PHP 5 via random_compat2)  3.Raw bytes read from /dev/urandom  4.mcrypt_create_iv($length, MCRYPT_DEV_URANDOM)  5.openssl_random_pseudo_bytes($length)可以这么写function generateToken($length = 20){    return bin2hex(random_bytes($length));}这个方案会有时序攻击的风险。 如果你的token＝WBWgm2oMFxsiGRGQNJ6n8gtN3gOuQ2wjN8ZRjZtU0Mn 如果你是通过数据库来校验SELECT * FROM auth_tokens WHERE token = 'WBWgm2oMFxsiGRGQNJ6n8gtN3gOuQ2wjN8ZRjZtU0Mn';或者通过从数据库取出token，在程序中做简单校验$getToken = $_GET[‘token’];if ($getToken == $token) {    //success} else {    //fail}这时有人按以下步骤修改他的cookie1.第一次把第一个字节从W改为X  2.第二次把最后一个字节从n改为o 第二次的校验时间要比第一次的校验时间要短，这样用户可以不断修改尝试来确认更改的字符是否正确，就是一次时序攻击。参考It’s All About Time. 这个时间差异仅在纳秒级有意义。 这不是一个简单或容易的攻击，但是我们写一个存在风险的程序是完全没有意义的。方案三在token中不留下任何有用的信息（甚至服务器时间）给攻击者。 使用selector:validator来取代单一的token，通过selector在数据库中去取出validator,这样可以防止不可避免的时序风险。从数据库取出token，程序中使用hash_equals()来做校验，因为hash_equals()能够防止时序攻击。生成tokenif ($login-&gt;success &amp;&amp; $login-&gt;rememberMe) { // However you implement it    $selector = base64_encode(random_bytes(9));    $authenticator = random_bytes(33);    setcookie(        'remember',         $selector.':'.base64_encode($authenticator),         time() + 864000,         '/',         'yourdomain.com',         true, // TLS-only         true  // http-only    );    $database-&gt;exec(        \"INSERT INTO auth_tokens (selector, token, userid, expires) VALUES (?, ?, ?, ?)\",         [            $selector,            hash('sha256', $authenticator),            $login-&gt;userId,            date('Y-m-d\TH:i:s', time() + 864000)        ]    );}验证if (empty($_SESSION['userid']) &amp;&amp; !empty($_COOKIE['remember'])) {    list($selector, $authenticator) = explode(':', $_COOKIE['remember']);    $row = $database-&gt;selectRow(        \"SELECT * FROM auth_tokens WHERE selector = ?\",        [            $selector        ]    );    if (hash_equals($row['token'], hash('sha256', base64_decode($authenticator)))) {        $_SESSION['userid'] = $row['userid'];        // Then regenerate login token as above    }}实际例子这里没有把uc记住登陆接口用异步请求去处理，主要因为我们系统并不都在同个主域名下，所以如果要实现全系统统一记住登陆处理，只能跳转到uc，在uc设置cookie。1.记住登录 sequenceDiagram    participant 系统A    participant UC    系统A--&gt;&gt;UC: 请求异步登录接口校验    UC-&gt;&gt;系统A: 返回登录校验结果    Note left of 系统A: 失败则结束流程    系统A--&gt;&gt;UC: 跳转到记住登录接口    Note right of UC: 1.生成token 2.写入数据库 3.设置cookie    UC-&gt;&gt;系统A: 跳转回系统A首页    Note left of 系统A: 完成2.校验登录 sequenceDiagram    participant 系统A    participant UC    系统A--&gt;&gt;UC: 跳转到校验记住登录接口    Note right of UC: 校验cookie及有效期    Note right of UC: 校验失败    UC-&gt;&gt;系统A: 跳转回系统A登录页    Note left of 系统A: 完成    Note right of UC: 校验成功 1.生成新token 2.写入数据库 3.设置cookie    UC-&gt;&gt;系统A: 跳转回系统A首页    Note left of 系统A: 完成3.移除记住登录 sequenceDiagram    participant 系统A    participant UC    系统A--&gt;&gt;UC: 跳转到移除记住登录接口    Note right of UC: 1.删除cookie 2.删除数据库token    UC-&gt;&gt;系统A: 跳转回系统A首页    Note left of 系统A: 完成资源            https://github.com/ircmaxell/RandomLib &#8617;              https://github.com/paragonie/random_compat &#8617;      "
                        } ,
                     
                        {
                          "title"    : "php实现webSocket",
                          "category" : "",
                          "tags"     : " php, webSocket",
                          "url"      : "/2017/06/11/php-websocket.html",
                          "date"     : "June 11, 2017",
                          "excerpt"  : "socketSocket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。执行流程服务器端  1.初始化  2.绑定端口(bind)  3.进入监听(listen)  4.阻塞(accept),等待用户连接  5.接收，发送客户端数据客户端  1.初始化  2.连接服务器(connect)  3...",
                          "content"  : "socketSocket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。执行流程服务器端  1.初始化  2.绑定端口(bind)  3.进入监听(listen)  4.阻塞(accept),等待用户连接  5.接收，发送客户端数据客户端  1.初始化  2.连接服务器(connect)  3.发送，读取数据实现服务器端&lt;?php//确保在连接客户端时不会超时set_time_limit(0);$ip = '127.0.0.1';$port = 1935;/* +------------------------------- *    @socket通信整个过程 +------------------------------- *    @socket_create *    @socket_bind *    @socket_listen *    @socket_accept *    @socket_read *    @socket_write *    @socket_close +-------------------------------- *//*----------------    以下操作都是手册上的    -------------------*/if(($sock = socket_create(AF_INET,SOCK_STREAM,SOL_TCP)) &lt; 0) {    echo \"socket_create() 失败的原因是:\".socket_strerror($sock).\"\n\";}if(($ret = socket_bind($sock,$ip,$port)) &lt; 0) {    echo \"socket_bind() 失败的原因是:\".socket_strerror($ret).\"\n\";}if(($ret = socket_listen($sock,4)) &lt; 0) {    echo \"socket_listen() 失败的原因是:\".socket_strerror($ret).\"\n\";}$count = 0;do {    if (($msgsock = socket_accept($sock)) &lt; 0) {        echo \"socket_accept() failed: reason: \" . socket_strerror($msgsock) . \"\n\";        break;    } else {                //发到客户端        $msg =\"测试成功！\n\";        socket_write($msgsock, $msg, strlen($msg));                echo \"测试成功了啊\n\";        $buf = socket_read($msgsock,8192);                        $talkback = \"收到的信息:$buf\n\";        echo $talkback;                if(++$count &gt;= 5){            break;        };                }    //echo $buf;    socket_close($msgsock);} while (true);socket_close($sock);?&gt;客户端&lt;?phperror_reporting(E_ALL);set_time_limit(0);echo \"&lt;h2&gt;TCP/IP Connection&lt;/h2&gt;\n\";$port = 1935;$ip = \"127.0.0.1\";/* +------------------------------- *    @socket连接整个过程 +------------------------------- *    @socket_create *    @socket_connect *    @socket_write *    @socket_read *    @socket_close +-------------------------------- */$socket = socket_create(AF_INET, SOCK_STREAM, SOL_TCP);if ($socket &lt; 0) {    echo \"socket_create() failed: reason: \" . socket_strerror($socket) . \"\n\";}else {    echo \"OK.\n\";}echo \"试图连接 '$ip' 端口 '$port'...\n\";$result = socket_connect($socket, $ip, $port);if ($result &lt; 0) {    echo \"socket_connect() failed.\nReason: ($result) \" . socket_strerror($result) . \"\n\";}else {    echo \"连接OK\n\";}$in = \"Ho\r\n\";$in .= \"first blood\r\n\";$out = '';if(!socket_write($socket, $in, strlen($in))) {    echo \"socket_write() failed: reason: \" . socket_strerror($socket) . \"\n\";}else {    echo \"发送到服务器信息成功！\n\";    echo \"发送的内容为:&lt;font color='red'&gt;$in&lt;/font&gt; &lt;br&gt;\";}while($out = socket_read($socket, 8192)) {    echo \"接收服务器回传信息成功！\n\";    echo \"接受的内容为:\",$out;}echo \"关闭SOCKET...\n\";socket_close($socket);echo \"关闭OK\n\";?&gt;webSocket执行流程  1.初始化  2.绑定端口  3.监听  4.等待用户连接  5.客户端发送握手  6.服务器响应握手  7.握手完毕后,可以相互传输数据  8.连接结束,发送关闭控制帧并断开TCP握手流程socket-select说明function socket_select (array &amp;$read, array &amp;$write, array &amp;$except, $tv_sec, $tv_usec = null)获取read数组中活动的socket，并且把不活跃的从read数组中删除,具体的看文档. 这是一个同步方法，必须得到响应之后才会继续下一步,常用在同步非阻塞IO。  1.新连接到来时,被监听的端口是活跃的,如果是新数据到来或者客户端关闭链接时,活跃的是对应的客户端socket而不是服务器上被监听的端口  2.如果客户端发来数据没有被读走,则socket_select将会始终显示客户端是活跃状态并将其保存在readfds数组中  3.如果客户端先关闭了,则必须手动关闭服务器上相对应的客户端socket,否则socket_select也始终显示该客户端活跃(这个道理跟”有新连接到来然后没有用socket_access把它读出来,导致监听的端口一直活跃”是一样的)实现server.php&lt;?php/** * Simple server class which manage WebSocket protocols * @author Sann-Remy Chea &lt;http://srchea.com&gt; * @license This program is free software: you can redistribute it and/or modify * 	it under the terms of the GNU General Public License as published by * 	the Free Software Foundation, either version 3 of the License, or * 	(at your option) any later version. * 	This program is distributed in the hope that it will be useful, * 	but WITHOUT ANY WARRANTY; without even the implied warranty of * 	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the * 	GNU General Public License for more details. * 	You should have received a copy of the GNU General Public License * 	along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;. * @version 1.0.0 */namespace PushWebSocket;class Server {	/**	 * The address of the server	 * @var String	 */	private $address;	/**	 * The port for the master socket	 * @var int	 */	private $port;	/**	 * The master socket	 * @var Resource	 */	private $master;	/**	 * The array of sockets (1 socket = 1 client)	 * @var Array of resource	 */	private $sockets;	/**	 * The array of connected clients	 * @var Array of clients	 */	private $clients;	/**	 * If true, the server will print messages to the terminal	 * @var Boolean	 */	private $verboseMode;	/**	 * Server constructor	 * @param $address The address IP or hostname of the server (default: 127.0.0.1).	 * @param $port The port for the master socket (default: 5001)	 */	public function __construct($address = '127.0.0.1', $port = 5001, $verboseMode = false) {		$this-&gt;console(\"Server starting...\");		$this-&gt;address = $address;		$this-&gt;port = $port;		$this-&gt;verboseMode = $verboseMode;		// socket creation		$socket = socket_create(AF_INET, SOCK_STREAM, SOL_TCP);		socket_set_option($socket, SOL_SOCKET, SO_REUSEADDR, 1);		if(!is_resource($socket)) {			$this-&gt;console(\"socket_create() failed: \".socket_strerror(socket_last_error()), true);		}		if(!socket_bind($socket, $this-&gt;address, $this-&gt;port)) {			$this-&gt;console(\"socket_bind() failed: \".socket_strerror(socket_last_error()), true);		}		if(!socket_listen($socket, 20)) {			$this-&gt;console(\"socket_listen() failed: \".socket_strerror(socket_last_error()), true);		}		$this-&gt;master = $socket;		$this-&gt;sockets = array($socket);		$this-&gt;console(\"Server started on {$this-&gt;address}:{$this-&gt;port}\");	}	/**	 * Create a client object with its associated socket	 * @param $socket	 */	private function connect($socket) {		$this-&gt;console(\"Creating client...\");		$client = new \PushWebSocket\Client(uniqid(), $socket);		$this-&gt;clients[] = $client;		$this-&gt;sockets[] = $socket;		$this-&gt;console(\"Client #{$client-&gt;getId()} is successfully created!\");	}	/**	 * Do the handshaking between client and server	 * @param $client	 * @param $headers	 */	private function handshake($client, $headers) {		$this-&gt;console(\"Getting client WebSocket version...\");		if(preg_match(\"/Sec-WebSocket-Version: (.*)\r\n/\", $headers, $match)) {			$version = $match[1];		}		else {			$this-&gt;console(\"The client doesn't support WebSocket\");			return false;		}		$this-&gt;console(\"Client WebSocket version is {$version}, (required: 13)\");		if($version == 13) {			// Extract header variables			$this-&gt;console(\"Getting headers...\");			if(preg_match(\"/GET (.*) HTTP/\", $headers, $match))				$root = $match[1];			if(preg_match(\"/Host: (.*)\r\n/\", $headers, $match))				$host = $match[1];			if(preg_match(\"/Origin: (.*)\r\n/\", $headers, $match))				$origin = $match[1];			if(preg_match(\"/Sec-WebSocket-Key: (.*)\r\n/\", $headers, $match))				$key = $match[1];			$this-&gt;console(\"Client headers are:\");			$this-&gt;console(\"\t- Root: \".$root);			$this-&gt;console(\"\t- Host: \".$host);			$this-&gt;console(\"\t- Origin: \".$origin);			$this-&gt;console(\"\t- Sec-WebSocket-Key: \".$key);			$this-&gt;console(\"Generating Sec-WebSocket-Accept key...\");			$acceptKey = $key.'258EAFA5-E914-47DA-95CA-C5AB0DC85B11';			$acceptKey = base64_encode(sha1($acceptKey, true));			$upgrade = \"HTTP/1.1 101 Switching Protocols\r\n\".					   \"Upgrade: websocket\r\n\".					   \"Connection: Upgrade\r\n\".					   \"Sec-WebSocket-Accept: $acceptKey\".					   \"\r\n\r\n\";			$this-&gt;console(\"Sending this response to the client #{$client-&gt;getId()}:\r\n\".$upgrade);			socket_write($client-&gt;getSocket(), $upgrade);			$client-&gt;setHandshake(true);			$this-&gt;console(\"Handshake is successfully done!\");			return true;		}		else {			$this-&gt;console(\"WebSocket version 13 required (the client supports version {$version})\");			return false;		}	}	/**	 * Disconnect a client and close the connection	 * @param $socket	 */	private function disconnect($client) {		$this-&gt;console(\"Disconnecting client #{$client-&gt;getId()}\");		$client-&gt;setIsConnected(false);		$i = array_search($client, $this-&gt;clients);		$j = array_search($client-&gt;getSocket(), $this-&gt;sockets);		if($j &gt;= 0) {			if($client-&gt;getSocket()) {				array_splice($this-&gt;sockets, $j, 1);				socket_shutdown($client-&gt;getSocket(), 2);				socket_close($client-&gt;getSocket());				$this-&gt;console(\"Socket closed\");			}		}		if($i &gt;= 0) {			array_splice($this-&gt;clients, $i, 1);		}		$this-&gt;console(\"Client #{$client-&gt;getId()} disconnected\");	}	/**	 * Get the client associated with the socket	 * @param $socket	 * @return A client object if found, if not false	 */	private function getClientBySocket($socket) {		foreach($this-&gt;clients as $client)			if($client-&gt;getSocket() == $socket) {				$this-&gt;console(\"Client found\");				return $client;			}		return false;	}	/**	 * Do an action	 * @param $client	 * @param $action	 */	private function action($client, $action) {		$action = $this-&gt;unmask($action);		$this-&gt;console(\"Performing action: \".$action);		if($action == \"exit\" || $action == \"quit\") {			$this-&gt;console(\"Killing a child process\");			posix_kill($client-&gt;getPid(), SIGTERM);			$this-&gt;console(\"Process {$client-&gt;getPid()} is killed!\");		}	}	/**	 * Run the server	 */	public function run() {		$this-&gt;console(\"Start running...\");		$this-&gt;console(\"Open in a browser: websocket_client.html (http)\");		$i = 1;		while(true) {			$changed_sockets = $this-&gt;sockets;			if($changed_sockets) {				@socket_select($changed_sockets, $write = NULL, $except = NULL, 1);				foreach($changed_sockets as $socket) {                    //如果是主机，则有新客户端请求连接					if($socket == $this-&gt;master) {						if(($acceptedSocket = socket_accept($this-&gt;master)) &lt; 0) {							$this-&gt;console(\"Socket error: \".socket_strerror(socket_last_error($acceptedSocket)));						}						else {							$this-&gt;console($i);							$this-&gt;connect($acceptedSocket);						}					}                    //有客户端的新数据到来或者关闭链接					else {						$this-&gt;console($i);						$this-&gt;console(\"Finding the socket that associated to the client...\");						$client = $this-&gt;getClientBySocket($socket);						if($client) {							$this-&gt;console(\"Receiving data from the client\");							$data = null;							while($bytes = @socket_recv($socket, $r_data, 2048, MSG_DONTWAIT)) {								$data .= $r_data;							}							if(!$client-&gt;getHandshake()) {								$this-&gt;console(\"Doing the handshake\");								if($this-&gt;handshake($client, $data)) {									$this-&gt;startProcess($client);								}								else {									$this-&gt;disconnect($client);								}							}							elseif($bytes === 0) {								$this-&gt;disconnect($client);							}							else {								// When received data from client								$this-&gt;action($client, $data);							}						}					}				}			}			$i ++;		}	}	/**	 * Start a child process for pushing data	 * @param unknown_type $client	 */	private function startProcess($client) {		$this-&gt;console(\"Start a client process\");		$pid = pcntl_fork();		if($pid == -1) {			die('could not fork');		}		elseif($pid) { // process			$client-&gt;setPid($pid);		}		else {			// we are the child			while(true) {				// check if the client is connected				if(!$client-&gt;isConnected()){					break;				}				// push something to the client				$seconds = rand(2, 5);				$this-&gt;send($client, \"I am waiting {$seconds} seconds\");				sleep($seconds);			}		}	}	/**	 * Send a text to client	 * @param $client	 * @param $text	 */	private function send($client, $text) {		$this-&gt;console(\"Send '\".$text.\"' to client #{$client-&gt;getId()}\");		$text = $this-&gt;encode($text);		if(socket_write($client-&gt;getSocket(), $text, strlen($text)) === false) {			$this-&gt;console(\"Unable to write to client #{$client-&gt;getId()}'s socket\");			$this-&gt;disconnect($client);		}	}	/**	 * Encode a text for sending to clients via ws://	 * @param $text	 * @param $messageType	 */	function encode($message, $messageType='text') {		switch ($messageType) {			case 'continuous':				$b1 = 0;				break;			case 'text':				$b1 = 1;				break;			case 'binary':				$b1 = 2;				break;			case 'close':				$b1 = 8;				break;			case 'ping':				$b1 = 9;				break;			case 'pong':				$b1 = 10;				break;		}			$b1 += 128;		$length = strlen($message);		$lengthField = \"\";		if($length &lt; 126) {			$b2 = $length;		} elseif($length &lt;= 65536) {			$b2 = 126;			$hexLength = dechex($length);			//$this-&gt;stdout(\"Hex Length: $hexLength\");			if(strlen($hexLength)%2 == 1) {				$hexLength = '0' . $hexLength;			}			$n = strlen($hexLength) - 2;			for($i = $n; $i &gt;= 0; $i=$i-2) {				$lengthField = chr(hexdec(substr($hexLength, $i, 2))) . $lengthField;			}			while(strlen($lengthField) &lt; 2) {				$lengthField = chr(0) . $lengthField;			}		} else {			$b2 = 127;			$hexLength = dechex($length);			if(strlen($hexLength) % 2 == 1) {				$hexLength = '0' . $hexLength;			}			$n = strlen($hexLength) - 2;			for($i = $n; $i &gt;= 0; $i = $i - 2) {				$lengthField = chr(hexdec(substr($hexLength, $i, 2))) . $lengthField;			}			while(strlen($lengthField) &lt; 8) {				$lengthField = chr(0) . $lengthField;			}		}		return chr($b1) . chr($b2) . $lengthField . $message;	}	/**	 * Unmask a received payload	 * @param $buffer	 */	private function unmask($payload) {		$length = ord($payload[1]) &amp; 127;		if($length == 126) {			$masks = substr($payload, 4, 4);			$data = substr($payload, 8);		}		elseif($length == 127) {			$masks = substr($payload, 10, 4);			$data = substr($payload, 14);		}		else {			$masks = substr($payload, 2, 4);			$data = substr($payload, 6);		}		$text = '';		for($i = 0; $i &lt; strlen($data); ++$i) {			$text .= $data[$i] ^ $masks[$i%4];		}		return $text;	}	/**	 * Print a text to the terminal	 * @param $text the text to display	 * @param $exit if true, the process will exit	 */	private function console($text, $exit = false) {		$text = date('[Y-m-d H:i:s] ').$text.\"\r\n\";		if($exit) {			die($text);		}		if($this-&gt;verboseMode) {			echo $text;		}	}}?&gt;client.php/** * Define a Client object * @author Sann-Remy Chea &lt;http://srchea.com&gt; * @license This program is free software: you can redistribute it and/or modify * it under the terms of the GNU General Public License as published by * the Free Software Foundation, either version 3 of the License, or * (at your option) any later version. * This program is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the * GNU General Public License for more details. * You should have received a copy of the GNU General Public License * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;. * @version 1.0.0 */namespace PushWebSocket;class Client {	private $id;	private $socket;	private $handshake;	private $pid;	private $isConnected;	public function __construct($id, $socket) {		$this-&gt;id = $id;		$this-&gt;socket = $socket;		$this-&gt;handshake = false;		$this-&gt;pid = null;		$this-&gt;isConnected = true;	}	public function getId() {		return $this-&gt;id;	}	public function getSocket() {		return $this-&gt;socket;	}	public function getHandshake() {		return $this-&gt;handshake;	}	public function getPid() {		return $this-&gt;pid;	}	public function isConnected() {		return $this-&gt;isConnected;	}	public function setId($id) {		$this-&gt;id = $id;	}	public function setSocket($socket) {		$this-&gt;socket = $socket;	}	public function setHandshake($handshake) {		$this-&gt;handshake = $handshake;	}	public function setPid($pid) {		$this-&gt;pid = $pid;	}	public function setIsConnected($isConnected) {		$this-&gt;isConnected = $isConnected;	}}run.php/** * A daemon of PHP Push WebSocket * @author Sann-Remy Chea &lt;http://srchea.com&gt; * @license This program is free software: you can redistribute it and/or modify * it under the terms of the GNU General Public License as published by * the Free Software Foundation, either version 3 of the License, or * (at your option) any later version. * This program is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the * GNU General Public License for more details. * You should have received a copy of the GNU General Public License * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;. * @version 1.0.0 */date_default_timezone_set('PRC');error_reporting(E_ALL);require_once './server.php'; // Autoload files using Composer autoloadrequire_once './client.php'; // Autoload files using Composer autoloadset_time_limit(0);// variables$address = '0.0.0.0';$port = 8080;$verboseMode = true;$server = new \PushWebSocket\Server($address, $port, $verboseMode);$server-&gt;run();client.html&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Test - PHP Push WebSocket&lt;/title&gt;&lt;meta charset=\"utf-8\" /&gt;&lt;script type=\"text/javascript\"&gt;var ws, url = 'ws://192.168.99.100:8080';window.onbeforeunload = function() {	ws.send('quit');};window.onload = function() {	try {		ws = new WebSocket(url);		write('Connecting... (readyState '+ws.readyState+')');		ws.onopen = function(msg) {			write('Connection successfully opened (readyState ' + this.readyState+')');		};		ws.onmessage = function(msg) {			write('Server says: '+msg.data);		};		ws.onclose = function(msg) {			if(this.readyState == 2)				write('Closing... The connection is going throught the closing handshake (readyState '+this.readyState+')');			else if(this.readyState == 3)				write('Connection closed... The connection has been closed or could not be opened (readyState '+this.readyState+')');			else				write('Connection closed... (unhandled readyState '+this.readyState+')');		};		ws.onerror = function(event) {			terminal.innerHTML = '&lt;li style=\"color: red;\"&gt;'+event.data+'&lt;/li&gt;'+terminal.innerHTML;		};	}	catch(exception) {		write(exception);	}};function write(text) {	var date = new Date();	var dateText = '['+date.getFullYear()+'-'+(date.getMonth()+1 &gt; 9 ? date.getMonth()+1 : '0'+date.getMonth()+1)+'-'+(date.getDate() &gt; 9 ? date.getDate() : '0'+date.getDate())+' '+(date.getHours() &gt; 9 ? date.getHours() : '0'+date.getHours())+':'+(date.getMinutes() &gt; 9 ? date.getMinutes() : '0'+date.getMinutes())+':'+(date.getSeconds() &gt; 9 ? date.getSeconds() : '0'+date.getSeconds())+']';	var terminal = document.getElementById('terminal');	terminal.innerHTML = '&lt;li&gt;'+dateText+' '+text+'&lt;/li&gt;'+terminal.innerHTML;}&lt;/script&gt;&lt;/head&gt;&lt;body&gt;	&lt;a href=\"client.html\" target=\"_blank\"&gt;Add another client&lt;/a&gt;	&lt;ul id=\"terminal\"&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;使用swoole&lt;?php$server = new swoole_websocket_server(\"0.0.0.0\", 8080);$server-&gt;on('open', function (swoole_websocket_server $server, $request) {    file_put_contents( __DIR__ .'/log.txt' , $request-&gt;fd);});$server-&gt;on('message', function (swoole_websocket_server $server, $frame) {    global $client;    $data = $frame-&gt;data;    $m = file_get_contents( __DIR__ .'/log.txt');    for ($i=1 ; $i&lt;= $m ; $i++) {        echo PHP_EOL . '  i is  ' . $i .  '  data  is '.$data  . '  m = ' . $m;        $server-&gt;push($i, $data );    }});$server-&gt;on('close', function ($ser, $fd) {    echo \"client {$fd} closed\n\";});$server-&gt;start();参考文章深入浅出讲解：php的socket通信  细说websocket - php篇  php socket_select() 说明"
                        } ,
                     
                        {
                          "title"    : "php实现守护进程",
                          "category" : "",
                          "tags"     : " php, 守护进程",
                          "url"      : "/2017/02/05/php-daemon.html",
                          "date"     : "February 5, 2017",
                          "excerpt"  : "守护进程应该能达到的要求 不依赖于当前会话，且无法打开控制终端。编写过程  1.假设当前进程为p  2.创建子进程c1，然后退出父进程p(进程组组长无法创建会话，这样c1就不是进程组组长)。  3.在c1进程中创建会话，此时进程c1为会话组长，并且可以打开控制终端。  4.在c1进程中创建子进程c2,退出父进程c1。  5.在c2进程中进行逻辑处理。实现&lt;?php// 创建子进程$pid = pcntl_fork();// 如果是父进程，退出if ($pid) {    exit($...",
                          "content"  : "守护进程应该能达到的要求 不依赖于当前会话，且无法打开控制终端。编写过程  1.假设当前进程为p  2.创建子进程c1，然后退出父进程p(进程组组长无法创建会话，这样c1就不是进程组组长)。  3.在c1进程中创建会话，此时进程c1为会话组长，并且可以打开控制终端。  4.在c1进程中创建子进程c2,退出父进程c1。  5.在c2进程中进行逻辑处理。实现&lt;?php// 创建子进程$pid = pcntl_fork();// 如果是父进程，退出if ($pid) {    exit($pid);}// 创建会话posix_setsid();// 创建子进程$pid = pcntl_fork();// 如果是父进程，退出if ($pid) {    exit($pid);}while(true) {    //逻辑处理    sleep(1);    echo '执行中';}参考文章  Linux信号列表详解  Linux-进程、进程组、作业、会话、控制终端详解  进程 、进程组、会话、控制终端之间的关系  php写守护进程（Daemon）  每天进步一点点——Linux中的文件描述符与打开文件之间的关系  Linux 系统文件描述符继承带来的危害  关于PHP的STDIN/STDOUT/STDERR  PHP高级编程之守护进程，实现优雅重启"
                        } ,
                     
                        {
                          "title"    : "mac使用rsync+fswatch实现目录文件实时同步",
                          "category" : "",
                          "tags"     : " 文件同步",
                          "url"      : "/2017/02/02/mac-rsync-fswatch.html",
                          "date"     : "February 2, 2017",
                          "excerpt"  : "安装rsyncbrew install rsync创建用户创建用户配置文件\etc\rsyncd.secrets  添加用户名:密码  这里我们设置用户名为root，密码123456，即root:123456配置创建配置文件 \etc\rsyncd.confuid = root                   #守护进程的用户权限gid = rootport = 873                   #rsync使用的端口，默认873address = 192.168.0.101...",
                          "content"  : "安装rsyncbrew install rsync创建用户创建用户配置文件\etc\rsyncd.secrets  添加用户名:密码  这里我们设置用户名为root，密码123456，即root:123456配置创建配置文件 \etc\rsyncd.confuid = root                   #守护进程的用户权限gid = rootport = 873                   #rsync使用的端口，默认873address = 192.168.0.101      # 本机的ip地址use chroot = yesuid = root                   #守护进程的用户权限gid = rootport = 873                   #rsync使用的端口，默认873address = 192.168.0.101      # 本机的ip地址use chroot = yesread only = no               # no客户端可上传文件,yes只读write only = no              # no客户端可下载文件,yes不能下载#list = yes                  # 是否提供资源列表hosts allow=192.168.0.101    # 本模块允许通过的IP地址hosts deny=*                 # 禁止主机IPmax connections = 5          # 客户端最大连接数目motd file = /etc/rsyncd.motdpid file = /var/run/rsyncd.pid   # 进程号存放位置log file = /var/log/rsyncd.log   # 日志位置lock file = /var/run/rsync.lock  # 锁文件存放位置transfer logging = yeslog format = %t %a %m %f %bsyslog facility = local3timeout = 300[phproot1]                            # 要同步的模块名path = /Users/Username/Document/Kitematic/nginx/htdocs/php1 # 要同步的目录list=yesignore errorsauth users = root                  # 登陆系统使用的用户名，没有默认为匿名。secrets file = /etc/rsyncd.secrets # 密码文件存放的位置comment = linuxsir tmp             # 这个名名称无所谓，最后模块名一直[phproot2]                            # 要同步的模块名path = /Users/Username/Document/Kitematic/nginx/htdocs/php2 # 要同步的目录list=yesignore errorsauth users = root                  # 登陆系统使用的用户名，没有默认为匿名。secrets file = /etc/rsyncd.secrets # 密码文件存放的位置comment = linuxsir tmp             # 这个名名称无所谓，最后模块名一直[phproot3]                            # 要同步的模块名path = /Users/Username/Document/Kitematic/nginx/htdocs/php3 # 要同步的目录list=yesignore errorsauth users = root                  # 登陆系统使用的用户名，没有默认为匿名。secrets file = /etc/rsyncd.secrets # 密码文件存放的位置comment = linuxsir tmp             # 这个名名称无所谓，最后模块名一直这里我们设置了3个同步模块，对应三个需要同步的目录启动sudo rsync --daemon --config=/etc/rsyncd.conf同步这里我们以同步/Users/Username/Document/Kitematic/nginx/htdocs/php1到/Users/Username/Document/Kitematic/nginx/htdocs/php2为例本地同步rsync -ave /Users/Username/Document/Kitematic/nginx/htdocs/php1/ /Users/Username/Document/Kitematic/nginx/htdocs/php2/远程同步rsync -ave ssh /Users/Username/Document/Kitematic/nginx/htdocs/php1/ username@192.168.0.101:phproot1/安装fswatchbrew install fswatch实时同步创建shell文件 rsync.sh#!/bin/zshfswatch /Users/zhongjunbin/Document/Kitematic/nginx/htdocs/php1/ | while read filedo    rsync -ave ssh /Users/Username/Document/Kitematic/nginx/htdocs/php1/ Username@192.168.0.101:phproot2/    rsync -ave ssh /Users/Username/Document/Kitematic/nginx/htdocs/php1/ Username@192.168.0.101:phproot3/    echo \"${file} was rsynced\" &gt;&gt; /usr/local/var/log/rsync.log 2&gt;&amp;1donefswatch /Users/zhongjunbin/Document/Kitematic/nginx/htdocs/php2/ | while read filedo    rsync -ave ssh /Users/Username/Document/Kitematic/nginx/htdocs/php1/ Username@192.168.0.101:phproot1/    rsync -ave ssh /Users/Username/Document/Kitematic/nginx/htdocs/php1/ Username@192.168.0.101:phproot3/    echo \"${file} was rsynced\" &gt;&gt; /usr/local/var/log/rsync.log 2&gt;&amp;1donefswatch /Users/zhongjunbin/Document/Kitematic/nginx/htdocs/php3/ | while read filedo    rsync -ave ssh /Users/Username/Document/Kitematic/nginx/htdocs/php1/ Username@192.168.0.101:phproot1/    rsync -ave ssh /Users/Username/Document/Kitematic/nginx/htdocs/php1/ Username@192.168.0.101:phproot2/    echo \"${file} was rsynced\" &gt;&gt; /usr/local/var/log/rsync.log 2&gt;&amp;1done后台运行shellsudo sh rsync.sh &amp;完成"
                        } ,
                     
                        {
                          "title"    : "数据库的事务处理",
                          "category" : "",
                          "tags"     : " 数据库, 分布式",
                          "url"      : "/2016/11/24/transaction-deal.html",
                          "date"     : "November 24, 2016",
                          "excerpt"  : "事务四个核心要素1.原子性  一组操作，要么都成功，要么都失败，不存在中间状态。  2.一致性  事务在提交或回滚时，对其他人来说，数据的状态是统一的，不存在其他状态。  最理想的状态是，数据提交后，所有的更改能立刻生效，但由于cpu运算，磁盘写入，内存写入需要时间，所以不可能达到立刻生效。  所以一般说的是逻辑上同时生效。  比如修改a，b两行数据，要保证一致性，对a，b加锁，修改数据，对a，b解锁。  3.隔离性  读未提交：什么锁也没有，别人可以读到中间状态（即为提交）数据。  读已...",
                          "content"  : "事务四个核心要素1.原子性  一组操作，要么都成功，要么都失败，不存在中间状态。  2.一致性  事务在提交或回滚时，对其他人来说，数据的状态是统一的，不存在其他状态。  最理想的状态是，数据提交后，所有的更改能立刻生效，但由于cpu运算，磁盘写入，内存写入需要时间，所以不可能达到立刻生效。  所以一般说的是逻辑上同时生效。  比如修改a，b两行数据，要保证一致性，对a，b加锁，修改数据，对a，b解锁。  3.隔离性  读未提交：什么锁也没有，别人可以读到中间状态（即为提交）数据。  读已提交：（读写锁）即不可重复读。在一个事务中，两次读取同样一条记录，数据可能会改变。  可重复读：（读写锁）在事务中读取的数据，在提交前不会被改变。 序列化：事务被处理为顺序执行。  4.持久性  事务执行完，数据就不会丢。单机事务从性能上看，读写锁在并行上并不理想，因为读的时候不能写，写的时候不能读。 于是MVCC出现了  MVCC是使用copy-on-write来解决这个问题  一个人开启一个事务，此时会申请一个事务id，此id是自增的且不会合并到全局id。在事务中，每执行一条sql都会令这个id递增，但只会读取到&lt;=自己事务id的数据， 这样就实现了数据读取不受事务外影响，即可重复读。而其他人只会读取&lt;=全局事务id的数据。在事务提交时，把该事务id更新到全局id。Q1: MVCC有解决版本冲突的问题吗？  Q2: 不同数据库的MVCC实现多机事务在单机事务中我们可以用锁来解决问题。可以用一个例子来说明这个问题，bob要给smith100块钱。  最简单的协议是,两段提交协议  Prepare(bob-100) at 机器a -&gt; Prepare(smith+100) at 机器b -&gt; commit(bob) -&gt; commit(smith)这样会引发一个性能问题，如果b机器一直无反馈，导致a机器一直处于等待状态，锁无法释放。如何改进呢？  其实smith并不需要很强的一致可见性，只要在合理时间内给smith加钱就行了。 在a机器做如下操作：  1.开启本地事务  2.读取bob账户  3.判断是否有充足余额  4.更新bob账户，bob－100  5.将需要给smith＋100写log，并且生成唯一的transactionID  6.事务关闭  7.异步发送通知消费者  在b机器做如下操作 查看去重表是否有相应transactionID，如果没有则  1.开启本地事务  2.smith＋100  3.将transactionID写入去重表  4.事务关闭  5.通知a机器已操作成功  如果有则通知a机器已操作成功Q1: 为何要使用去重表呢？ 因为b有可能会操作失败，或无反馈给a。此时a应继续发送通知，直到b反馈成功。 如果不用去重表，会导致b已操作成功，而a仍继续发送通知，让b去给smith＋100。  Q2: 如果bob是个消费大户，短时间内进行了大量购买，可能会让bob所在机器成为热点，可能会让事务在某个单节点大量堆积，导致挂掉。  可把写log操作放到另外一台机器，这样可以通过水平加log机器来防止热点产生。  Q3: 如果有几十个系统同时关注smith＋100这个操作呢？ 可以增加一个队列，使用推，拉，或推拉结合的方式将smith＋100这个操作加以分发，减少主机压力。"
                        } ,
                     
                        {
                          "title"    : "数据库的一致性与高可用",
                          "category" : "",
                          "tags"     : " 分布式",
                          "url"      : "/2016/11/24/consistency-highavailability.html",
                          "date"     : "November 24, 2016",
                          "excerpt"  : "在给定多台计算机，他们相互之间由网络相互连通，能够做到  1.数据每次成功写入，数据不会丢失，并且按照写入的顺序排列  2.给定安全级别，保证服务可用性，并尽可能减少机器消耗。2PC所谓的两个阶段是指：第一阶段：准备阶段(投票阶段)和第二阶段：提交阶段（执行阶段）。准备阶段事务协调者(事务管理器)给每个参与者(资源管理器)发送Prepare消息，每个参与者要么直接返回失败(如权限验证失败)，要么在本地执行事务，写本地的redo和undo日志，但不提交，到达一种“万事俱备，只欠东风”的状态。...",
                          "content"  : "在给定多台计算机，他们相互之间由网络相互连通，能够做到  1.数据每次成功写入，数据不会丢失，并且按照写入的顺序排列  2.给定安全级别，保证服务可用性，并尽可能减少机器消耗。2PC所谓的两个阶段是指：第一阶段：准备阶段(投票阶段)和第二阶段：提交阶段（执行阶段）。准备阶段事务协调者(事务管理器)给每个参与者(资源管理器)发送Prepare消息，每个参与者要么直接返回失败(如权限验证失败)，要么在本地执行事务，写本地的redo和undo日志，但不提交，到达一种“万事俱备，只欠东风”的状态。可以进一步将准备阶段分为以下三个步骤：  1）协调者节点向所有参与者节点询问是否可以执行提交操作(vote)，并开始等待各参与者节点的响应。  2）参与者节点执行询问发起为止的所有事务操作，并将Undo信息和Redo信息写入日志。（注意：若成功这里其实每个参与者已经执行了事务操作）  3）各参与者节点响应协调者节点发起的询问。如果参与者节点的事务操作实际执行成功，则它返回一个”同意”消息；如果参与者节点的事务操作实际执行失败，则它返回一个”中止”消息。提交阶段如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚(Rollback)消息；否则，发送提交(Commit)消息；参与者根据协调者的指令执行提交或者回滚操作，释放所有事务处理过程中使用的锁资源。(注意:必须在最后阶段释放锁资源)接下来分两种情况分别讨论提交阶段的过程。当协调者节点从所有参与者节点获得的相应消息都为”同意”时:1）协调者节点向所有参与者节点发出”正式提交(commit)”的请求。  2）参与者节点正式完成操作，并释放在整个事务期间内占用的资源。  3）参与者节点向协调者节点发送”完成”消息。  4）协调者节点受到所有参与者节点反馈的”完成”消息后，完成事务。如果任一参与者节点在第一阶段返回的响应消息为”中止”，或者 协调者节点在第一阶段的询问超时之前无法获取所有参与者节点的响应消息时：1）协调者节点向所有参与者节点发出”回滚操作(rollback)”的请求。  2）参与者节点利用之前写入的Undo信息执行回滚，并释放在整个事务期间内占用的资源。  3）参与者节点向协调者节点发送”回滚完成”消息。  4）协调者节点受到所有参与者节点反馈的”回滚完成”消息后，取消事务。不管最后结果如何，第二阶段都会结束当前事务。  二阶段提交看起来确实能够提供原子性的操作，但是不幸的事，二阶段提交还是有几个缺点的：  1.同步阻塞问题。执行过程中，所有参与节点都是事务阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。  2.单点故障。由于协调者的重要性，一旦协调者发生故障。参与者会一直阻塞下去。尤其在第二阶段，协调者发生故障，那么所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作。（如果是协调者挂掉，可以重新选举一个协调者，但是无法解决因为协调者宕机导致的参与者处于阻塞状态的问题）  3.数据不一致。在二阶段提交的阶段二中，当协调者向参与者发送commit请求之后，发生了局部网络异常或者在发送commit请求过程中协调者发生了故障，这回导致只有一部分参与者接受到了commit请求。而在这部分参与者接到commit请求之后就会执行commit操作。但是其他部分未接到commit请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据部一致性的现象。  4.二阶段无法解决的问题：协调者再发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。  由于二阶段提交存在着诸如同步阻塞、单点问题、脑裂等缺陷，所以，研究者们在二阶段提交的基础上做了改进，提出了三阶段提交。3PC三阶段提交（Three-phase commit），也叫三阶段提交协议（Three-phase commit protocol），是二阶段提交（2PC）的改进版本。与两阶段提交不同的是，三阶段提交有两个改动点。  1.引入超时机制。同时在协调者和参与者中都引入超时机制。  2.在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。  也就是说，除了引入超时机制之外，3PC把2PC的准备阶段再次一分为二，这样三阶段提交就有CanCommit、PreCommit、DoCommit三个阶段。CanCommit阶段3PC的CanCommit阶段其实和2PC的准备阶段很像。协调者向参与者发送commit请求，参与者如果可以提交就返回Yes响应，否则返回No响应。  1.事务询问 协调者向参与者发送CanCommit请求。询问是否可以执行事务提交操作。然后开始等待参与者的响应。  2.响应反馈 参与者接到CanCommit请求之后，正常情况下，如果其自身认为可以顺利执行事务，则返回Yes响应，并进入预备状态。否则反馈NoPreCommit阶段协调者根据参与者的反应情况来决定是否可以记性事务的PreCommit操作。根据响应情况，有以下两种可能。  假如协调者从所有的参与者获得的反馈都是Yes响应，那么就会执行事务的预执行。  1.发送预提交请求 协调者向参与者发送PreCommit请求，并进入Prepared阶段。  2.事务预提交 参与者接收到PreCommit请求后，会执行事务操作，并将undo和redo信息记录到事务日志中。  3.响应反馈 如果参与者成功的执行了事务操作，则返回ACK响应，同时开始等待最终指令。假如有任何一个参与者向协调者发送了No响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断。  1.发送中断请求 协调者向所有参与者发送abort请求。  2.中断事务 参与者收到来自协调者的abort请求之后（或超时之后，仍未收到协调者的请求），执行事务的中断。doCommit阶段该阶段进行真正的事务提交，也可以分为以下两种情况。执行提交  1.发送提交请求 协调接收到参与者发送的ACK响应，那么他将从预提交状态进入到提交状态。并向所有参与者发送doCommit请求。  2.事务提交 参与者接收到doCommit请求之后，执行正式的事务提交。并在完成事务提交之后释放所有事务资源。  3.响应反馈 事务提交完之后，向协调者发送Ack响应。  4.完成事务 协调者接收到所有参与者的ack响应之后，完成事务。中断事务  协调者没有接收到参与者发送的ACK响应（可能是接受者发送的不是ACK响应，也可能响应超时），那么就会执行中断事务。  1.发送中断请求 协调者向所有参与者发送abort请求  2.事务回滚 参与者接收到abort请求之后，利用其在阶段二记录的undo信息来执行事务的回滚操作，并在完成回滚之后释放所有的事务资源。3.反馈结果 参与者完成事务回滚之后，向协调者发送ACK消息  4.中断事务 协调者接收到参与者反馈的ACK消息之后，执行事务的中断。在doCommit阶段，如果参与者无法及时接收到来自协调者的doCommit或者rebort请求时，会在等待超时之后，会继续进行事务的提交。（其实这个应该是基于概率来决定的，当进入第三阶段时，说明参与者在第二阶段已经收到了PreCommit请求，那么协调者产生PreCommit请求的前提条件是他在第二阶段开始之前，收到所有参与者的CanCommit响应都是Yes。（一旦参与者收到了PreCommit，意味他知道大家其实都同意修改了）所以，一句话概括就是，当进入第三阶段时，由于网络超时等原因，虽然参与者没有收到commit或者abort响应，但是他有理由相信：成功提交的几率很大。 ）2PC与3PC的区别相对于2PC，3PC主要解决的单点故障问题，并减少阻塞，因为一旦参与者无法及时收到来自协调者的信息之后，他会默认执行commit。而不会一直持有事务资源并处于阻塞状态。但是这种机制也会导致数据一致性问题，因为，由于网络原因，协调者发送的abort响应没有及时被参与者接收到，那么参与者在等待超时之后执行了commit操作。这样就和其他接到abort命令并执行回滚的参与者之间存在数据不一致的情况。了解了2PC和3PC之后，我们可以发现，无论是二阶段提交还是三阶段提交都无法彻底解决分布式的一致性问题。Google Chubby的作者Mike Burrows说过， there is only one consensus protocol, and that’s Paxos” – all other approaches are just broken versions of Paxos. 意即世上只有一种一致性算法，那就是Paxos，所有其他一致性算法都是Paxos算法的不完整版。Paxos其实就是“少数服从多数”我们假定有A,B,C,D,E五台机器。kv系统需要put一个数据[key=Whisper -&gt; val=3306]到我们这5台机器上，要保证只要反馈为真，任意两台机器挂掉都不会丢失数据，并且可以保证高可用。怎么做：  首先,客户端随机选择一个节点，进行写入提交，这里我们随机选择了C这个节点，这时候C节点就是这次提议的发起人【也叫proposer，在老的2pc协议里也叫做coodinator】，当C收到这个提议的时候，C首先要做的事情是根据当前节点的最新全局global id，做一次自增操作，我们假定，在当时全局id,Global ID是0,所以，这个议案就被对应了一个编号，1—&gt;[key=Whisper -&gt; val=3306]。这里有两个我们经常犯的错误，下面做一个解说：  1.global id问题，在老的论文里，Lamport没有描述这个自增id是怎么生成的，所以大家的第一个疑问一般是问id怎么生成，从我目前能够看到的所有实现里面，基本上就是选择哪一台机器，就是以那台机器当前所保持的全局id(snapshot，可能不是全局来看的最高值，但没关系，只要是自己这台机器的最高值就行了)，然后做一下自增就行了。我们后面会看到协议如何保证非全局最高值的globalID提议会被拒绝以至于不能够形成决议。  2.global id —&gt;[key=Whisper -&gt; val=3306] . 这也是个会让人困惑的问题，在原文中，他被表示为一个key-value的形式，比如proposal[0-&gt;value] 。这会让人自然的联想到与数据库的kv相对应，key是0，value是value。然后就会困惑，这个数据是怎么和数据库对应起来的呢？这是我当时的困惑，现在也把他列在这里。其实很简单，这里的global id对应value.global id只是对paxos协议有意义，对于数据库，其实只需要关心value里面的数据即可，也即将global id —&gt;[key=Whisper -&gt; val=3306]里面的value: [key=Whisper-&gt; val=3306] 作为数据库构建映射时所需要的redoLog就行了，global id的作用只是告诉你这些数据的顺序是按照global id来排列的，其他无意义。我们回到文中，我们已经将这个新的议案标记了从C这台机器看起来最大的global id : 1—&gt;[key=Whisper -&gt; val=3306]。然后，他会尝试将这个信息发送给其余的A,B,D,E这几台机器。 我们来看这些机器的操作流程。 在这个过程中，Paxos将A,B,D,E叫做accepter【老的协议里没有区分，管这些都叫做参与者，cohorts】，他们的行为模式如下： 如果A,B,D,E这几台机器的globalID 小于C给出的决议的GID(1—&gt;[key=Whisper -&gt; val=3306])，那么就告诉C，这个决议被批准了。而如果A,B,D,E这几台机器的GlobalID 大于或等于C给出决议的GID.那么就告知C 这个决议不能够被批准。 我们假定A,B两台机器当时的Max(GID)是0 ，而D,E的Max(GID)是1.那么，A,B两台机器会反馈给C说协议被接受，这时候我们算算，C的议案有几票了？A+B+!C!，一定要算自己哦:) 。所以，这个议案有三票，5台机器的半数是3.超过法定人数，于是决议就被同意了。我们保持这个上下文，来看看D,E这边的情况。首先，要思考的问题是，为什么D,E的Max(GID)是1呢？ 其实很简单，D可能在C发起决议的同时，也发起了一个决议，我们假定这个决议是由D发起的，决议是 1—&gt;[key=taobao -&gt;val=1234]。既然D,E的Max(GID)是1，那么意味着E已经告知D,它同意了他的决议，但D马上会发现，A,B,C里面的任意一个都返回了D不同意。他的议案只拿到两票，没有通过，它虽然有点不爽，但也是没办法的事情啊。。这时候C的决议已经被多数派接受，所以他需要告知所有人，我的议案1—&gt;[key=Whisper -&gt; val=3306]已经被接受，你们去学习吧。zab协议(Paxos改进)zab协议把整个过程分为两个部分，第一个部分叫选总统，第二个部分叫进行决议。 选总统的过程比较特殊，这种模式，相对的给人感觉思路来源于lamport的面包房算法，这个我们后面讲。，选择的主要依据是：  1.如果有gid最大的机器，那么他是主机。  2.如果好几台主机的gid相同，那么按照序号选择最小的那个。所以，在开始的时候，给A,B,C,D,E进行编号，0,1,2,3,4。 第一轮的时候，因为大家的Max(gid)都是0，所以自然而然按照第二个规则，选择A作为主机。 然后，所有人都知道A是主机以后，无论谁收到的请求，都直接转发给A,由A机器去做后续的分发，这个分发的过程，我们叫进行决议。  进行决议的规则就简单很多了，对其他机器进行3pc 提交，但与3pc不同的是，因为是群发议案给所有其他机器，所以一个机器无反馈对大局是没有影响的，只有当在一段时间以后，超过半数没有反馈，才是有问题的时候，这时候要做的事情是，重新选择总统。 具体过程是，A会将决议precommit给B,C,D,E。然后等待，当B,C,D,E里面的任意两个返回收到后，就可以进行doCommit().否则进行doAbort(). 为什么要任意两个？原因其实也是一样的，为了防止脑裂，原则上只能大于半数，不能少于半数，因为一旦决议成立的投票数少于半数，那么就存在另立中央的可能，两个总统可不是闹着玩的。  定两个，就能够保证，任意“两台”机器挂掉，数据不丢:)，能够做到quorum。参考文章淘宝沈询"
                        } ,
                     
                        {
                          "title"    : "php线程安全",
                          "category" : "",
                          "tags"     : " php",
                          "url"      : "/2016/11/18/php-about-thred-safe.html",
                          "date"     : "November 18, 2016",
                          "excerpt"  : "线程不安全线程不安全就是不提供数据访问保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据。  比如一个 ArrayList 类，在添加一个元素的时候，它可能会有两步来完成：1. 在 Items[Size] 的位置存放此元素；2. 增大 Size 的值。  在单线程运行的情况下，如果 Size = 0，添加一个元素后，此元素在位置 0，而且 Size=1；  而如果是在多线程情况下，比如有两个线程，线程 A 先将元素1存放在位置 0。但是此时 CPU 调度线程A暂停，线程 B 得到...",
                          "content"  : "线程不安全线程不安全就是不提供数据访问保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据。  比如一个 ArrayList 类，在添加一个元素的时候，它可能会有两步来完成：1. 在 Items[Size] 的位置存放此元素；2. 增大 Size 的值。  在单线程运行的情况下，如果 Size = 0，添加一个元素后，此元素在位置 0，而且 Size=1；  而如果是在多线程情况下，比如有两个线程，线程 A 先将元素1存放在位置 0。但是此时 CPU 调度线程A暂停，线程 B 得到运行的机会。线程B向此 ArrayList 添加元素2，因为此时 Size 仍然等于 0 （注意，我们假设的是添加一个元素是要两个步骤，而线程A仅仅完成了步骤1），所以线程B也将元素存放在位置0。然后线程A和线程B都继续运行，都增加 Size 的值，结果Size等于2。处理http并发目前有两种响应请求方式  1.创建线程（线程不安全）  2.创建进程，每个进程都是单线程（线程安全）php自身是不响应http请求的，需要通过配置apache或nginx服务器来请求转发。apache支持两种并发模式  1.Worker MPM ,使用创建线程来处理并发，这种情况php需要选择线程安全版本  2.Prefork MPM 使用创建进程来处理并发其他像nginx,lighttpd使用FastCGI，都是通过进程来处理请求，所以不存在线程安全问题。php异步处理fsockopen,stream_socket等都是通过socket来创建进程实现异步处理，不存在线程安全。 curl是通过异步发起http请求来处理的，所以也不存在线程安全。php实现多线程可通过安装pthreads扩展库来实现，有线程安全问题，需要使用线程安全版本。"
                        } ,
                     
                        {
                          "title"    : "线程与cpu核",
                          "category" : "",
                          "tags"     : " 操作系统",
                          "url"      : "/2016/11/14/system-thread-cpu.html",
                          "date"     : "November 14, 2016",
                          "excerpt"  : "进程，线程，核之间的关联  1.一个应用普遍只占一个进程，一个进程可以衍生出多个线程，而核只与线程有关。  2.一个线程只能在一个核上面跑。单核CPU，程序可以创建多个线程，但他们并不是真正意义上的并行执行，因为他们只会占用一个核，所以只是切换速度较快，没察觉到。每个线程会分配差不多20ms的时间片，执行完时间片，会切换到其他线程，该线程会处于等待执行状态，等其他线程执行完，再继续执行20ms。如果遇到有某些操作比较耗时，又要及时反馈给用户，还是很有必要多线程的。多核CPU，应该多用多线程...",
                          "content"  : "进程，线程，核之间的关联  1.一个应用普遍只占一个进程，一个进程可以衍生出多个线程，而核只与线程有关。  2.一个线程只能在一个核上面跑。单核CPU，程序可以创建多个线程，但他们并不是真正意义上的并行执行，因为他们只会占用一个核，所以只是切换速度较快，没察觉到。每个线程会分配差不多20ms的时间片，执行完时间片，会切换到其他线程，该线程会处于等待执行状态，等其他线程执行完，再继续执行20ms。如果遇到有某些操作比较耗时，又要及时反馈给用户，还是很有必要多线程的。多核CPU，应该多用多线程，系统会把线程平均分配到每个核上面，一个核上面的线程处理参考上面的单核CPU。"
                        } ,
                     
                        {
                          "title"    : "监督学习与梯度下降",
                          "category" : "",
                          "tags"     : " 机器学习",
                          "url"      : "/2016/11/14/machinelearning-supervised.html",
                          "date"     : "November 14, 2016",
                          "excerpt"  : "假设一个问题有n个特征，线性函数为  其中   差值计算，其中m为训练数据  所以我们要求出当最小值时的特征参数值。主要有两种方式来求出  1.梯度下降  2.正则方程组梯度下降把计算结果与真实结果的差值比做山顶，通过找寻山的最大坡度下降，达到最快到达山脚，从而实现最小差值。对每个求导，得出最快下降梯度，然后沿着这梯度下降。学习速度或下降速度。python实例import numpy as npimport matplotlib.pyplot as pltx_train = np.arra...",
                          "content"  : "假设一个问题有n个特征，线性函数为  其中   差值计算，其中m为训练数据  所以我们要求出当最小值时的特征参数值。主要有两种方式来求出  1.梯度下降  2.正则方程组梯度下降把计算结果与真实结果的差值比做山顶，通过找寻山的最大坡度下降，达到最快到达山脚，从而实现最小差值。对每个求导，得出最快下降梯度，然后沿着这梯度下降。学习速度或下降速度。python实例import numpy as npimport matplotlib.pyplot as pltx_train = np.array([[1, 2], [2, 1], [2, 3], [3, 5], [1, 3], [4, 2], [7, 3], [4, 5], [11, 3], [8, 7]])y_train = np.array([7, 8, 10, 14, 8, 13, 20, 16, 28, 26])x_test  = np.array([[1, 4], [2, 2], [2, 5], [5, 3], [1, 5], [4, 1]])def h(x, theta0_guess, theta1_guess, theta2_guess):return theta0_guess + theta1_guess * x[0] + theta2_guess * x[1]def learn(learn_rate = 0.001,  variance = 0.00001):theta0_guess = 0theta1_guess = 0theta2_guess = 0diff = 10000dataSetCount = len(x_train)while (diff &gt; variance) :    sum0 = sum1 = sum2 = 0    for i in range(dataSetCount):        sum0 += (y_train[i] - h(x_train[i], theta0_guess, theta1_guess, theta2_guess))    for i in range(dataSetCount):        sum1 += (y_train[i] - h(x_train[i], theta0_guess, theta1_guess, theta2_guess)) * x_train[i][0]    for i in range(dataSetCount):        sum2 += (y_train[i] - h(x_train[i], theta0_guess, theta1_guess, theta2_guess)) * x_train[i][1]    theta0_guess += learn_rate * sum0    theta1_guess += learn_rate * sum1    theta2_guess += learn_rate * sum2    diff = 0    for i in range(dataSetCount):        diff += 1/2 * ((h(x_train[i], theta0_guess, theta1_guess, theta2_guess) - y_train[i]) ** 2)    plt.plot([h(x, theta0_guess, theta1_guess, theta2_guess) for x in x_train])return theta0_guess, theta1_guess, theta2_guessprint(learn())plt.show()输出结果如下：上述方法可实现收敛，但在针对大量数据的处理上性能差。批量梯度下降 每训练完一条数据，便更新值，这样可以只取其中一部分训练数据来训练，提高性能，但可能无法达到收敛。  正则方程组把训练数据集看成一个矩阵    且    得出    由性质  可得    使    推断出  python实例import numpy as npimport matplotlib.pyplot as pltx_train = np.matrix([[1, 1, 2], [1, 2, 1], [1, 2, 3], [1, 3, 5], [1, 1, 3], [1, 4, 2], [1, 7, 3], [1, 4, 5], [1, 11, 3], [1, 8, 7]])y_train = np.matrix([[7], [8], [10], [14], [8], [13], [20], [16], [28], [26]])def h(x, theta0_guess, theta1_guess, theta2_guess):    return theta0_guess + theta1_guess * x[1] + theta2_guess * x[2]def learn():    x_train_t = x_train.T    theta = (1 / (x_train_t * x_train)) * x_train_t * y_train    theta = np.asarray(theta).reshape(-1)    plot = []    for x in x_train:        x = np.asarray(x)[0]        plot.append(h(x, theta[0], theta[1], theta[2]))    plt.plot(plot)    plt.show()learn()"
                        } ,
                     
                        {
                          "title"    : "时间复杂度计算",
                          "category" : "",
                          "tags"     : " 算法",
                          "url"      : "/2016/11/13/time-complexity.html",
                          "date"     : "November 13, 2016",
                          "excerpt"  : "用大写O()来体现算法时间复杂度，称之为大O记法。推导大O阶1.用常数1取代运行时间中的所有加法常数。  2.在修改后的运行次数函数中，只保留最高阶项。  3.如果最高阶项存在且不是1，则去除与这个项相乘的常数。  4.得出大O阶。算法分析1.计算所有情况的平均值，称为平均时间复杂度2.计算最坏情况下的时间复杂度，称为最坏时间复杂度计算实例常数阶 O(1)int sum = 0, n = 100; /*执行一次*/sum = (1 + n) * n / 2; /*执行一次*/sum = (...",
                          "content"  : "用大写O()来体现算法时间复杂度，称之为大O记法。推导大O阶1.用常数1取代运行时间中的所有加法常数。  2.在修改后的运行次数函数中，只保留最高阶项。  3.如果最高阶项存在且不是1，则去除与这个项相乘的常数。  4.得出大O阶。算法分析1.计算所有情况的平均值，称为平均时间复杂度2.计算最坏情况下的时间复杂度，称为最坏时间复杂度计算实例常数阶 O(1)int sum = 0, n = 100; /*执行一次*/sum = (1 + n) * n / 2; /*执行一次*/sum = (1 + n) * n / 2; /*执行一次*/sum = (1 + n) * n / 2; /*执行一次*/sum = (1 + n) * n / 2; /*执行一次*/sum = (1 + n) * n / 2; /*执行一次*/sum = (1 + n) * n / 2; /*执行一次*/sum = (1 + n) * n / 2; /*执行一次*/printf(\"%d\", sum);线性阶 O(n)int sum = 0, n = 100, i;for(i = 0; i &lt; n; i++){    sum = (1 + n) * n / 2; /*执行一次*/}printf(\"%d\", sum);对数阶 O(logn)int count = 1;while(count &lt; n){    count = count * 2;}平方阶 O(n²)int i,j,sum = 0;for( i = 0; i &lt; n; i++){    for( j = iSS; j &lt; n; j++)    {        sum ++;    }}"
                        } ,
                     
                        {
                          "title"    : "排序",
                          "category" : "",
                          "tags"     : " 算法",
                          "url"      : "/2016/11/13/sort.html",
                          "date"     : "November 13, 2016",
                          "excerpt"  : "冒泡算法do  swapped = false  for i = 1 to indexOfLastUnsortedElement    if leftElement &gt; rightElement      swap(leftElement, rightElement)      swapped = truewhile swapped选择排序repeat (numOfElements - 1) times  set the first unsorted element as the m...",
                          "content"  : "冒泡算法do  swapped = false  for i = 1 to indexOfLastUnsortedElement    if leftElement &gt; rightElement      swap(leftElement, rightElement)      swapped = truewhile swapped选择排序repeat (numOfElements - 1) times  set the first unsorted element as the minimum  for each of the unsorted elements    if element &lt; currentMinimum      set element as new minimum  swap minimum with first unsorted position插入排序mark first element as sortedfor each unsorted element  'extract' the element  for i = lastSortedIndex to 0    if currentSortedElement &gt; extractedElement      move sorted element to the right by 1    else: insert extracted element归并排序split each element into partitions of size 1recursively merge adjancent partitions  for i = leftPartStartIndex to rightPartLastIndex inclusive    if leftPartHeadValue &lt;= rightPartHeadValue      copy leftPartHeadValue    else: copy rightPartHeadValuecopy elements back to original array统计排序create key (counting) arrayfor each element in list  increase the respective counter by 1for each counter, starting from smallest key  while counter is non-zero    restore element to list    decrease counter by 1基数排序create 10 buckets (queues) for each digit (0 to 9)for each digit placing  for each element in list    move element into respective bucket  for each bucket, starting from smallest digit    while bucket is non-empty      restore element to list"
                        } ,
                     
                        {
                          "title"    : "php实现session跨域",
                          "category" : "",
                          "tags"     : " php, session",
                          "url"      : "/2016/11/13/php-session.html",
                          "date"     : "November 13, 2016",
                          "excerpt"  : "session跨域在*.a.com上保存session，在客户端浏览器中会生成一个sessionID，作用范围仅仅是在a.com这个域名下，这个sessionID就是对应该服务器存储session文件的文件名，在用户打开浏览器访问a.com，浏览器会发送该sessionID去服务器找到该文件名，然后获取session。同服务器跨主域  由于sessionID只会在一个主域下面有效，所以要在另外一个域名下生成相应的sessionID。实现a.com&lt;?phpsession_start(...",
                          "content"  : "session跨域在*.a.com上保存session，在客户端浏览器中会生成一个sessionID，作用范围仅仅是在a.com这个域名下，这个sessionID就是对应该服务器存储session文件的文件名，在用户打开浏览器访问a.com，浏览器会发送该sessionID去服务器找到该文件名，然后获取session。同服务器跨主域  由于sessionID只会在一个主域下面有效，所以要在另外一个域名下生成相应的sessionID。实现a.com&lt;?phpsession_start();$ssid = session_id();$_SESSION['name'] = 'name';header('Location:http://www.b.com?ssid=' . $ssid);b.com&lt;?phpsession_id($_GET['ssid']);session_start();var_dump($_SESSION);这样就能在b.com域名下生成同样的sessionID，当然a.com和b.com找到是同个文件 有个问题： 如果传递不了sessionID，需要配置php.ini，让url支持或者使用p3p协议进行传输跨子域  只要设置session_set_cookie_params(1800 , ‘/’, ‘.a.com’);，就ok不同服务器跨主域  这个就比较蛋疼了，只能是把要设置session的参数传递到b.com，然后在该服务器下重新设置session，因为session文件在另外一台服务器不能被找到。跨子域  可以传递sessionID到b.com，然后生成相应的session文件，当然session文件内容也要传递过去。统一解决办法1.用两台服务器都能访问到的数据库服务器存储session  2.使用memcache"
                        } ,
                     
                        {
                          "title"    : "链表",
                          "category" : "",
                          "tags"     : " 数据结构",
                          "url"      : "/2016/11/13/link.html",
                          "date"     : "November 13, 2016",
                          "excerpt"  : "单链表查找temp = head, index = 0while (temp.data != input)  temp = temp.next , index++  if temp == null    return -1return index;插入  1.指定位置v = 90, k = 2Vertex temp1 = headwhile (--k!=0)  temp1 = temp1.nextVertex temp2 = temp1.nextVertex newVertex = new...",
                          "content"  : "单链表查找temp = head, index = 0while (temp.data != input)  temp = temp.next , index++  if temp == null    return -1return index;插入  1.指定位置v = 90, k = 2Vertex temp1 = headwhile (--k!=0)  temp1 = temp1.nextVertex temp2 = temp1.nextVertex newVertex = new Vertex(input)temp1.next = newVertexnewVertex.next = temp22.头部Vertex temp = new Vertex(input)temp.next = headhead = temp3.尾部Vertex temp = new Vertex(input)tail.next = temptail = temp删除  1.头部temp = headhead = head.nextdelete temp2.指定位置Vertex cur = headwhile (--k!=0)  cur = cur.nextVertex tobedeleted = cur.nextcur.next = cur.next.nextdelete tobedeleted3.尾部Vertex prev = headtemp = head.nextwhile (temp.next!=null)  temp = temp.next , prev = prev.nextprev.next = nulldelete temptail = prev堆栈插入Vertex temp = new Vertex(input)temp.next = headhead = temp取出temp = headhead = head.nextdelete temp队列入列Vertex temp = new Vertex(input)tail.next = temptail = temp出列temp = headhead = head.nextdelete temp双链表查找temp = head, index = 0while (temp.data != input)  temp = temp.next , index++  if temp == null    return -1return index;插入  1.指定位置Vertex temp1 = headwhile (--k!=0)  temp1 = temp1.nextVertex temp2 = temp1.nextVertex newVertex = new Vertex(input)newVertex.next = temp2 , temp2.prev = newVertextemp1.next = newVertex , newVertex.prev = temp12.头部Vertex temp = new Vertex(input)temp.next = headif (head!=null) head.prev = temphead = temp3.尾部Vertex temp = new Vertex(input)tail.next = temptemp.prev = tailtail = temp删除  1.头部temp = headhead = head.nextdelete tempif(head!=null) head.prev = null2.指定位置Vertex cur = headwhile (--k!=0)  cur = cur.nextVertex tobedeleted = cur.nextVertex temp = tobedeleted.nextdelete tobedeletedcur.next = temp, temp.prev = cur3.尾部temp = tailtail = tail.prevtail.next = nulldelete temp双端队列入列  1.头部Vertex temp = new Vertex(input)temp.next = headif (head!=null) head.prev = temphead = temp2.尾部Vertex temp = new Vertex(input)tail.next = temptemp.prev = tailtail = temp出列  1.头部temp = headhead = head.nextdelete tempif(head!=null) head.prev = null2.尾部temp = tailtail = tail.prevtail.next = nulldelete temp"
                        } ,
                     
                        {
                          "title"    : "jsonp实现异步请求跨域",
                          "category" : "",
                          "tags"     : " jsonp",
                          "url"      : "/2016/11/13/jsonp.html",
                          "date"     : "November 13, 2016",
                          "excerpt"  : "ajax 和 jsonp的区别  ajax是通过XmlHttpRequest来获取非本页内容，而jsonp是通过动态添加为什么jsonp能够跨服  因为在web调用js文件是不受跨服影响的，不仅如此，凡是拥有src属性的都有跨服的能力。实现一www.b.com/remote.jsalert(1)www.a.com/json.html&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www...",
                          "content"  : "ajax 和 jsonp的区别  ajax是通过XmlHttpRequest来获取非本页内容，而jsonp是通过动态添加为什么jsonp能够跨服  因为在web调用js文件是不受跨服影响的，不仅如此，凡是拥有src属性的都有跨服的能力。实现一www.b.com/remote.jsalert(1)www.a.com/json.html&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"&gt; &lt;html xmlns=\"http://www.w3.org/1999/xhtml\"&gt;&lt;head&gt;&lt;title&gt;&lt;/title&gt;&lt;script type=\"text/javascript\" src=\"http://remoteserver.com/remote.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;实例二现在我们在jsonp.html页面定义一个函数，然后在远程remote.js中传入数据进行调用。  www.a.com/json.html&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\"&gt;&lt;head&gt;&lt;title&gt;&lt;/title&gt;&lt;script type=\"text/javascript\"&gt;var localHandler = function(data){alert('我是本地函数，可以被跨域的remote.js文件调用，远程js带来的数据是：' + data.result);};&lt;/script&gt;&lt;script type=\"text/javascript\" src=\"http://remoteserver.com/remote.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;www.b.com/remote.jslocalHandler({\"result\":\"我是远程js带来的数据\"});实现三使用callback  www.a.com/json.html&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\"&gt;&lt;head&gt;&lt;title&gt;&lt;/title&gt;&lt;script type=\"text/javascript\"&gt;// 得到航班信息查询结果后的回调函数var flightHandler = function(data){    alert('你查询的航班结果是：票价 ' + data.price + ' 元，' + '余票 ' + data.tickets + ' 张。');};// 提供jsonp服务的url地址（不管是什么类型的地址，最终生成的返回值都是一段javascript代码）var url = \"http://www.b.com/json.php?callback=flightHandler\";// 创建script标签，设置其属性var script = document.createElement('script');script.setAttribute('src', url);// 把script标签加入head，此时调用开始document.getElementsByTagName('head')[0].appendChild(script);&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;www.b.com/json.php&lt;?phpecho $_GET['callback'] . '(' . json_encode(1) . ')';exit;####实例四 使用jquery&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\" &gt;&lt;head&gt;&lt;title&gt;Untitled Page&lt;/title&gt;&lt;script type=\"text/javascript\" src=\"jquery.min.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt;jQuery(document).ready(function(){    $.ajax({        type: \"get\",        async: false,        url: \"http://www.b.com/jsonp.php\",        dataType: \"jsonp\",        jsonp: \"callback\",//传递给请求处理程序或页面的，用以获得jsonp回调函数名的参数名(一般默认为:callback)        jsonpCallback:\"flightHandler\",//自定义的jsonp回调函数名称，默认为jQuery自动生成的随机函数名，也可以写\"?\"，jQuery会自动为你处理数据        success: function(json){            alert('您查询到航班信息：票价： ' + json.price + ' 元，余票： ' + json.tickets + ' 张。');        },        error: function(){            alert('fail');        }    });});&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;"
                        } ,
                     
                        {
                          "title"    : "哈希表",
                          "category" : "",
                          "tags"     : " 数据结构",
                          "url"      : "/2016/11/13/hash-table.html",
                          "date"     : "November 13, 2016",
                          "excerpt"  : "线性探查查找i = base = key%HT.length // get hashed indexwhile (true)  if (HT[i] == EMPTY) return \"not found\"  else if (HT[i] == key) return \"found at index i\"  else i = (base+step*1)%HT.length插入if HT is 1 item before full, prevent insertioni = base ...",
                          "content"  : "线性探查查找i = base = key%HT.length // get hashed indexwhile (true)  if (HT[i] == EMPTY) return \"not found\"  else if (HT[i] == key) return \"found at index i\"  else i = (base+step*1)%HT.length插入if HT is 1 item before full, prevent insertioni = base = key%HT.length // get hashed indexwhile (HT[i] != EMPTY || HT[i] != DELETED)  i = (base+step*1)%HT.lengthfound insertion point, insert key at HT[i]删除i = base = key%HT.length // get hashed indexwhile (true)  if (HT[i] == EMPTY) break // key not found  else if (HT[i] == key)    HT[i] = DELETED  else i = (base+step*1)%HT.length二次探查查找i = base = key%HT.length // get hashed indexwhile (true)  if (HT[i] == EMPTY) return \"not found\"  else if (HT[i] == key) return \"found at index i\"  else i = (base+step*step)%HT.length插入if HT is 1 item before full, prevent insertioni = base = key%HT.length // get hashed indexwhile (HT[i] != EMPTY || HT[i] != DELETED)  i = (base+step*step)%HT.lengthfound insertion point, insert key at HT[i]删除i = base = key%HT.length // get hashed indexwhile (true)  if (HT[i] == EMPTY) break // key not found  else if (HT[i] == key)    HT[i] = DELETED  else i = (base+step*step)%HT.length"
                        } ,
                     
                        {
                          "title"    : "位运算",
                          "category" : "",
                          "tags"     : " 算法",
                          "url"      : "/2016/11/13/bit-cal.html",
                          "date"     : "November 13, 2016",
                          "excerpt"  : "以S = 1001011,j = 0000000为例。获取第 i 标志位j = 0000001(shift left j) * iS AND j切换第 i 标志位j = 0000001(shift left j) * iS XOR j(XOR: 11 = 0 10 = 1 01 = 1 00 = 0)清除第 i 标志位j = 0000001(shift left j) * iinvert j(反转)S AND j获取最后一个有效位j = NOT(S)+1S AND jS = 1001011...",
                          "content"  : "以S = 1001011,j = 0000000为例。获取第 i 标志位j = 0000001(shift left j) * iS AND j切换第 i 标志位j = 0000001(shift left j) * iS XOR j(XOR: 11 = 0 10 = 1 01 = 1 00 = 0)清除第 i 标志位j = 0000001(shift left j) * iinvert j(反转)S AND j获取最后一个有效位j = NOT(S)+1S AND jS = 1001011j = 0000000获取第 i 标志位j = 0000001(shift left j) * iS AND j切换第 i 标志位j = 0000001(shift left j) * iS XOR j(XOR: 11 = 0 10 = 1 01 = 1 00 = 0)清除第 i 标志位j = 0000001(shift left j) * iinvert j(反转)S AND j获取最后一个有效位j = NOT(S)+1S AND jS = 1001011j = 0000000获取第 i 标志位j = 0000001(shift left j) * iS AND j切换第 i 标志位j = 0000001(shift left j) * iS XOR j(XOR: 11 = 0 10 = 1 01 = 1 00 = 0)清除第 i 标志位j = 0000001(shift left j) * iinvert j(反转)S AND j获取最后一个有效位j = NOT(S)+1S AND jS = 1001011j = 0000000获取第 i 标志位j = 0000001(shift left j) * iS AND j切换第 i 标志位j = 0000001(shift left j) * iS XOR j(XOR: 11 = 0 10 = 1 01 = 1 00 = 0)清除第 i 标志位j = 0000001(shift left j) * iinvert j(反转)S AND j获取最后一个有效位j = NOT(S)+1S AND j"
                        } ,
                     
                        {
                          "title"    : "php实现异步",
                          "category" : "",
                          "tags"     : " php",
                          "url"      : "/2016/11/12/php-async.html",
                          "date"     : "November 12, 2016",
                          "excerpt"  : "php在处理异步执行主要有以下四种方式来处理，其中第四种方式是最好的，推荐使用。1.ajax或嵌入img标签，在src中指向异步地址。  缺点 不能算是真正异步，主要用户关闭浏览器，异步脚本也就被终止掉了&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;img src=\"b.php\"&gt; &lt;script src=\"jquery.js\"&gt;&lt;/script&gt;&lt;script&gt;$(documen...",
                          "content"  : "php在处理异步执行主要有以下四种方式来处理，其中第四种方式是最好的，推荐使用。1.ajax或嵌入img标签，在src中指向异步地址。  缺点 不能算是真正异步，主要用户关闭浏览器，异步脚本也就被终止掉了&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;img src=\"b.php\"&gt; &lt;script src=\"jquery.js\"&gt;&lt;/script&gt;&lt;script&gt;$(document).ready(function(){    $.ajax({url:\"b.php\",async:false});});    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;2.popen  缺点 只能在命令行中执行本地脚本，如果访问量高，会产生大量进程pclose(popen(\"php -f /Users/zhongjunbin/Document/Kitematic/nginx/htdocs/b.php &amp;\", 'r'));3.curl  缺点 会有至少一秒的等待时间$ch = curl_init();$curl_opt = array(CURLOPT_URL, 'http://www.example.com/backend.php',                            CURLOPT_RETURNTRANSFER, 1,                            CURLOPT_TIMEOUT, 1,);curl_setopt_array($ch, $curl_opt);4.fsockopen 或 socker_stream_client  缺点 需要自己拼接http头信息&lt;?php$fp = fsockopen(\"192.168.99.100\", 80, $errno, $errstr, 30);if (!$fp) {    echo \"$errstr ($errno)&lt;br /&gt;\n\";} else {    $out = \"GET /b.php HTTP/1.1\r\n\";    $out .= \"Host: 192.168.99.100\r\n\";    $out .= \"Connection: Close\r\n\r\n\";    fwrite($fp, $out);    /*忽略执行结果    while (!feof($fp)) {        echo fgets($fp, 128);    }*/    fclose($fp);}&lt;?php$fp = stream_socket_client(\"192.168.99.100:80\", $errno, $errstr, 30);if (!$fp) {    echo \"$errstr ($errno)&lt;br /&gt;\n\";} else {    fwrite($fp, \"GET /b.php HTTP/1.0\r\nHost: 192.168.99.100\r\nAccept: */*\r\n\r\n\");    /*忽略执行结果    while (!feof($fp)) {         echo fgets($fp, 1024);    }*/    fclose($fp);}"
                        } ,
                     
                        {
                          "title"    : "NGINX+PHP运行原理",
                          "category" : "",
                          "tags"     : " php, nginx",
                          "url"      : "/2016/11/11/php-nginx.html",
                          "date"     : "November 11, 2016",
                          "excerpt"  : "前向代理与反向代理前向代理作为客户端的代理，将从互联网上获取的资源返回给一个或多个的客户端，服务器端（如Web服务器）只知道代理的IP地址而不知道客户端的IP地址。而反向代理是作为服务器端（如Web服务器）的代理使用，而不是客户端。客户端借由前向代理可以间接访问很多不同互联网服务器（簇）的资源，而反向代理是供很多客户端都通过它间接访问不同后端服务器上的资源，而不需要知道这些后端服务器的存在，而以为所有资源都来自于这个反向代理服务器。CGI通用网关接口（Common Gateway Inte...",
                          "content"  : "前向代理与反向代理前向代理作为客户端的代理，将从互联网上获取的资源返回给一个或多个的客户端，服务器端（如Web服务器）只知道代理的IP地址而不知道客户端的IP地址。而反向代理是作为服务器端（如Web服务器）的代理使用，而不是客户端。客户端借由前向代理可以间接访问很多不同互联网服务器（簇）的资源，而反向代理是供很多客户端都通过它间接访问不同后端服务器上的资源，而不需要知道这些后端服务器的存在，而以为所有资源都来自于这个反向代理服务器。CGI通用网关接口（Common Gateway Interface/CGI）是一种重要的互联网技术，可以让一个客户端，从网页浏览器向执行在网络服务器上的程序请求数据。CGI描述了服务器和请求处理程序之间传输数据的一种标准。CGI程序可以用任何脚本语言或者是完全独立编程语言实现，只要这个语言可以在这个系统上运行。除Perl外，像Unix shell script, Python, Ruby, PHP, Tcl, C/C++,和Visual Basic都可以用来编写CGI程序。工作方式  从Web服务器的角度看，是在特定的位置（比如：http://www.example.com/wiki.cgi）定义了可以运行CGI程序。当收到一个匹配URL的请求，相应的程序就会被调用，并将客户端发送的数据作为输入。程序的输出会由Web服务器收集，并加上合适的档头，再发送回客户端。缺点  一般每次的CGI请求都需要新生成一个程序的副本来运行，这样大的工作量会很快将服务器压垮，因此一些更有效的技术像mod_php，可以让脚本解释器直接作为模块集成在Web服务器（例如：Apache）中，这样就能避免重复载入和初始化解释器。不过这只是就那些需要解释器的高级语言（即解释语言）而言的，使用诸如C一类的编译语言则可以避免这种额外负荷。由于C及其他编译语言的程序与解释语言程序相比，前者的运行速度更快、对操作系统的负荷更小，使用编译语言程序是可能达到更高执行效率的，然而因为开发效率等原因，在目前直译性语言还是最合适的。FAST-CGI快速通用网关接口（Fast Common Gateway Interface／FastCGI）是一种让交互程序与Web服务器通信的协议。FastCGI是早期通用网关接口（CGI）的增强版本。  FastCGI致力于减少网页服务器与CGI程序之间交互的开销，从而使服务器可以同时处理更多的网页请求。CGI使外部程序与Web服务器之间交互成为可能。CGI程序运行在独立的进程中，并对每个Web请求创建一个进程，这种方法非常容易实现，但效率很差，难以扩展。面对大量请求，进程的大量创建和消亡使操作系统性能大大下降。此外，由于地址空间无法共享，也限制了资源重用。与为每个请求创建一个新的进程不同，FastCGI使用持续的进程来处理一连串的请求。这些进程由FastCGI服务器管理，而不是web服务器。 当进来一个请求时，web服务器把环境变量和这个页面请求通过一个socket比如FastCGI进程与web服务器（都位于本地）或者一个TCP connection（FastCGI进程在远端的server farm）传递给FastCGI进程。PHP-FPM全称php-Fastcgi Process Manager，是对FastCGI的实现，并提供了进程管理的功能。进程包含 master 进程和 worker 进程两种进程。master 进程只有一个，负责监听端口，接收来自 Web Server 的请求，而 worker 进程则一般有多个(具体数量根据实际需要配置)，每个进程内部都嵌入了一个 PHP 解释器，是 PHP 代码真正执行的地方。执行流程Nginx 不仅仅是一个 Web 服务器，也是一个功能强大的 Proxy 服务器，除了进行 http 请求的代理，也可以进行许多其他协议请求的代理，包括本文与 fpm 相关的 fastcgi 协议。为了能够使 Nginx 理解 fastcgi 协议，Nginx 提供了 fastcgi 模块来将 http 请求映射为对应的 fastcgi 请求。Nginx 的 fastcgi 模块提供了 fastcgi_param 指令来主要处理这些映射关系，下面 Ubuntu 下 Nginx 的一个配置文件，其主要完成的工作是将 Nginx 中的变量翻译成 PHP 中能够理解的变量。Nginx 的 fastcgi 模块提供了 fastcgi_param 指令来主要处理这些映射关系，下面 Ubuntu 下 Nginx 的一个配置文件，其主要完成的工作是将 Nginx 中的变量翻译成 PHP 中能够理解的变量。fastcgi_param  QUERY_STRING       $query_string;fastcgi_param  REQUEST_METHOD     $request_method;fastcgi_param  CONTENT_TYPE       $content_type;fastcgi_param  CONTENT_LENGTH     $content_length;fastcgi_param  SCRIPT_NAME        $fastcgi_script_name;fastcgi_param  REQUEST_URI        $request_uri;fastcgi_param  DOCUMENT_URI       $document_uri;fastcgi_param  DOCUMENT_ROOT      $document_root;fastcgi_param  SERVER_PROTOCOL    $server_protocol;fastcgi_param  REQUEST_SCHEME     $scheme;fastcgi_param  HTTPS              $https if_not_empty;fastcgi_param  GATEWAY_INTERFACE  CGI/1.1;fastcgi_param  SERVER_SOFTWARE    nginx/$nginx_version;fastcgi_param  REMOTE_ADDR        $remote_addr;fastcgi_param  REMOTE_PORT        $remote_port;fastcgi_param  SERVER_ADDR        $server_addr;fastcgi_param  SERVER_PORT        $server_port;fastcgi_param  SERVER_NAME        $server_name;# PHP only, required if PHP was built with --enable-force-cgi-redirectfastcgi_param  REDIRECT_STATUS    200;除此之外，非常重要的就是 fastcgi_pass 指令了，这个指令用于指定 fpm 进程监听的地址，Nginx 会把所有的 php 请求翻译成 fastcgi 请求之后再发送到这个地址。下面一个简单的可以工作的 Nginx 配置文件：server {    listen       80; #监听80端口，接收http请求    server_name  www.example.com; #就是网站地址    root /usr/local/etc/nginx/www/huxintong_admin; # 准备存放代码工程的路径    #路由到网站根目录www.example.com时候的处理    location / {        index index.php; #跳转到www.example.com/index.php        autoindex on;    }       #当请求网站下php文件的时候，反向代理到php-fpm    location ~ \.php$ {        include /usr/local/etc/nginx/fastcgi.conf; #加载nginx的fastcgi模块        fastcgi_intercept_errors on;        fastcgi_pass   127.0.0.1:9000; #这个指令用于指定 fpm 进程监听的地址，Nginx 会把所有的 php 请求翻译成 fastcgi 请求之后再发送到这个地址    }}具体流程如下： graph TD;    www.example.com--&gt;Nginx    Nginx--&gt;路由到www.example.com/index.php    路由到www.example.com/index.php--&gt;加载nginx的fast-cgi模块    加载nginx的fast-cgi模块--&gt;发送到127.0.0.1:9000地址    发送到127.0.0.1:9000地址--&gt;PHP-FPM监听到发送到这个端口的请求    PHP-FPM监听到发送到这个端口的请求--&gt;等待处理参考链接代理服务器-wiki  反向代理-wiki  通用网关接口-wiki  FastCGI-wiki  Nginx+Php-fpm运行原理详解  深入理解PHP之：Nginx 与 FPM 的工作机制"
                        } 
                     ,
                     
                       {
                         
                            "title"    : "Ninja",
                            "category" : "",
                            "tags"     : " Lorem",
                            "url"      : "/portfolio/ninja",
                            "date"     : "April 8, 2014",
                            "excerpt"  : "",
                            "content"  : "Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt. Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem. Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? Quis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, vel illum qui dolorem eum fugiat quo voluptas nulla pariatur?"
                         
                       } ,
                     
                       {
                         
                            "title"    : "Creative",
                            "category" : "",
                            "tags"     : " Ipsum",
                            "url"      : "/portfolio/safe",
                            "date"     : "August 16, 2014",
                            "excerpt"  : "",
                            "content"  : "Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt. Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem. Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? Quis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, vel illum qui dolorem eum fugiat quo voluptas nulla pariatur?Use this area of the page to describe your project. The icon above is part of a free icon set by Flat Icons. On their website, you can download their free set with 16 icons, or you can purchase the entire set with 146 icons for only $12!"
                         
                       } ,
                     
                       {
                         
                            "title"    : "Circus",
                            "category" : "",
                            "tags"     : " Ipsum",
                            "url"      : "/portfolio/circus",
                            "date"     : "September 1, 2014",
                            "excerpt"  : "",
                            "content"  : "Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt. Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem. Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? Quis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, vel illum qui dolorem eum fugiat quo voluptas nulla pariatur?"
                         
                       } ,
                     
                       {
                         
                            "title"    : "Tower of Hanoi",
                            "category" : "",
                            "tags"     : " ",
                            "url"      : "/portfolio/hanoi",
                            "date"     : "September 1, 2014",
                            "excerpt"  : "",
                            "content"  : "Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt. Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem. Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? Quis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, vel illum qui dolorem eum fugiat quo voluptas nulla pariatur?"
                         
                       } ,
                     
                       {
                         
                            "title"    : "Tic tac toe",
                            "category" : "",
                            "tags"     : " ",
                            "url"      : "/portfolio/tictactoe",
                            "date"     : "September 1, 2014",
                            "excerpt"  : "",
                            "content"  : "Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt. Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem. Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? Quis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, vel illum qui dolorem eum fugiat quo voluptas nulla pariatur?"
                         
                       } ,
                     
                       {
                         
                            "title"    : "Cake",
                            "category" : "",
                            "tags"     : " Lorem, Ipsum, Portfolio",
                            "url"      : "/portfolio/cake",
                            "date"     : "September 27, 2015",
                            "excerpt"  : "",
                            "content"  : "Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt. Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem. Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? Quis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, vel illum qui dolorem eum fugiat quo voluptas nulla pariatur?Use this area of the page to describe your project. The icon above is part of a free icon set by Flat Icons. On their website, you can download their free set with 16 icons, or you can purchase the entire set with 146 icons for only $12!"
                         
                       } ,
                     
                       {
                         
                            "title"    : "Jekyll",
                            "category" : "",
                            "tags"     : " ",
                            "url"      : "/portfolio/jekyllblog",
                            "date"     : "May 26, 2017",
                            "excerpt"  : "",
                            "content"  : "Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt. Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem. Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? Quis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, vel illum qui dolorem eum fugiat quo voluptas nulla pariatur?"
                         
                       } ,
                     
                       {
                         
                            "title"    : "Lorem Ipsum",
                            "category" : "",
                            "tags"     : " ",
                            "url"      : "/portfolio/submarine",
                            "date"     : "September 3, 2017",
                            "excerpt"  : "",
                            "content"  : "Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt. Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem. Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? Quis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, vel illum qui dolorem eum fugiat quo voluptas nulla pariatur?Use this area of the page to describe your project. The icon above is part of a free icon set by Flat Icons. On their website, you can download their free set with 16 icons, or you can purchase the entire set with 146 icons for only $12!"
                         
                       } ,
                     
                       {
                         
                            "title"    : "Github",
                            "category" : "",
                            "tags"     : " Lorem, Portfolio",
                            "url"      : "/portfolio/gitlecture",
                            "date"     : "October 20, 2017",
                            "excerpt"  : "",
                            "content"  : "Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt. Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem. Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? Quis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, vel illum qui dolorem eum fugiat quo voluptas nulla pariatur?"
                         
                       } 
                     
                    
                  ],
            searchResultTemplate: '<div class="search-title"><a href="{url}"><h3> {title}</h3></a><div class="meta">{date} <div class="right"><i class="fa fa-tag"></i> {tags}</div></div><p>{excerpt}</p></div><hr> ',
            noResultsText: 'No results found',
            limit: 10,
            fuzzy: false,
            exclude: []
        })
    </script>
</section>
</section>
    
    
  <!-- Tag list for portfolio -->
  
  


<footer>
  <div class="tag-list"></div>
</footer>

    
</article>

    </div>
    
<footer class="site-footer">
    <p class="text">Powered by <a href="https://jekyllrb.com/">Jekyll</a> with <a href="https://github.com/sylhare/Type-on-Strap">Type on Strap</a>
</p>
            <div class="footer-icons">
                <ul>
                <!-- Social icons from Font Awesome, if enabled -->
                
<li>
	<a href="http://localhost:4000/feed.xml" title="Follow RSS feed">
		<span class="fa-stack fa-lg">
            <i class="fa fa-circle fa-stack-2x"></i>
            <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
        </span>
	</a>
</li>















<li>
	<a href="https://github.com/shadowdragons" title="Follow on GitHub">
		<span class="fa-stack fa-lg">
            <i class="fa fa-circle fa-stack-2x"></i>
            <i class="fa fa-github fa-stack-1x fa-inverse"></i>
        </span>
	</a>
</li>
































                </ul>
            </div>
</footer>




  </body>
</html>
